# -*- coding: utf-8 -*-
import os
import socket

import myscm.common.constants
import myscm.client.config

from myscm.common.parser import CommandLineFlagConfigOption
from myscm.common.parser import ConfigParser
from myscm.common.parser import GeneralChoiceConfigOption
from myscm.common.parser import GeneralConfigOption
from myscm.common.parser import ParserError
from myscm.common.parser import ValidatedCommandLineConfigOption
from myscm.common.parser import ValidatedFileConfigOption
from myscm.server.sysimggenerator import SystemImageGenerator

_APP_VERSION = myscm.common.constants.get_app_version("myscm-cli")
_HELP_DESC = '''This is client side of the mySCM application â€“ simple Software
Configuration Management (SCM) tool for managing software and configuration of
the clients running GNU/Linux distributions. This application is intended to
apply GNU/Linux system image created with myscm-srv application.'''


class ClientParserError(ParserError):
    pass


##################################
# Client's configuration options #
##################################


class ApplySysImgConfigOption(ValidatedCommandLineConfigOption):
    """Configuration option read from CLI specifying to apply changes read
       from given system image (which is tar.gz archive)."""

    def __init__(self):
        super().__init__(
            "ApplyImg", None, self._assert_sys_img_version_valid,
            "--apply-img", metavar="SYS_IMG_VER",
            type=self._assert_sys_img_version_valid,
            help="apply changes to the system updating it to the system state "
                 "identified by unique SYS_IMG_VER integer (which is Y "
                 "integer in {}; X is integer representing current state of "
                 "the system)".format(
                    SystemImageGenerator.MYSCM_IMG_FILE_NAME.format("X", "Y")))

    def _assert_sys_img_version_valid(self, sys_img_ver):
        # After parsing RecentlyAppliedSysImgVerPathConfigOption we need to
        # check if system image myscm-img.X.Y.tar.gz exist (X is recently
        # applied myscm system image version and Y is sys_img_ver).
        return myscm.common.parser.assert_sys_img_ver_valid(sys_img_ver)


class UpdateSysImgConfigOption(ValidatedCommandLineConfigOption):
    """Configuration option read from CLI specifying to update system image
       by downloading it from other client or server."""

    def __init__(self):
        super().__init__(
            "UpdateSysImg", False, self._assert_ip_valid, "--update",
            metavar="IP_ADDR", type=self._assert_ip_valid, nargs="?",
            const=True,
            help="update system image by downloading it from one of the "
                 "clients (chosen randomly) predefined in configuration file "
                 "or by IP_ADDR if given; protocol that is used for "
                 "connection is defined by --protocol option or by "
                 "configuration file if --protocol option is not present")

    def _assert_ip_valid(self, ip_str):
        is_bool_var = isinstance(ip_str, bool)

        if is_bool_var:  # if --update or --update not specified
            return ip_str

        valid_ip = True

        try:
            socket.inet_aton(ip_str)
        except socket.error:
            valid_ip = False

        if not valid_ip:
            m = "Not valid IP address '{}'".format(ip_str)
            raise ClientParserError(m)

        return ip_str


class UpgradeSysImgConfigOption(CommandLineFlagConfigOption):
    """Configuration option read from CLI specifying to update system image
       by downloading it from other client or server and then to apply
       downloaded system image."""

    def __init__(self):
        super().__init__(
            "UpgradeSysImg", "--upgrade SYS_IMG_VER",
            help="equivalent of running --update and --apply-img SYS_IMG_VER "
                 "option")


class SSLCertConfigOption(GeneralConfigOption):
    """Configuration option read from file and/or CLI specifying SSL
       certificate file path to verify system image created by myscm-srv."""

    # default if not provided in config file
    DEFAULT_SSL_CERT_PATH = "/etc/myscm-cli/ssl.sig"

    def __init__(self, ssl_cert_path=None):
        super().__init__(
            "SSLCertPath",
            ssl_cert_path or self.DEFAULT_SSL_CERT_PATH,
            self._assert_ssl_cert_path_valid, True, "--ssl-cert",
            metavar="PATH", type=self._assert_ssl_cert_path_valid,
            help="full path to the server's SSL certificate that is being "
                 "used to verify signature of the system image generated by "
                 "the myscm-srv (default value: '{}')".format(
                    self.DEFAULT_SSL_CERT_PATH))

    def _assert_ssl_cert_path_valid(self, cert_path):
        """SSL certificate path option validator."""

        if not os.path.isfile(cert_path):
            m = "Given SSL certificate file '{}' probably doesn't exist"\
                .format(cert_path)
            raise ClientParserError(m)

        return cert_path


class UpdateProtocolConfigOption(GeneralChoiceConfigOption):
    """Configuration option read from file and/or CLI specifying which protocol
       should be preferred to download new system image from one of the
       predefined client. This option makes sense only with --update and
       --upgrade options."""

    ALLOWED_PROTOCOLS = ["SFTP"]
    DEFAULT_PROTOCOL = "SFTP"  # default if not provided in config file

    def __init__(self, protocol=None):
        super().__init__(
            "SysImgUpdateProtocol", protocol or self.DEFAULT_PROTOCOL,
            self.ALLOWED_PROTOCOLS, True, "-p", "--protocol", metavar="PROTO",
            help="select protocol that will be used to download newest system "
                 "image generated by myscm-srv (default is '{}', allowed "
                 "options are: '{}'); this option makes sense only with "
                 "--update and --upgrade options".format(
                    self.DEFAULT_PROTOCOL,
                    "', '".join(self.ALLOWED_PROTOCOLS)))


class PeersListConfigOption(ValidatedFileConfigOption):
    """Configuration option read from file specifying IP adresses of the peers
       that share mySCM system images. --update and --upgrade options use this
       list to randomly select client that will be used to download mySCM
       system image (unless IP is explicitly specified for those options)."""

    def __init__(self):
        super().__init__(
            "PeersList", [], self._assert_peers_list_valid, True)

    def _assert_peers_list_valid(self, peers_str):
        peers_list = peers_str.lstrip("[").rstrip("]").split(",")

        for i in range(len(peers_list)):
            valid_ip = True
            ip = peers_list[i].strip()

            try:
                socket.inet_aton(ip)
            except socket.error:
                valid_ip = False

            if not valid_ip:
                m = "One of the IP addresses assigned to variable PeersList "\
                    "is not valid (has value: '{}')".format(ip)
                raise ClientParserError(m)

            peers_list[i] = ip

        return peers_list


class VerifySysImgConfigOption(ValidatedCommandLineConfigOption):
    """Configuration option read from CLI specifying to verify signature of
       the given system image."""

    def __init__(self):
        super().__init__(
            "VerifySysImg", None, self._assert_sys_img_to_verify_valid,
            "--verify-img", metavar="PATH",
            type=self._assert_sys_img_to_verify_valid,
            help="verify signature of the given system image")

    def _assert_sys_img_to_verify_valid(self, sys_img_path):
        """System image path option validator."""

        if not os.path.isfile(sys_img_path):
            m = "Given myscm system image file '{}' probably doesn't exist"\
                .format(sys_img_path)
            raise ClientParserError(m)

        signature_path = sys_img_path + SystemImageGenerator.SIGNATURE_EXT

        if not os.path.isfile(signature_path):
            m = "Given myscm system image file '{}' doesn't have expected "\
                "corresponding '{}' certificate".format(sys_img_path,
                                                        signature_path)
            raise ClientParserError(m)

        return sys_img_path


class ForceApplyConfigOption(CommandLineFlagConfigOption):
    """Configuration option read from CLI specifying do not bother user with
       interactive questions."""

    def __init__(self):
        super().__init__(
            "ForceApply", "--force",
            help="take default actions and do not ask interactive questions "
                 "while --apply-img")


class SFTPUsernameConfigOption(ValidatedFileConfigOption):
    """Configuration option read from CLI specifying SFTP username being used
       to connect to other client to download newest system image."""

    def __init__(self):
        super().__init__(
            "SFTPUsername", None, self._assert_sftp_username_valid, False)

    def _assert_sftp_username_valid(self, sftp_username):
        if sftp_username == "":
            raise ClientParserError("SFTP username cannot be empty")

        return sftp_username


class SFTPPasswordConfigOption(ValidatedFileConfigOption):
    """Configuration option read from CLI specifying SFTP password being used
       to connect to other client to download newest system image."""

    def __init__(self):
        super().__init__(
            "SFTPPassword", None, self._assert_sftp_passwd_valid, False)

    def _assert_sftp_passwd_valid(self, sftp_passwd):
        if sftp_passwd == "":
            raise ClientParserError("SFTP password cannot be empty")

        return sftp_passwd


class ListSysImgConfigOption(CommandLineFlagConfigOption):
    """Configuration option read from CLI specifying to list all available
       system images created by myscm-srv."""

    def __init__(self):
        super().__init__(
            "ListSysImg", "-l", "--list",
            help="list all locally available system images created by "
                 "myscm-srv")


class SysImgExtractDirConfigOption(ValidatedFileConfigOption):

    DEFAULT_SYS_IMG_EXTRACT_DIR = "/tmp"

    def __init__(self, sys_img_extract_dir=None):
        super().__init__(
            "SysImgExtractDir",
            sys_img_extract_dir or self.DEFAULT_SYS_IMG_EXTRACT_DIR,
            self._assert_sys_img_extract_dir_valid, True)

    def _assert_sys_img_extract_dir_valid(self, sys_img_extract_dir):
        if not os.path.isdir(sys_img_extract_dir):
            m = "Value '{}' assigned to variable '{}' doesn't refer to "\
                "directory".format(sys_img_extract_dir, self.name)
            raise ClientParserError(m)

        return sys_img_extract_dir


class SysImgDownloadDirConfigOption(ValidatedFileConfigOption):

    DEFAULT_SYS_IMG_DOWNLOAD_DIR = "/var/lib/myscm-cli/downloaded"

    def __init__(self, sys_img_download_dir=None):
        super().__init__(
            "SysImgDownloadDir",
            sys_img_download_dir or self.DEFAULT_SYS_IMG_DOWNLOAD_DIR,
            self._assert_sys_img_download_dir_valid, True)

    def _assert_sys_img_download_dir_valid(self, sys_img_download_dir):
        if not os.path.isdir(sys_img_download_dir):
            m = "Value '{}' assigned to variable '{}' doesn't refer to "\
                "directory".format(sys_img_download_dir, self.name)
            raise ClientParserError(m)

        return sys_img_download_dir


class RecentlyAppliedSysImgVerPathConfigOption(ValidatedFileConfigOption):

    DEFAULT_RECENT_IMG_VER_PATH = "/var/myscm-cli/id.myscm"
    OPTION_NAME = "RecentSysImgVerPath"

    def __init__(self, recent_img_ver_path=None):
        super().__init__(
            self.OPTION_NAME,
            recent_img_ver_path or self.DEFAULT_RECENT_IMG_VER_PATH,
            self._assert_recent_img_ver_path_valid, True)

    def _assert_recent_img_ver_path_valid(self, recent_img_ver_path):
        if os.path.isfile(recent_img_ver_path):
            # It's OK if this file doesn't exist yet
            assert_recent_img_ver_file_content_valid(recent_img_ver_path)

        return recent_img_ver_path


class PrintSysImgVerConfigOption(CommandLineFlagConfigOption):

    def __init__(self):
        super().__init__(
            "PrintSysImgVer", "--print-ver",
            help="print recently applied mySCM system image version (if no "
                 "image was applied yet, then -1 is printed)")


def assert_recent_img_ver_file_content_valid(recent_img_ver_path):
    ver = -1
    first_line = None
    second_line = None
    var_name = RecentlyAppliedSysImgVerPathConfigOption.OPTION_NAME

    try:
        with open(recent_img_ver_path) as f:
            first_line = f.readline().strip()
            second_line = f.readline()
    except Exception as e:
        m = "Unable to open '{}' assigned to variable '{}'".format(
            recent_img_ver_path, var_name)
        raise ClientParserError(m, e) from e

    if not first_line:
        m = "'{}' assigned to '{}' is empty".format(recent_img_ver_path,
                                                    var_name)
        raise ClientParserError(m)

    if second_line:
        m = "'{}' assigned to '{}' is expected to have one line with version "\
            "of the recently applied myscm system image".format(
                recent_img_ver_path, var_name)
        raise ClientParserError(m)

    try:
        ver = int(first_line)
    except:
        m = "First and only line of the '{}' line is supposed to be integer "\
            "corresponding to recently applied myscm system image version "\
            "(current value: '{}')".format(recent_img_ver_path,
                                           first_line.strip())
        raise ClientParserError(m)

    if ver < 0:
        m = "Negative integer assigned to the recent system version read "\
            "from file '{}'".format(recent_img_ver_path)
        raise ClientParserError(m)

    return ver


#############################################
# Core of the client's configuration parser #
#############################################


class ClientConfigParser(ConfigParser):
    """Application configuration parser for configuration read from both
       configuration file and command line (CLI)."""

    def __init__(self, config_path, config_section_name):
        _CLIENT_DEFAULT_CONFIG = [
            ApplySysImgConfigOption(),
            UpdateSysImgConfigOption(),
            UpgradeSysImgConfigOption(),
            SSLCertConfigOption(),
            UpdateProtocolConfigOption(),
            PeersListConfigOption(),
            VerifySysImgConfigOption(),
            ForceApplyConfigOption(),
            SFTPUsernameConfigOption(),
            SFTPPasswordConfigOption(),
            ListSysImgConfigOption(),
            SysImgExtractDirConfigOption(),
            SysImgDownloadDirConfigOption(),
            RecentlyAppliedSysImgVerPathConfigOption(),
            PrintSysImgVerConfigOption()
        ]
        super().__init__(config_path, config_section_name,
                         _CLIENT_DEFAULT_CONFIG, _HELP_DESC, _APP_VERSION)

    def parse(self):
        self._parse()
        client_config = myscm.client.config.ClientConfig(self.config)
        return client_config
