\documentclass[thesis]{subfiles}

\begin{document}

%------------------------------------------------------------------------------

\chapter{Istniejące rozwiązania}
\label{ch:istniejace-rozwiazania}

W~niniejszym rozdziale przedstawiono przegląd czterech, prawdopodobnie jednych z~najpopularniejszych obecnie rozwiązań dla~problemu dystrybuowania oprogramowania w~sieci~\cite{leading-scms,wiki:scm-comparison}.

Wymienione w~tym rozdziale aplikacje, poza możliwością synchronizacji zainstalowanego oprogramowania i~konfiguracji, pozwalają również na~inne manipulacje systemem operacyjnym, np.~zapewnienie istnienia zadanego użytkownika w~systemie czy zapewnienie działanie zadanego \glslink{demon}{demona}. Takie oprogramowanie jest nazywane często w~skrócie~\emph{Software Configuration Management~(SCM)}, implementującym podejście \emph{Infrastructure as~Code}~\cite{wiki:iac,wiki:scm}.

%---------------------------------------

\section{Puppet}
\label{sec:puppet}

Jednym z~najpopularniejszych istniejących rozwiązań problemu dystrybuowania oprogramowania jest projekt Puppet, który jest dedykowany nie tylko dla systemów~\glslink{unix-like-system}{*niksowych}, ale~również dla~systemów \emph{Windows} i~\emph{Mac~OS}~\cite{puppet,puppet-github,puppet-clients}.

Puppet został napisany w~języku programowania \href{https://en.wikipedia.org/wiki/Ruby_(programming_language)}{Ruby}, a~jego rozwój jest wspierany i~wykorzystywany przez wiele czołowych firm i~organizacji w~branży~IT, takich jak: \emph{Google}, \emph{NASA}, \emph{Verizon}, \emph{Sony}, \emph{Disney}, \emph{Uber}, \emph{gettyimages}, \emph{CERN} i~wiele innych~\cite{puppet,puppet-google,puppet-cern,puppet-chef-disney}. Pierwsza wersja Puppet została opublikowana w~2005~roku na~licencji~\glslink{gpl}{GPL}. Od~wersji 2.0~Puppet jest licencjonowany na~warunkach licencji~\glslink{apache2.0-license}{Apache~2.0}. Istnieje również komercyjna wersja projektu, znana pod~nazwą \emph{Puppet Enterprise}.

Konfiguracja Puppet polega na~napisaniu reguł tekstowych, niezależnych od~systemu operacyjnego (\emph{Domain Specific Language}), przechowywanych zwyczajowo w~plikach z~rozszerzeniem~\texttt{.pp}, zwanych manifestami. Reguły są~zapisane w~postaci deklaratywnej, a~nie imperatywnej, tzn.~opisują oczekiwany stan systemu, a~nie sposób przeprowadzenia zmian w~systemie. Struktura manifestu jest w~postaci tablicy asocjacyjnej (struktura danych \hreftt{https://docs.ruby-lang.org/en/trunk/Hash.html}{Hash}) z~języka programowania Ruby. Przykładowe manifesty przedstawiono na~listingach \ref{lst:puppet-openssh-example}, \ref{lst:puppet-motd-example} i~\ref{lst:puppet-httpd-example}~\cite{puppet-examples}. Poprawność składni w~manifeście \path{example.pp} można zweryfikować komendą:
\begin{center}
	\texttt{puppet parser validate example.pp}
\end{center}

Aby~wprowadzić zmiany opisane manifestem \texttt{example.pp}, wystarczy uruchomić komendę:
\begin{center}
	\texttt{puppet apply example.pp}
\end{center}

Przed dokonaniem zmian w~systemie pomocna może być flaga \texttt{-{}-noop}, która uruchomia tryb \emph{dry run}, tzn.~tryb w~którym nie są dokonywane żadne zmiany w~systemie, a~na standardowym wyjściu są drukowane zmiany jakie by~zaszły, gdyby nie użyć tej flagi.

\begin{minipage}{\linewidth} % żeby listing nie był podzielony na 2 stronach
\begin{lstlisting}[numbers=none,caption={Manifest Puppet gwarantujący, że~pakiet \texttt{openssh-client}, dostarczający klienta SSH, jest zainstalowany},label=lst:puppet-openssh-example]
package { 'openssh-client':
  ensure => present,
}
\end{lstlisting}
\end{minipage}

\begin{lstlisting}[numbers=none,caption={Manifest Puppet gwarantujący istnienie pliku \hreftt{https://en.wikipedia.org/wiki/Motd_(Unix)}{/etc/motd} z~komunikatem \texttt{Hello!}, który wyświetla się~użytkownikom systemu po~zalogowaniu},label=lst:puppet-motd-example]
file { 'motd':
  path => '/etc/motd',
  content => 'Hello!',
}
\end{lstlisting}

\begin{lstlisting}[numbers=none,caption={Manifest Puppet gwarantujący, że~\gls{demon} \hreftt{https://httpd.apache.org/}{httpd} jest włączony i~działa},label=lst:puppet-httpd-example]
service { 'httpd':
  ensure => running,
  enable => true,
}
\end{lstlisting}

W~nomenklaturze Puppeta istnieje co~najmniej kilka słów kluczowych, które odpowiadają abstrakcyjnym typom danych reprezentującym klientów i~ich oprogramowanie. Najważniejsze z~nich to:\mynobreakpar
\begin{itemize}
\item \texttt{class} --- Nazwany blok kodu Puppet przechowywany w~\hyperlink{itm:puppetmodule}{module}. Służy do~konfiguracji dużej części funkcjonalności aplikacji. Konfiguracja \hyperlink{itm:puppetnode}{węzła} pozwala zadeklarować parametryzowane użycie wielu różnych klas. Deklaracja klasy może być co~najwyżej jedna.
\item \hypertarget{itm:puppetmodule}{\texttt{module}} --- Zbiór klas konfigurujący całą aplikację. Społeczność Puppet dostarcza na~stronie internetowej \hreftt{https://forge.puppet.com/}{forge.puppet.com} wielu użytecznych modułów do~różnych rodzajów złożonego oprogramowania. Najpopularniejsze z~nich są~weryfikowane przez programistów Puppet i~otrzymują status \emph{Puppet Supported} lub~\emph{Puppet Approved}, przez co~są postrzegane jako zaufane.
\item \hypertarget{itm:puppetnode}{\texttt{node}} --- Węzeł. Reprezentacja jednego lub~wielu klientów.
\item Wbudowane typy zasobów, takie jak: \texttt{cron}, \texttt{exec}, \texttt{file}, \texttt{group}, \texttt{host}, \texttt{maillist}, \texttt{mount}, \texttt{package}, \texttt{router}, \texttt{service}, \texttt{ssh\_authorized\_key}, \texttt{user}, \texttt{vlan}, \texttt{zone}, \texttt{zone\_pool} i~wiele innych. Listę tą można rozszerzać o~własne typy danych np.~przez załadowanie dodatkowych modułów~\cite{puppet-resources-types}.
\end{itemize}
W~praktyce często jest pożądane automatyczne odpytywanie serwera przez klienta. Klient Puppeta domyślnie odpytuje serwer o~zmiany oprogramowania co~30~minut. Konfiguracja serwera odpowiadająca za~zdefiniowanie klas oprogramowania dla~poszczególnych klientów jest przechowywana w~pliku zwyczajowo nazywanym \path{site.pp}.

\urldef\etchosts\path{%SystemRoot%\system32\drivers\etc\hosts}

W~przykładach~\ref{lst:puppet-openssh-example}, \ref{lst:puppet-motd-example}, \ref{lst:puppet-httpd-example} zostały użyte trzy, różne zasoby, odpowiednio: pakiet oprogramowania~(\texttt{package}), plik~(\texttt{file}) oraz~serwis~(\texttt{service}). Puppet udostępnia również inne rodzaje zasobów takie jak: użytkownik~(\texttt{user}), grupa~(\texttt{group}), zdarzenie cykliczne~(\texttt{cron}), wykonanie komendy~(\texttt{exec}), wpis w~pliku \path{/etc/hosts}\footnote{Lub odpowiedniku pliku \path{/etc/hosts} w~systemach nie \glslink{unix-like-system}{*nixowych}, np.~\etchosts~w~nowych wersjach systemów Windows.}. Pełną listę wbudowanych typów zasobów można uzyskać wywołując komendę \texttt{puppet describe --list}. Aby~dowiedzieć się~więcej o~wybranym typie zasobu \texttt{X}, wystarczy wydać komendę:
\begin{center}
	\texttt{puppet describe~X}
\end{center}

Puppet składa się~z~wielu narzędzi towarzyszących. Jednym z~nich jest \texttt{facter}, który na~żądanie zbiera informacje o~systemie i~wyświetla je w~jednym z~możliwych formatów: \hreftt{https://en.wikipedia.org/wiki/JSON}{JSON}, \hreftt{https://en.wikipedia.org/wiki/YAML}{YAML} lub~\hreftt{https://en.wikipedia.org/wiki/Plaintext}{plaintext}, który jest formatem domyślnym. Wywołanie komendy \texttt{facter} bez dodatkowych parametrów, wyświetla wszystkie dane o~systemie, jakie zebrało to~narzędzie.

Dla~nowych użytkowników Puppeta została przygotowana przez opiekunów projektu maszyna wirtualna z~samouczkiem tak, aby użytkownik nie~był skazany na~naukę Puppeta na~własnym systemie~\cite{puppet-vm-tutorial}. W~przypadku błędnej konfiguracji Puppeta, stan maszyny wirtualnej z~samouczkiem może być~łatwo przywrócony, co~może nie~być takie proste w~przypadku nieudanych prób eksperymentów na~własnym systemie.

%---------------------------------------

\section{Chef}
\label{sec:chef}

Chef jest oprogramowaniem napisanym w~językach programowania \href{https://en.wikipedia.org/wiki/Ruby_(programming_language)}{Ruby} (tak jak Puppet) i~\href{https://en.wikipedia.org/wiki/Erlang_(programming_language)}{Erlang} (zastosowanym tylko do~API w~części serwerowej). Projekt został zapoczątkowany przez \href{https://blog.chef.io/author/adam/}{Adama Jacoba} na~potrzeby firmy consultingowej, ale~po~zaprezentowaniu go~pracownikowi firmy \emph{Amazon} --- \href{https://en.wikipedia.org/wiki/Jesse_Robbins}{Jesse Robinsowi} --- został został opublikowany na~zasadach licencji \glslink{apache2.0-license}{Apache~2.0} i~zaadaptowany do~użycia w~firmie \emph{Amazon}. Pierwsza wersja Chef została opublikowana w~2009~roku.

Chef działa w~architekturze klient--serwer. Serwer może być uruchomiony na~systemach operacyjnych: \emph{CentOS}, \emph{Oracle Linux}, \emph{Red Hat Enterprise Linux} i~\emph{Ubuntu}. Serwer można również próbować uruchomić na~systemach \emph{Mac~OS~X} i~\emph{Microsoft Windows} --- dokumentacja Chef wyszczególnia te~systemy jako nieprzetestowane pod~kątem współpracy z~Chef~\cite{chef-supported-platforms}.

Klientami mogą być systemy działające pod~kontrolą m.in.: \emph{AIX}, \emph{CentOS}, \emph{FreeBSD}, \emph{Mac~OS~X}, \emph{Oracle Linux}, \emph{Red Hat Enterprise Linux}, \emph{Solaris}, \emph{Ubuntu}, \emph{Microsoft Windows}, \emph{Cisco NX-OS} i~\emph{Cisco IOS XR}~\cite{chef-supported-platforms}. Lista wspieranych systemów operacyjnych dla~maszyn działających w~roli klienta jest większa, ale są~one określone jako \emph{Secondary Platforms} i~\emph{Other Platforms} w~przeciwieństwie do~wymienionych, które są~określane jako~\emph{Foundational Platforms}.

Użytkownikami Chefa, tak jak w~przypadku Puppeta, jest wiele dużych firm i~uniwersytetów, takich jak: \emph{Airbnb}, \emph{Disney}, \emph{Mozilla}, \emph{Facebook}, \emph{HP Public Cloud}, \emph{Prezi}, \emph{Uniwersytet Minnesoty}~\cite{chef-customers,puppet-chef-disney}.

Odpowiednikiem plików konfiguracyjnych, które w~Puppet nazywane są~\emph{manifestami}, są~pliki nazywane w~nomenklaturze Chef \emph{przepisami}~(ang.~\emph{recipe}). Przykładowe przepisy przedstawiono w~przykładach~\ref{lst:chef-apache-example}, \ref{lst:chef-user-example} i~\ref{lst:chef-service-example}. Więcej przykładów można znaleźć w,~bogatej w~przykładowe przepisy, dokumentacji Chef~\cite{chef-examples}.

\begin{lstlisting}[numbers=none,caption={Przepis Chef gwarantujący, że~serwer Apache zostanie zainstalowany niezależnie od~tego jak~się~nazywa pakiet oprogramowania go~dostarczający},label=lst:chef-apache-example]
package 'Install Apache' do
  case node[:platform]
  when 'redhat', 'centos'
    package_name 'httpd'
  when 'ubuntu', 'debian'
    package_name 'apache2'
  end
end
\end{lstlisting}

\begin{lstlisting}[numbers=none,caption={Przepis Chef gwarantujący, że~użytkownik \texttt{xyz} istnieje w~systemie i~ma zadane ustawienia konta},label=lst:chef-user-example]
user 'xyz' do
  comment 'A random user'
  uid '1234'
  gid '1234'
  home '/home/random'
  shell '/bin/bash'
  password '$1$JJsvHslasdfjVEroftprNn4JHtDi'
end
\end{lstlisting}

\begin{lstlisting}[numbers=none,caption={Przepis Chef gwarantujący, że~serwis \texttt{example\_service} jest uruchomiony},label=lst:chef-service-example]
service 'example_service' do
  action :start
end
\end{lstlisting}

%---------------------------------------

\section{Ansible}
\label{sec:ansible}

Ansible jest rozwiązaniem do~zarządzania oprogramowaniem różniącym się od~Puppet i~Chef tym, że~do~konfiguracji klientów \glslink{unix-like-system}{*nixowych} używa~SSH, a~do~klientów Windows \hrefemph{http://superuser.com/questions/184926/winrm-what-it-is-and-how-to-use-it}{WinRM} i~\hrefemph{https://en.wikipedia.org/wiki/PowerShell}{PowerShell}, dzięki czemu klienci nie~muszą uruchamiać żadnych dodatkowych procesów działających w~tle --- Ansible działa w~trybie \emph{agentless}, tzn.~klienci nie mają żadnego dedykowanego oprogramowania do~obsługi Ansible. Autorzy projektu Ansible podkreślają na~swojej stronie internetowej, że~w~przeciwieństwie do~konkurencji, Ansible nie jest skomplikowany, przez co~jego szybkie opanowanie jest łatwe~\cite{ansible}.

Listing~\ref{lst:ansible-inventory-example} przedstawia przykładową konfigurację serwera dotyczącą klientów zarządzanych przez serwer Ansible~\cite{ansible-example}. Po~zapisanu takiej konfiguracji, Ansible można wykorzystać do~uruchomienia komendy na~wybranej grupie klientów. Np.~komenda:
\begin{center}
\texttt{ansible all -s -m shell -a 'apt-get install nginx'}
\end{center}
zainstaluje serwer HTTP \hreftt{https://www.nginx.com/}{nginx} na wszystkich klientach. Flaga \texttt{-m} wybiera moduł (w~tym wypadku moduł \texttt{shell}), \texttt{-s} zapewnia, że~komenda będzie uruchomiona z~użyciem \hreftt{https://en.wikipedia.org/wiki/Sudo}{sudo}, a~\texttt{-a} pozwala na~przekazanie parametru do~użytego modułu. Taka forma użycia Ansible jest najprostsza i~nie pozwala w~pełni wykorzystać możliwości Ansible. Trochę lepszym, deklaratywnym sposobem, wykorzystującym moduł~\texttt{apt} jest wywołanie:
\begin{center}
\texttt{ansible all -s -m apt -a 'pkg=nginx state=installed update\_cache=true'}
\end{center}
które zwraca wynik na~standardowym wyjściu w~postaci~\texttt{JSON}:
\begin{lstlisting}[numbers=none,frame=none]
127.0.0.1 | success >> {
    "changed": false
}
\end{lstlisting}
Powyższe sposoby uruchamiania Ansible są wykorzystaniem Ansible~\emph{ad-hoc}. Możliwości Ansible w~pełni ujawniają się, gdy~wykorzystamy \hrefemph{http://docs.ansible.com/playbooks_intro.html}{Playbook}, czyli odpowiednik manifestu Puppeta. Przykładowy \emph{Playbook} z~listingu~\ref{lst:ansible-playbook-example} przedstawia sposób zainstalowania na~grupie komputerów o~nazwie \texttt{web}~(por.~\ref{lst:ansible-inventory-example}) serwera \texttt{nginx}, stworzenia pliku serwowanego przez serwer, a~następnie uruchomienia \glslink{demon}{demona} serwera. Zmiany opisane przez \emph{Playbook} można dokonać za~pomocą komendy:
\begin{center}
\texttt{ansible-playbook -s nginx.yml}
\end{center}
gdzie \texttt{-s} to~flaga po~której następuje nazwa pliku~\emph{Playbook}. Ansible, tak jak konkurencyjne rozwiązania, potrafi zarządzać oprogramowaniem i~konfiguracją (i~nie tylko) w~sposób warunkowy, dlatego w~praktyce konfiguracje są~znacznie bardziej złożone od~przykładowych.

\begin{lstlisting}[numbers=none,caption={Przykładowy plik konfiguracyjny klientów serwera Ansible (w~numenklaturze Ansible nazywany \hrefemph{http://docs.ansible.com/ansible/intro_inventory.html}{Inventory file}), zwyczajowo zapisywany w~\texttt{/etc/ansible/hosts}, definiujący adresy~IP zarządzanych klientów},label=lst:ansible-inventory-example]
[local]
127.0.0.1

[web]
192.168.22.10
192.168.22.11
\end{lstlisting}

\begin{lstlisting}[numbers=none,language=,caption={Przykładowa konfiguracja klientów serwera Ansible, w~nomenklaturze Ansible nazywana \emph{Playbook}},label=lst:ansible-playbook-example]
---
- hosts: web
  vars:
   - docroot: /var/www/serversforhackers.com/public
  tasks:
   - name: Add Nginx Repository
     apt_repository: repo='ppa:nginx/stable' state=present
     register: ppastable

   - name: Install Nginx
     apt: pkg=nginx state=installed update_cache=true
     when: ppastable|success
     register: nginxinstalled
     notify:
      - Start Nginx

   - name: Create Web Root
     when: nginxinstalled|success
     file: dest={{ '{{' }} docroot {{ '}}' }} mode=775 state=directory owner=www-data group=www-data
     notify:
      - Reload Nginx

  handlers:
   - name: Start Nginx
     service: name=nginx state=started

    - name: Reload Nginx
      service: name=nginx state=reloaded
\end{lstlisting}

Ansible może zostać uruchomiony na~wielu różnych systemach~\glslink{unix-like-system}{*nixowych}, takich systemach jak~np.~\emph{Red~Hat}, \emph{Debian}, \emph{CentOS}, \emph{OS~X}, \emph{BSD}. System Windows może działać tylko w~roli klienta. Konfiguracja Ansible jest przechowywana w~plikach tekstowych~\texttt{YAML}.

Ansible został opublikowany na~licencji~\glslink{gpl}{GPL} w~wersji~3, a~jego pierwsza wersja została wydana w~2012~roku. Projekt został zaimplementowany w~języku Python przez \href{http://michaeldehaan.net/}{\mbox{Michaela} \mbox{Dehaana}}~\cite{ansible-github}.

%---------------------------------------

\section{Salt}
\label{sec:salt}

Salt, nazywany też \emph{SaltStack}, to~otwartoźdłowe oprogramowanie napisane w~Pythonie przez \href{https://www.linkedin.com/in/thhatch/}{Thomasa Hatcha} i~opublikowane na~licencji \glslink{apache2.0-license}{Apache~2.0}. Funkcjonalność Salt jest podobna do~dotychczas opisanych rozwiązań problemu synchronizacji oprogramowania. Pierwsza wersja Salt powstała w~2011~roku, a~więc jest to~najmłodsze rozwiązanie z~dotychczas przedstawionych~\cite{saltstack}.

Salt pracuje w~modelu serwer--agent --- agenci są~nazywani \emph{Salt~Minions}, a~serwer \emph{Salt~Master}. Komunikacja między serwerem i~agentami odbywa się~asynchronicznie, zgodnie ze~wzorcem \hrefemph{https://en.wikipedia.org/wiki/Publish\%E2\%80\%93subscribe\_pattern}{publish/subscribe}, co~implementują wykorzystane biblioteki \hreftt{http://zeromq.org/}{ZeroMQ} oraz~\hreftt{http://www.tornadoweb.org/}{Tornado}. Podczas projektowania Salt położono duży nacisk na~modularność implementowaną jako \href{https://docs.python.org/3.7/tutorial/modules.html}{Pythonowe moduły}\footnote{W~nomenklaturze Salta moduł Pythonowy rozbudowujący funkcjonalność to~\emph{plug-in} (a~nie~\emph{module}).} tak, aby dodawanie obsługi nowych zasobów było możliwie łatwe. Salt, podobnie jak Puppet, przechowuje konfigurację w~plikach~\texttt{YAML}, \texttt{JSON}, \texttt{plaintext}, a~do zapewnienia bezpieczeństwa komunikacji używa szyfru blokowego~\gls{aes} w~ramach protokołu~\glslink{ssl/tls}{TLS}. Wspierane systemy operacyjne to~m.in. \emph{\glslink{gnulinux}{Linux}}, \emph{Windows}, \emph{MacOS}, \emph{FreeBSD}, \emph{Solaris} i~\emph{AIX}.

Przykład~\ref{lst:salt-topfile-example} przedstawia plik konfiguracyjny \hrefemph{https://docs.saltstack.com/en/getstarted/fundamentals/top.html\#introducing-the-top-file}{Top file}, znajdujący się zwyczajowo w~pliku \path{/srv/salt/top.sls}. Plik ten~definuje stan różnych agentów --- w~przedstawionym przykładzie~\ref{lst:salt-topfile-example} są~3~rodzajów agentów zdefiniowanych przez wyrażenia regularne dopasowywane do~nazwy agenta:\mynobreakpar
\begin{enumerate}
	\item grupa wszystkich agentów --- wyrażenie regularne~\texttt{'*'} pasuje do~każdej nazwy agenta,
	\item grupa agentów, których nazwa pasuje do~wyrażenia regularnego~\texttt{'*web*'},
	\item grupa agentów, których nazwa pasuje do~wyrażenia regularnego~\texttt{'*db*'}.
\end{enumerate}
Aby~zastosować zmiany opisane w~pliku konfiguracyjnym~\path{top.sls} wystarczy wydać komendę na~komputerze odgrywającym rolę~\emph{Salt Mastera}:
\begin{center}
	\texttt{salt '*' state.apply}
\end{center}

\begin{lstlisting}[numbers=none,language=,caption={Plik konfiguracyjny \texttt{top.sls} w~formacie \texttt{YAML} definujący konfigurację dla~3~rodzajów agentów},label=lst:salt-topfile-example]
base:
  '*':
    - vim
    - scripts
    - users
  '*web*':
    - apache
    - python
    - django
  '*db*':
    - mysql
\end{lstlisting}
Nazwy znajdujące się w~pliku konfiguracyjnym pod~wyrażeniami regularnymi --- np.~w~przykładzie~\ref{lst:salt-topfile-example}: \texttt{vim}, \texttt{scripts} i~\texttt{users} pod~wyrażeniem regularnym \texttt{'*'} --- to~nazwy stanów opisanych innymi plikami konfiguracyjnymi nazywanymi plikami stanu~(\emph{State Files}). Przykład~\ref{lst:salt-statefile} przedstawia przykładowy plik stanu \path{nettools.sls} (niewystępujący w~przykładowym pliku~\path{top.sls} w~przykładzie~\ref{lst:salt-topfile-example}). Plik ten~wymusza: instalację pakietów \texttt{rsync}, \texttt{lftp} i~\texttt{curl} oraz~obecność użytkownika \texttt{fred} z~przypisanym shellem \path{/bin/zsh}.

\begin{lstlisting}[numbers=none,language=,caption={Plik stanu \texttt{nettools.sls} definujący 3~pakiety, które agent ma~zainstalować oraz~użytkownika \texttt{fred}, który musi być w~systemie i~mieć przypisany shell~\texttt{/bin/zsh}},label=lst:salt-statefile]
install_network_packages:
  pkg.installed:
    - pkgs:
      - rsync
      - lftp
      - curl
  user.present:
    - name: fred
    - shell: /bin/zsh
\end{lstlisting}

Plik stanu można zastosować bezpośrednio na~wybrany rodzaj agentów przez komendę (a~niekoniecznie przez plik konfiguracyjny~\emph{Top file} agregujący pliki stanu). Np.~komenda:
\begin{center}
\texttt{salt 'minion[0-9]' state.apply nettools}
\end{center}
zastosuje plik stanu \path{nettools.sls} dla~agentów o~nazwach od~\texttt{minion0} do~\texttt{minion9}, a~komenda:
\begin{center}
\texttt{salt -C 'G@os:Ubuntu and minion* or S@192.168.50.*' nettools}
\end{center}
zastosuje plik stanu \path{nettools.sls} dla~agentów pracujących pod~kontrolą systemu operacyjnego \texttt{Ubuntu}, których nazwa pasuje do~wyrażenia regularnego \texttt{minion*} lub~których adres~IP pasuje do~wyrażenia regularnego~\texttt{192.168.50.*}.

Ciekawym trybem pracy Salt jest tryb \emph{Agentless}, który polega na~tym, że~agenci nie muszą mieć zainstalowanego klienckiego oprogramowania~Salt. Do~działania, na maszynach klienckich, wystarczy zainstalowany Python i~SSH. Serwer Salt loguje się~do agentów przez~SSH i~rozpakowuje lekką wersję klienta Salt w~katalogu tymczasowym, który w~zależności od~konfiguracji, po~dokonaniu zmian zleconych przez \emph{Salt Mastera}, jest kasowany z~dysku agenta lub~nie.

%---------------------------------------

\section{Inne rozwiązania}

Poza przedstawionymi czterema, \href{http://www.infoworld.com/article/2609482/data-center/data-center-review-puppet-vs-chef-vs-ansible-vs-salt.html}{prawdopodobnie najpopularniejszymi} rozwiązaniami, istnieją również inne:\mynobreakpar
\begin{itemize}
	\item \hrefemph{https://en.wikipedia.org/wiki/Otter_(software)}{Otter}\footnote{\emph{Otter} autorstwa firmy \emph{Inedo} nie~należy mylić \href{https://en.wikipedia.org/wiki/Prover9\#Predecessor}{aplikacją do~automatycznego dowodzenia twierdzeń} i~z~\href{https://pl.wikipedia.org/wiki/Otter\_Browser}{przeglądarką} o~tych samych nazwach.} --- komercyjne oprogramowanie do~automatyzacji głównie systemu Windows, sprzedawane przez firmę \emph{Inedo}~\cite{otter}. Konfiguracja dla systemu Windows odbywa się~przez graficzny interfejs przeglądarki internetowej, a~dla systemów \glslink{unix-like-system}{*nixowych} przez~SSH. Otter jest zintegrowany z~\hrefemph{https://en.wikipedia.org/wiki/PowerShell}{Windows PowerShell}.
	\item\label{itm:cfengine} \hrefemph{https://en.wikipedia.org/wiki/CFEngine}{CFEngine} (skrót od~ang.~\emph{The~\textbf{C}on\textbf{f}iguration \textbf{E}ngine}) --- otwartoźródłowy~(opublikowany na~licencji~\glslink{gpl}{GPL}) system zarządzania konfiguracją autorstwa \href{https://en.wikipedia.org/wiki/Mark_Burgess_(computer_scientist)}{prof.~Marka Burgessa} z~Uniwersystetu w~Oslo~\cite{cfengine}. Projekt jest najstarszy z~zestawienia --- narodził się bowiem w~1993~roku w~Departamencie Fizyki Teoretycznej, gdzie pracował autor projektu. W~roku~2009 została ogłoszona komercyjna wersja projektu. CFEngine działał pierwotnie tylko na~systemach~\glslink{unix-like-system}{*nixowych}, ale~obecnie wspiera również system Windows. CFEngine wyróżnia się na~tle konkurencji tym, że~został napisany w~języku~C. Rozpoznawalnym użytkownikiem CFEngine jest \hrefemph{https://www.linkedin.com/feed/}{LinkedIn} --- międzynarodowy serwis społecznościowy, specjalizujący się w~kontaktach zawodowo--biznesowych (kupiony w~2016~roku przez \emph{Microsoft})~\cite{cfengine-linkedin}.
	\item\label{itm:bcfg2} \hrefemph{https://en.wikipedia.org/wiki/Bcfg2}{Bcfg2} --- projekt napisany w~Pythonie, zapoczątkowany przez \hrefemph{https://en.wikipedia.org/wiki/Argonne_National_Laboratory}{Argonne National Laboratory}. Na~tle konkurencyjnych rozwiązań wyróżnia się rozbudowaną funkcjonalnością raportowania statystyk przez klientów. Działa na \emph{AIX}, \emph{FreeBSD}, \emph{OpenBSD}, \emph{Mac OS X}, \emph{OpenSolaris}, \emph{Solaris} i~wielu dystrybucjach \gls{gnulinux}: \emph{Alpine Linux}, \emph{ArchLinux}, \emph{Blag}, \emph{CentOS}, \emph{Debian}, \emph{Fedora}, \emph{Gentoo}, \emph{gNewSense}, \emph{Mandriva}, \emph{openSUSE}, \emph{Red~Hat/RHEL}, \emph{SuSE/SLES}, \emph{Trisquel} i~\emph{Ubuntu}~\cite{bcfg2}.
\end{itemize}
W~pracy nie scharakteryzowano wszystkich istniejących rozwiązań do~zarządzania konfiguracją systemów operacyjnych~\cite{wiki:scm-comparison}. Nazwy innych otwartoźródłowych rozwiązań to~m.in.:~\hrefemph{https://en.wikipedia.org/wiki/Capistrano_(software)}{Capistrano}, \hrefemph{https://en.wikipedia.org/wiki/Cdist}{cdist}, \hrefemph{https://en.wikipedia.org/wiki/ISconf}{ISconf}, \hrefemph{https://en.wikipedia.org/wiki/LCFG}{LCFG}, \hrefemph{https://en.wikipedia.org/wiki/Juju_(software)}{Juju}, \hrefemph{https://en.wikipedia.org/wiki/OCS_Inventory}{OCS~Inventory}, \hrefemph{https://en.wikipedia.org/wiki/OpenLMI}{OpenLMI}, \hrefemph{https://en.wikipedia.org/wiki/Opsi}{Opsi}, \hrefemph{https://en.wikipedia.org/wiki/PIKT}{PIKT}, \hrefemph{https://en.wikipedia.org/wiki/Quattor}{Quattor}, \hrefemph{https://en.wikipedia.org/wiki/Radmind}{Radmind}, \hrefemph{https://en.wikipedia.org/wiki/Rex_(software)}{Rex}, \hrefemph{https://en.wikipedia.org/wiki/Rudder_(software)}{Rudder}, \hrefemph{https://en.wikipedia.org/wiki/SmartFrog}{SmartFrog}, \hrefemph{https://en.wikipedia.org/wiki/Spacewalk_(software)}{Spacewalk}, \hrefemph{https://en.wikipedia.org/wiki/Software_Testing_Automation_Framework}{STAF}, \hrefemph{https://en.wikipedia.org/wiki/Synctool}{Synctool}. Nie wszystkie z~nich mają tak rozbudowaną funkcjonalność jak rozwiązania opisane w~tym rozdziale --- np.~\emph{Radmind} zarządza tylko systemem plików, \emph{STAF} służy do~konfiguracji środowisk testowych, \emph{ISconf} nie ma wyróżnionego serwera, a~\emph{Rudder} bazuje na~\emph{CFEngine} i~systemie kontroli wersji~\hrefemph{https://en.wikipedia.org/wiki/Git}{git}. Pomimo długiej listy istniejących rozwiązań, zdaje się, że~żadne z~nich nie zdominowało rynku (tak jak np.~zrobił to~\emph{git} w~\href{https://en.wikipedia.org/wiki/Version_control}{systemach kontroli wersji}~\cite{vcs-market-share}).

Duża część przedstawionych rozwiązań, szczególnie tych najpopularniejszych, ma~za sobą co~najmniej kilka lat rozwoju i~duże zespoły programistów pracujących nad~ulepszaniem kodu źródłowego projektu. Przykładowo do~rozwoju projektu \emph{\hyperref[sec:ansible]{Ansible}}, \emph{\hyperref[sec:salt]{Salt}}, \emph{\hyperref[sec:chef]{Chef}}, \emph{\hyperref[sec:puppet]{Puppet}}, \emph{\hyperref[itm:cfengine]{CFEngine}} i~\emph{\hyperref[itm:bcfg2]{Bcfg2}} przyczyniło się odpowiednio co~najmniej: 2589, 1754, 505, 440, 82 i~55~osób dodając w~sumie odpowiednio: 29304, 79307, 18696, 24262, 13775 i~8525\hrefemph{https://en.wikipedia.org/wiki/Commit\_(version\_control)}{commitów}\footnote{Na~podstawie statystyk z~dnia 11~marca~2017r. udostępnionych na stronach repozytoriów projektów udostępnianych przez \hreftt{https://github.com/}{github.com}}. Dzięki temu zaangażowaniu rozwiązania te~są~w~stanie zarządzać niemal każdym aspektem konfiguracji systemu operacyjnego i~jego oprogramowania. Jest to~możliwe również dzięki modułowości oprogramowania i~licencji \glslink{copyleft}{copyleft}, na~warunkach których zostały w~znacznej większości udostępnione. Z~racji na~specyfikę pracy magisterskiej, projektowany protokół nie jest tak wszechstronny jak największe z~przedstawionych rozwiązań, mimo, że~podczas projektowania protokołu starano się~stworzyć możliwie wiele ułatwień dla~jego łatwej, modułowej rozbudowy. Niniejsza praca implementuje wyłącznie zarządzanie pakietami oprogramowania i~ich konfiguracją --- w~szczególności zaimplementowane rozwiązanie nie ma~wbudowanego mechanizmu do~zapewnienia, że~dany \gls{demon} jest uruchomiony.
\end{document}
