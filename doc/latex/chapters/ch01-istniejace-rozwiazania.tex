\documentclass[thesis]{subfiles}

\begin{document}

%------------------------------------------------------------------------------

\chapter{Istniejące rozwiązania}
\label{ch:istniejace-rozwiazania}

W~niniejszym rozdziale przedstawiono przegląd czterech, prawdopodobnie jednych z~najpopularniejszych w~czasie pisania niniejszej pracy, rozwiązań dla~problemu dystrybuowania oprogramowania w~sieci~\cite{leading-scms}.

Opisane w~tym rozdziale aplikacje, poza możliwością synchronizacji zainstalowanego oprogramowania i~konfiguracji, pozwalają również na~inne manipulacje systemem operacyjnym, np.~zapewnienie istnienia wybranego użytkownika w~systemie, zapewnienie działania zadanego \glslink{daemon}{daemona} czy~konfigurację interfejsów sieciowych. Takie oprogramowanie jest często nazywane w~skrócie~\hrefemph{https://en.wikipedia.org/wiki/Software_configuration_management}{Software Configuration Management~(SCM)} implementującym ideę \hrefemph{https://en.wikipedia.org/wiki/Infrastructure_as_Code}{Infrastructure as~Code~(IaC)}, która polega na~traktowaniu infrastruktury komputerowej jak kodu, który może być zarządzany i~przetwarzany przez programy takie jak \href{https://en.wikipedia.org/wiki/Version_control}{systemy kontroli wersji}, \href{https://en.wikipedia.org/wiki/Test_automation}{automatyczne testy}, \href{https://en.wikipedia.org/wiki/Comparison_of_continuous_integration_software}{systemy ciągłej integracji}~itp.~\cite{puppet-iac}.

%------------------------------------------------------------------------------

\section{Puppet}
\label{sec:puppet}

Jednym z~najpopularniejszych w~czasie pisania tej~pracy rozwiązań problemu dystrybuowania oprogramowania jest projekt Puppet, który jest dedykowany nie tylko dla systemów~\glslink{unix-like-system}{*niksowych}, ale~również dla~systemów Windows i~\href{https://en.wikipedia.org/wiki/MacOS}{Mac~OS}~\cite{puppet,puppet-github}.

Puppet został napisany w~języku programowania \href{https://en.wikipedia.org/wiki/Ruby_(programming_language)}{Ruby}, a~jego rozwój jest wspierany i~wykorzystywany przez wiele czołowych firm i~organizacji w~branży~IT, takich jak: \emph{\google{}}, \emph{\nasa{}}, \emph{\intel{}}, \hrefemph{https://en.wikipedia.org/wiki/Verizon_Communications}{Verizon}, \hrefemph{https://en.wikipedia.org/wiki/Sony}{Sony}, \hrefemph{https://en.wikipedia.org/wiki/The_Walt_Disney_Company}{Disney}, \emph{\twitter{}}, \emph{\uber{}}, \hrefemph{https://en.wikipedia.org/wiki/Getty_Images}{gettyimages}, \emph{\cern{}}, \emph{\stanford{}}, \emph{\wikipedia{}}, \emph{\paypal{}}, \emph{\dell{}} i~wiele innych\footnote{Oficjalna strona internetowa Puppet \href{https://puppet.com/company/leadership/luke-kanies}{podaje}, że~Puppet jest używany przez ponad 30~tys. firm.}~\cite{puppet,puppet-google,puppet-cern,puppet-chef-disney}. Pierwsza wersja Puppet została opublikowana w~2005~roku przez \href{https://puppet.com/company/leadership/luke-kanies}{Luke'a Kaniesa} na~licencji~\glslink{gpl}{GPL}. Od~wersji 2.0~Puppet jest licencjonowany na~warunkach licencji~\glslink{apache2.0-license}{Apache~2.0}. Istnieje również komercyjna wersja projektu, znana pod~nazwą \emph{Puppet Enterprise}.

Konfiguracja Puppet polega na~napisaniu reguł tekstowych, w~języku niezależnym od~systemu operacyjnego (\hrefemph{https://en.wikipedia.org/wiki/Domain-specific_language}{Domain Specific Language}), przechowywanych zwyczajowo w~plikach z~rozszerzeniem~\texttt{.pp}, zwanych \emph{manifestami}. Reguły są~zapisane w~postaci deklaratywnej, a~nie imperatywnej, tzn.~opisują oczekiwany stan systemu, a~nie sposób przeprowadzenia zmian w~systemie. Struktura manifestu jest w~postaci tablicy asocjacyjnej (struktura danych \hreftt{https://docs.ruby-lang.org/en/trunk/Hash.html}{Hash}) z~języka programowania Ruby. Przykładowe manifesty przedstawiono na~listingach \ref{lst:puppet-openssh-example}, \ref{lst:puppet-motd-example} i~\ref{lst:puppet-httpd-example}~\cite{puppet-examples}. Poprawność składni w~manifeście \path{example.pp} można zweryfikować poleceniem:\mynobreakpar
\begin{center}
	\texttt{puppet parser validate example.pp}
\end{center}

Aby~wprowadzić zmiany opisane manifestem \texttt{example.pp}, wystarczy uruchomić polecenie:\mynobreakpar
\begin{center}
	\texttt{puppet apply example.pp}
\end{center}

Przed dokonaniem zmian w~systemie pomocna może być flaga \texttt{-{}-noop} (od~\hrefemph{https://en.wikipedia.org/wiki/NOP}{no operation}), która uruchomia tryb \emph{dry run}, tzn.~tryb w~którym nie są dokonywane żadne zmiany w~systemie, a~na standardowym wyjściu są drukowane zmiany jakie by~zaszły, gdyby nie użyć tej flagi.

\begin{minipage}{\linewidth} % żeby listing nie był podzielony na 2 stronach
\begin{lstlisting}[language=,caption={Manifest Puppet gwarantujący, że~pakiet \texttt{openssh-client}, dostarczający klienta \ssh{}, jest zainstalowany},label=lst:puppet-openssh-example]
package { 'openssh-client':
  ensure => present,
}
\end{lstlisting}
\end{minipage}

\begin{lstlisting}[language=,caption={Manifest Puppet gwarantujący istnienie pliku \hreftt{https://en.wikipedia.org/wiki/Motd_(Unix)}{/etc/motd} z~komunikatem \texttt{Hello!}, który wyświetla się~użytkownikom systemu po~zalogowaniu},label=lst:puppet-motd-example]
file { 'motd':
  path => '/etc/motd',
  content => 'Hello!',
}
\end{lstlisting}

\begin{lstlisting}[language=,caption={Manifest Puppet gwarantujący, że~\gls{daemon} \hreftt{https://httpd.apache.org/}{httpd} jest włączony i~działa},label=lst:puppet-httpd-example]
service { 'httpd':
  ensure => running,
  enable => true,
}
\end{lstlisting}

W~nomenklaturze Puppeta istnieją słowa kluczowe, które odpowiadają abstrakcyjnym typom danych, reprezentującym klientów i~ich oprogramowanie. Najważniejsze z~nich to:\mynobreakpar
\begin{itemize}
\item \texttt{class} --- Nazwany blok kodu Puppet przechowywany w~\hyperlink{itm:puppetmodule}{module}. Służy do~konfiguracji dużej części funkcjonalności aplikacji. Konfiguracja \hyperlink{itm:puppetnode}{węzła} pozwala zadeklarować parametryzowane użycie wielu różnych klas. Deklaracja klasy może być co~najwyżej jedna.
\item \hypertarget{itm:puppetmodule}{\texttt{module}} --- Zbiór klas konfigurujący całą aplikację. Społeczność Puppet dostarcza na~stronie internetowej \hreftt{https://forge.puppet.com/}{forge.puppet.com} wielu modułów do~różnego rodzaju oprogramowania, w~tym np.~do~aplikacji serwerowych i~aplikacji użytkowych. Przykładowe moduły obsługują m.in.:~serwer stron internetowych \hrefemph{https://forge.puppet.com/puppetlabs/apache}{Apache}, serwer~\href{https://en.wikipedia.org/wiki/Domain_Name_System}{DNS} \emph{\href{https://forge.puppet.com/ajjahn/dns}{Bind9}}, serwer~\href{https://forge.puppet.com/theforeman/dhcp}{DHCP}, narzędzie blokujące~IP z~nietypowym ruchem sieciowym \hrefemph{https://forge.puppet.com/netmanagers/fail2ban}{fail2ban}, \hrefemph{https://forge.puppet.com/example42/iptables}{iptables}, komunikatory \href{https://forge.puppet.com/jamtur01/xmpp}{XMPP/Jabber}, przeglądarki \hrefemph{https://forge.puppet.com/jamesnetherton/google_chrome}{Chrome}, \hrefemph{https://forge.puppet.com/h4x/firefox}{Firefox}, klienty poczty \hrefemph{https://forge.puppet.com/hetzner/roundcube}{Roundcube}, \hrefemph{https://forge.puppet.com/jgoettsch/thunderbird}{Thunderbird}, i~tysiące innych. Najpopularniejsze moduły są~weryfikowane przez programistów Puppet i~otrzymują status \emph{Puppet Supported} lub~\emph{Puppet Approved}, przez co~mogą być postrzegane jako zaufane.
\item \hypertarget{itm:puppetnode}{\texttt{node}} --- Węzeł. Reprezentacja jednego lub~wielu klientów.
\item Wbudowane typy zasobów, takie jak: \texttt{cron}, \texttt{exec}, \texttt{file}, \texttt{group}, \texttt{host}, \texttt{maillist}, \texttt{mount}, \texttt{package}, \texttt{router}, \texttt{service}, \texttt{ssh\_authorized\_key}, \texttt{user}, \texttt{vlan}, \texttt{zone}, \texttt{zone\_pool} i~wiele innych. Listę tą można rozszerzać o~własne typy danych np.~przez załadowanie dodatkowych modułów~\cite{puppet-resources-types}.
\end{itemize}
W~praktyce czasami pożądane jest automatyczne odpytywanie serwera przez klienta. Klient Puppeta domyślnie odpytuje serwer o~zmiany oprogramowania co~30~minut. Konfiguracja serwera odpowiadająca za~zdefiniowanie klas oprogramowania dla~poszczególnych klientów jest przechowywana w~głównym manifeście, zwyczajowo nazywanym \href{https://docs.puppet.com/puppet/latest/dirs_manifest.html#directories:-the-main-manifest(s)}{\path{site.pp}}.

\urldef\etchosts\path{%SystemRoot%\system32\drivers\etc\hosts}

W~przykładach~\ref{lst:puppet-openssh-example}, \ref{lst:puppet-motd-example} i~\ref{lst:puppet-httpd-example} zostały użyte trzy różne zasoby, odpowiednio --- pakiet oprogramowania~(\texttt{package}), plik~(\texttt{file}) oraz~serwis~(\texttt{service}). Puppet udostępnia również inne rodzaje zasobów takie jak: użytkownik~(\texttt{user}), grupa~(\texttt{group}), zdarzenie cykliczne~(\texttt{cron}), wykonanie polecenia~(\texttt{exec}), wpis w~pliku \path{/etc/hosts}\footnote{Lub~odpowiedniku pliku \path{/etc/hosts} w~systemach nie \glslink{unix-like-system}{*nixowych}, np.~\etchosts~w~systemach Windows \href{https://en.wikipedia.org/wiki/Hosts_(file)\#Location_in_the_file_system}{od}~wersji \href{https://en.wikipedia.org/wiki/Windows_NT}{Windows~NT} do~(aktualnie najnowszego) \href{https://en.wikipedia.org/wiki/Windows_10}{Windows~10}.}. Pełną listę wbudowanych typów zasobów można uzyskać wywołując polecenie \texttt{puppet describe --list}. Aby~dowiedzieć się~więcej o~wybranym typie zasobu \texttt{X}, wystarczy wydać polecenie:\mynobreakpar
\begin{center}
	\texttt{puppet describe~X}
\end{center}

Puppet składa się~z~wielu narzędzi towarzyszących. Jednym z~nich jest \hreftt{https://docs.puppet.com/facter/}{facter}, który na~żądanie zbiera informacje o~systemie i~wyświetla je w~jednym z~możliwych formatów: \json{}, \hreftt{https://en.wikipedia.org/wiki/YAML}{YAML} lub~\hreftt{https://en.wikipedia.org/wiki/Plaintext}{plaintext}, który jest formatem domyślnym. Wywołanie polecenia \texttt{facter} bez dodatkowych parametrów, wyświetla wszystkie dane o~systemie jakie zebrało to~narzędzie.

Dla~nowych użytkowników Puppeta została \href{https://puppet.com/download-learning-vm}{przygotowana} przez opiekunów projektu maszyna wirtualna z~samouczkiem tak, aby użytkownik nie~był skazany na~naukę Puppeta na~własnym systemie~\cite{puppet-vm-tutorial}. W~przypadku błędnej konfiguracji Puppeta, stan maszyny wirtualnej z~samouczkiem może być~łatwo przywrócony, co~może nie~być takie proste w~przypadku nieudanych eksperymentów na~własnym systemie.

%------------------------------------------------------------------------------

\section{Chef}
\label{sec:chef}

Chef jest oprogramowaniem napisanym w~językach programowania \href{https://en.wikipedia.org/wiki/Ruby_(programming_language)}{Ruby} (tak jak Puppet) i~\href{https://en.wikipedia.org/wiki/Erlang_(programming_language)}{Erlang} --- zastosowanym tylko do~API w~części serwerowej. Projekt został zapoczątkowany przez \href{https://blog.chef.io/author/adam/}{Adama Jacoba} na~potrzeby firmy consultingowej, ale~po~zaprezentowaniu go~pracownikowi firmy Amazon --- \href{https://en.wikipedia.org/wiki/Jesse_Robbins}{Jesse Robinsowi} --- został został opublikowany na~zasadach licencji \glslink{apache2.0-license}{Apache~2.0} i~zaadaptowany do~użycia w~firmie Amazon. Pierwsza wersja Chef została opublikowana w~2009~roku.

Chef działa w~architekturze klient--serwer. Serwer może być uruchomiony na~systemach operacyjnych: \hrefemph{https://en.wikipedia.org/wiki/CentOS}{CentOS}, \hrefemph{https://en.wikipedia.org/wiki/Oracle_Linux}{Oracle Linux}, \hrefemph{https://en.wikipedia.org/wiki/Red_Hat_Enterprise_Linux}{Red Hat Enterprise Linux} i~\hrefemph{https://en.wikipedia.org/wiki/Ubuntu_(operating_system)}{Ubuntu}. Serwer można również próbować uruchomić na~systemach \hrefemph{https://en.wikipedia.org/wiki/Macintosh_operating_systems}{Mac~OS~X} i~\hrefemph{https://en.wikipedia.org/wiki/Microsoft_Windows}{Windows} --- dokumentacja Chef wyszczególnia te~systemy jako nieprzetestowane pod~kątem współpracy z~Chef~\cite{chef-supported-platforms}.

Klientami mogą być systemy działające pod~kontrolą m.in.: \hrefemph{https://en.wikipedia.org/wiki/IBM_AIX}{AIX}, \hrefemph{https://en.wikipedia.org/wiki/CentOS}{CentOS}, \hrefemph{https://en.wikipedia.org/wiki/FreeBSD}{FreeBSD}, \hrefemph{https://en.wikipedia.org/wiki/Macintosh_operating_systems}{Mac~OS~X}, \hrefemph{https://en.wikipedia.org/wiki/Oracle_Linux}{Oracle Linux}, \hrefemph{https://en.wikipedia.org/wiki/Red_Hat_Enterprise_Linux}{Red Hat Enterprise Linux}, \hrefemph{https://en.wikipedia.org/wiki/Solaris_(operating_system)}{Solaris}, \hrefemph{https://en.wikipedia.org/wiki/Ubuntu_(operating_system)}{Ubuntu}, \hrefemph{https://en.wikipedia.org/wiki/Microsoft_Windows}{Windows}, \hrefemph{https://en.wikipedia.org/wiki/NX-OS}{Cisco NX-OS} i~\hrefemph{https://en.wikipedia.org/wiki/IOS_XR}{Cisco IOS~XR}~\cite{chef-supported-platforms}. Lista wspieranych systemów operacyjnych dla~maszyn działających w~roli klienta jest dłuższa, ale~są~one określone jako \emph{Secondary Platforms} i~\emph{Other Platforms} w~przeciwieństwie do~wymienionych, które są~określane jako~\emph{Foundational Platforms}, co~sugeruje ich~gorsze wsparcie lub~brak wsparcia.

\begin{lstlisting}[language=,caption={Przepis Chef gwarantujący, że~serwer Apache zostanie zainstalowany niezależnie od~tego jak na~danej dystrybucji \gls{gnulinux} nazywa się pakiet oprogramowania go~dostarczający},label=lst:chef-apache-example]
package 'Install Apache' do
  case node[:platform]
  when 'redhat', 'centos'
    package_name 'httpd'
  when 'ubuntu', 'debian'
    package_name 'apache2'
  end
end
\end{lstlisting}

\begin{lstlisting}[language=,caption={Przepis Chef gwarantujący, że~użytkownik \texttt{xyz} istnieje w~systemie i~ma zadane ustawienia konta},label=lst:chef-user-example]
user 'xyz' do
  comment 'A random user'
  uid '1234'
  gid '1234'
  home '/home/random'
  shell '/bin/bash'
  password '$1$JJsvHslasdfjVEroftprNn4JHtDi'
end
\end{lstlisting}

\begin{lstlisting}[language=,caption={Przepis Chef gwarantujący, że~serwis \texttt{example\_service} jest uruchomiony},label=lst:chef-service-example]
service 'example_service' do
  action :start
end
\end{lstlisting}

Użytkownikami Chefa, tak jak w~przypadku Puppeta, jest wiele dużych firm i~uniwersytetów takich jak: \hrefemph{https://en.wikipedia.org/wiki/Airbnb}{Airbnb}, \hrefemph{https://en.wikipedia.org/wiki/The_Walt_Disney_Company}{Disney}, \hrefemph{https://en.wikipedia.org/wiki/Mozilla}{Mozilla}, \emph{\facebook{}}, \hrefemph{https://en.wikipedia.org/wiki/IBM}{IBM}, \hrefemph{https://en.wikipedia.org/wiki/HP_Cloud\#HP_Public_Cloud}{HP Public Cloud}, \hrefemph{https://en.wikipedia.org/wiki/Prezi}{Prezi}, \hrefemph{https://en.wikipedia.org/wiki/University_of_Minnesota}{Uniwersytet Minnesoty}~\cite{chef-customers,puppet-chef-disney}.

Odpowiednikiem plików konfiguracyjnych, które w~Puppet nazywane są~\emph{manifestami}, są~pliki nazywane w~nomenklaturze Chef \emph{przepisami}~(ang.~\emph{recipe}). Przykładowe przepisy przedstawiono w~przykładach~\ref{lst:chef-apache-example}, \ref{lst:chef-user-example} i~\ref{lst:chef-service-example}. Więcej przykładów można znaleźć w,~bogatej w~przykładowe przepisy, dokumentacji Chef~\cite{chef-examples}.

%------------------------------------------------------------------------------

\section{Ansible}
\label{sec:ansible}

Ansible\footnote{Nazwa \hrefemph{https://en.wikipedia.org/wiki/Ansible}{Ansible} pochodzi od~fikcyjnej maszyny służącej do~natychmiastowej transmisji danych znanej z~powieści \hrefemph{https://en.wikipedia.org/wiki/Rocannon\%27s_World}{Rocannon's World} (1966) autorstwa amerykańskiej pisarki \hrefemph{https://en.wikipedia.org/wiki/Ursula_K._Le_Guin}{Ursuli Kroeber Le~Guin}.} jest rozwiązaniem do~zarządzania oprogramowaniem różniącym się od~Puppet i~Chef tym, że~do~konfiguracji klientów \glslink{unix-like-system}{*nixowych} używa~\ssh{}, a~do~klientów Windows \hrefemph{http://superuser.com/questions/184926/winrm-what-it-is-and-how-to-use-it}{WinRM} i~\hrefemph{https://en.wikipedia.org/wiki/PowerShell}{PowerShell}, dzięki czemu klienci nie~muszą uruchamiać żadnych dodatkowych procesów działających w~tle --- Ansible działa w~trybie \emph{agentless}, tzn.~klienci nie mają żadnego stale zainstalowanego dedykowanego oprogramowania do~obsługi Ansible. Komunikacja pomiędzy serwerem i~klientami odbywa się przez wymianę komunikatów \json{} po~przesłaniu przez serwer do~klienta lekkiej, tymczasowo zainstalowanej aplikacji klienckiej (\hrefemph{https://en.wikipedia.org/wiki/Software_Thin_Client}{thin client}). Autorzy projektu Ansible podkreślają na~swojej stronie internetowej, że~w~przeciwieństwie do~konkurencji, Ansible nie jest skomplikowany, przez co~jego szybkie opanowanie jest łatwe~\cite{ansible}.

Ansible został opublikowany na~licencji~\glslink{gpl}{GPL} w~wersji~3, a~jego pierwsza wersja została wydana w~2012~roku. Projekt został zaimplementowany w~języku \python{} przez \href{http://michaeldehaan.net/}{\mbox{Michaela} \mbox{Dehaana}}, a~obecnie należy do~firmy \href{https://en.wikipedia.org/wiki/Red_Hat}{Red~Hat}~\cite{ansible-github}.


\begin{lstlisting}[language=,caption={Przykładowy plik konfiguracyjny klientów serwera Ansible \protect\path{/etc/ansible/hosts} (w~nomenklaturze Ansible nazywany \hrefemph{http://docs.ansible.com/ansible/intro_inventory.html}{Inventory file}) definiujący adresy~IP zarządzanych klientów},label=lst:ansible-inventory-example]
[local]
127.0.0.1

[web]
192.168.22.10
192.168.22.11
\end{lstlisting}

Listing~\ref{lst:ansible-inventory-example} przedstawia przykładową konfigurację serwera dotyczącą klientów zarządzanych przez serwer Ansible~\cite{ansible-example}. Po~zapisaniu takiej konfiguracji, Ansible można wykorzystać do~uruchomienia polecenia na~wybranej grupie klientów. Np.:\mynobreakpar
\begin{center}
\texttt{ansible all -s -m shell -a 'apt-get install nginx'}
\end{center}
zainstaluje serwer HTTP \hreftt{https://www.nginx.com/}{nginx} na wszystkich klientach. Flaga \texttt{-m} wybiera moduł (w~tym wypadku moduł \texttt{shell}), \texttt{-s} zapewnia, że~polecenie będzie uruchomione z~użyciem \hreftt{https://en.wikipedia.org/wiki/Sudo}{sudo}, a~\texttt{-a} pozwala na~przekazanie parametru do~użytego modułu. Taka forma użycia Ansible jest najprostsza i~nie pozwala w~pełni wykorzystać możliwości Ansible. Trochę lepszym, bo~deklaratywnym sposobem, wykorzystującym moduł~\texttt{apt} jest wywołanie:\mynobreakpar
\begin{center}
\texttt{ansible all -s -m apt -a 'pkg=nginx state=installed update\_cache=true'}
\end{center}
które zwraca wynik na~standardowym wyjściu w~postaci~\json{}:\mynobreakpar
\begin{lstlisting}[language=,frame=none,numbers=none]
127.0.0.1 | success >> {
    "changed": false
}
\end{lstlisting}

Powyższe sposoby uruchamiania Ansible są wykorzystaniem Ansible~\emph{ad-hoc}. Możliwości Ansible w~pełni ujawniają się, gdy~wykorzystamy \hrefemph{http://docs.ansible.com/playbooks_intro.html}{playbook}, czyli odpowiednik manifestu Puppeta i~przepisu Chefa. 

\begin{lstlisting}[language=,caption={Przykładowa konfiguracja klientów serwera Ansible, w~nomenklaturze Ansible nazywana \emph{playbook}},label=lst:ansible-playbook-example]
---
- hosts: web
  vars:
   - docroot: /var/www/serversforhackers.com/public
  tasks:
   - name: Add Nginx Repository
     apt_repository: repo='ppa:nginx/stable' state=present
     register: ppastable

   - name: Install Nginx
     apt: pkg=nginx state=installed update_cache=true
     when: ppastable|success
     register: nginxinstalled
     notify:
      - Start Nginx

   - name: Create Web Root
     when: nginxinstalled|success
     file: dest={{ '{{' }} docroot {{ '}}' }} mode=775 state=directory owner=www-data group=www-data
     notify:
      - Reload Nginx

  handlers:
   - name: Start Nginx
     service: name=nginx state=started

    - name: Reload Nginx
      service: name=nginx state=reloaded
\end{lstlisting}

Przykładowy \emph{playbook} z~listingu~\ref{lst:ansible-playbook-example} przedstawia sposób zainstalowania na~grupie komputerów o~nazwie \texttt{web}~(por. listing~\ref{lst:ansible-inventory-example}) serwera \texttt{nginx}, stworzenia pliku serwowanego przez serwer, a~następnie uruchomienia \glslink{daemon}{daemona} serwera. Zmiany opisane przez \emph{playbook} można dokonać za~pomocą polecenia:\mynobreakpar
\begin{center}
\texttt{ansible-playbook -s nginx.yml}
\end{center}
gdzie \texttt{-s} to~flaga po~której następuje ścieżka do~pliku~\emph{playbook}. Ansible, tak jak konkurencyjne rozwiązania, potrafi zarządzać oprogramowaniem i~konfiguracją w~sposób warunkowy, dlatego w~praktyce użyteczne konfiguracje są~znacznie bardziej złożone od~przykładowych.

Ansible może zostać uruchomiony na~wielu różnych systemach~\glslink{unix-like-system}{*nixowych}, takich systemach jak~np.~\hrefemph{https://en.wikipedia.org/wiki/Red_Hat}{Red~Hat}, \emph{\debian{}}, \hrefemph{https://en.wikipedia.org/wiki/CentOS}{CentOS}, \hrefemph{https://en.wikipedia.org/wiki/MacOS}{Mac~OS~X}, \hrefemph{https://en.wikipedia.org/wiki/Berkeley_Software_Distribution}{BSD}. System Windows może działać tylko w~roli klienta. Konfiguracja Ansible jest przechowywana w~plikach tekstowych~\texttt{YAML} (por.~listing~\ref{lst:ansible-playbook-example}).

Do~września~2017~roku istniał komercyjny dodatek \hrefemph{https://www.ansible.com/tower}{Ansible Tower}, który 7~września~2017 został upubliczniony pod~nazwą~\href{https://github.com/ansible/awx}{AWX} (skrót od~\emph{AnsibleWorks}). Oferuje on~m.in.~preglądarkowy interfejs obsługi i~\href{https://en.wikipedia.org/wiki/Representational_state_transfer}{REST~API} dla~Ansible.

%------------------------------------------------------------------------------

\section{Salt}
\label{sec:salt}

Salt, nazywany też \emph{SaltStack}, to~otwartoźdłowe oprogramowanie napisane w~Pythonie przez Amerykanina --- \href{https://www.linkedin.com/in/thhatch/}{Thomasa Hatcha} --- i~opublikowane na~warunkach licencji \glslink{apache2.0-license}{Apache~2.0}. Funkcjonalność Salt jest podobna do~dotychczas opisanych rozwiązań problemu synchronizacji oprogramowania. Pierwsza wersja Salt powstała w~2011~roku, a~więc jest to~najmłodsze rozwiązanie z~dotychczas przedstawionych~\cite{saltstack}.

Salt pracuje w~modelu serwer-agent --- agenci są~nazywani \emph{Salt~Minions}, a~serwer \emph{Salt~Master}. Komunikacja między serwerem i~agentami odbywa się~asynchronicznie, zgodnie ze~wzorcem \hrefemph{https://en.wikipedia.org/wiki/Publish\%E2\%80\%93subscribe\_pattern}{publish/subscribe} implementowanym przez wykorzystane biblioteki \hreftt{http://zeromq.org/}{ZeroMQ} oraz~\hreftt{http://www.tornadoweb.org/}{Tornado}. Podczas projektowania Salt położono duży nacisk na~modularność implementowaną jako \href{https://docs.python.org/3.7/tutorial/modules.html}{Pythonowe moduły}\footnote{W~nomenklaturze Salta moduł Pythonowy rozbudowujący funkcjonalność to~\emph{plug-in} (a~nie~\emph{module}).} tak, aby~dodawanie obsługi nowych zasobów było możliwie jak~najłatwiejsze. Salt, podobnie jak Puppet, przechowuje konfigurację w~plikach~\texttt{YAML}, \json{}, \texttt{plaintext}, a~do zapewnienia bezpieczeństwa komunikacji używa szyfru blokowego~\gls{aes} w~ramach protokołu~\glslink{ssl/tls}{TLS}. Wspierane systemy operacyjne to~m.in. \emph{\glslink{gnulinux}{Linux}}, \hrefemph{https://en.wikipedia.org/wiki/Microsoft_Windows}{Windows}, \hrefemph{https://en.wikipedia.org/wiki/Macintosh_operating_systems}{Mac~OS}, \hrefemph{https://en.wikipedia.org/wiki/FreeBSD}{FreeBSD}, \hrefemph{https://en.wikipedia.org/wiki/Solaris_(operating_system)}{Solaris} i~\hrefemph{https://en.wikipedia.org/wiki/IBM_AIX}{AIX}.

Przykład~\ref{lst:salt-topfile-example} przedstawia plik konfiguracyjny \hrefemph{https://docs.saltstack.com/en/getstarted/fundamentals/top.html\#introducing-the-top-file}{Top file}, znajdujący się zwyczajowo w~pliku \path{/srv/salt/top.sls}. Plik ten~definiuje stan różnych agentów --- w~przedstawionym przykładzie~\ref{lst:salt-topfile-example} są~3~rodzajów agentów zdefiniowanych przez wyrażenia regularne dopasowywane do~nazwy agenta:\mynobreakpar
\begin{enumerate}
	\item grupa wszystkich agentów --- wyrażenie regularne~\texttt{'*'} pasuje do~każdej nazwy agenta,
	\item grupa agentów, których nazwa pasuje do~wyrażenia regularnego~\texttt{'*web*'},
	\item grupa agentów, których nazwa pasuje do~wyrażenia regularnego~\texttt{'*db*'}.
\end{enumerate}
Aby~zastosować zmiany opisane w~pliku konfiguracyjnym~\path{top.sls} wystarczy wydać polecenie na~komputerze odgrywającym rolę~\emph{Salt Mastera}:\mynobreakpar
\begin{center}
	\texttt{salt '*' state.apply}
\end{center}

\begin{lstlisting}[language=,caption={Plik konfiguracyjny \texttt{top.sls} w~formacie \texttt{YAML} definiujący konfigurację dla~3~rodzajów agentów},label=lst:salt-topfile-example]
base:
  '*':
    - vim
    - scripts
    - users
  '*web*':
    - apache
    - python
    - django
  '*db*':
    - mysql
\end{lstlisting}
Nazwy znajdujące się w~pliku konfiguracyjnym pod~wyrażeniami regularnymi --- np.~w~przykładzie~\ref{lst:salt-topfile-example}: \texttt{vim}, \texttt{scripts} i~\texttt{users} pod~wyrażeniem regularnym \texttt{'*'} --- to~nazwy stanów opisanych innymi plikami konfiguracyjnymi nazywanymi plikami stanu~(\emph{State Files}). Przykład~\ref{lst:salt-statefile} przedstawia przykładowy plik stanu \path{nettools.sls} (niewystępujący w~przykładowym pliku~\path{top.sls} w~przykładzie~\ref{lst:salt-topfile-example}). Plik ten~wymusza: instalację pakietów \hreftt{https://wiki.archlinux.org/index.php/rsync}{rsync}, \hreftt{https://lftp.yar.ru/}{lftp} i~\hreftt{https://curl.haxx.se/}{curl} oraz~obecność użytkownika \texttt{fred} z~przypisanym \hrefemph{https://superuser.com/questions/144666/what-is-the-difference-between-shell-console-and-terminal}{shellem} \href{https://en.wikipedia.org/wiki/Z_shell}{\path{/bin/zsh}}.

\begin{lstlisting}[language=,caption={Plik stanu \texttt{nettools.sls} definiujący 3~pakiety, które agent ma~zainstalować oraz~użytkownika \texttt{fred}, który musi być w~systemie i~mieć przypisany \emph{shell}~\texttt{/bin/zsh}},label=lst:salt-statefile]
install_network_packages:
  pkg.installed:
    - pkgs:
      - rsync
      - lftp
      - curl
  user.present:
    - name: fred
    - shell: /bin/zsh
\end{lstlisting}

Plik stanu można zastosować bezpośrednio na~wybrany rodzaj agentów przez polecenie (a~niekoniecznie przez plik konfiguracyjny~\emph{Top file} agregujący pliki stanu). Np.:\mynobreakpar
\begin{center}
\texttt{salt 'minion[0-9]' state.apply nettools}
\end{center}
zastosuje plik stanu \path{nettools.sls} dla~agentów o~nazwach od~\texttt{minion0} do~\texttt{minion9}, a~polecenie:\mynobreakpar
\begin{center}
\texttt{salt -C 'G@os:Ubuntu and minion* or S@192.168.50.*' nettools}
\end{center}
zastosuje plik stanu \path{nettools.sls} dla~agentów pracujących pod~kontrolą systemu operacyjnego \href{https://en.wikipedia.org/wiki/Ubuntu_(operating_system)}{Ubuntu}, których nazwa pasuje do~wyrażenia regularnego \texttt{minion*} lub~których adres~IP pasuje do~wyrażenia regularnego~\texttt{192.168.50.*}.

Ciekawym trybem pracy Salt jest tryb \emph{agentless}, który polega na~tym, że~agenci nie muszą mieć zainstalowanego klienckiego oprogramowania~Salt --- podobnie jak w~\hyperref[sec:ansible]{Asible} omówionym w~rozdziale~\ref{sec:ansible}. Do~działania, na maszynach klienckich, wystarczy zainstalowany \python{} i~\ssh{}. Serwer Salt loguje się~do agentów przez~\ssh{} i~rozpakowuje lekką wersję klienta Salt w~katalogu tymczasowym, który w~zależności od~konfiguracji, po~dokonaniu zmian zleconych przez \emph{Salt Mastera}, jest kasowany z~dysku agenta lub~nie.

%------------------------------------------------------------------------------

\section{Inne rozwiązania}

\newcommand{\puppetlogo}{\centerheader{img/Puppet_logo}}
\newcommand{\cheflogo}{\centerheader{img/Chef_logo}}
\newcommand{\ansiblelogo}{\centerheader{img/Ansible_logo}}
\newcommand{\saltlogo}{\multicolumn{1}{c}{\includegraphics[height=\tablelogoheight]{img/SaltStack_logo}}}

\newcommand{\puppetauthor}{\href{https://puppet.com/company/leadership/luke-kanies}{Luke Kanies}}
\newcommand{\chefauthor}{\href{https://blog.chef.io/author/adam/}{Adam Jacob}}
\newcommand{\ansibleauthor}{\href{http://michaeldehaan.net/}{Michael Dehaan}}
\newcommand{\saltauthor}{\href{https://www.linkedin.com/in/thhatch/}{Thomas Hatch}}

\newcommand{\puppetref}{\hyperref[sec:puppet]{Puppet}}
\newcommand{\chefref}{\hyperref[sec:chef]{Chef}}
\newcommand{\ansibleref}{\hyperref[sec:ansible]{Ansible}}
\newcommand{\saltref}{\hyperref[sec:salt]{Salt}}

\newcommand{\rubylink}{\href{https://en.wikipedia.org/wiki/Ruby_(programming_language)}{Ruby}}
\newcommand{\erlanglink}{\href{https://en.wikipedia.org/wiki/Erlang_(programming_language)}{Erlang}}
\newcommand{\pythonlink}{\href{https://en.wikipedia.org/wiki/Python_(programming_language)}{Python}}
\newcommand{\powershelllink}{\href{https://en.wikipedia.org/wiki/PowerShell}{PowerShell}}

\newcommand{\apachegls}{\glslink{apache2.0-license}{Apache~2.0}}
\newcommand{\gplgls}{\glslink{gpl}{GPLv3}}

\newcommand{\puppetpage}{\hreftt{https://puppet.com/}{puppet.com}}
\newcommand{\chefpage}{\hreftt{https://www.chef.io/}{chef.io}}
\newcommand{\ansiblepage}{\hreftt{https://www.ansible.com/}{ansible.com}}
\newcommand{\saltpage}{\hreftt{https://saltstack.com/}{saltstack.com}}

\newcommand{\mysmallfont}{\fontsize{7.1}{\baselineskip}\selectfont}
\newcommand{\puppetgithub}{\mysmallfont\hreftt{https://github.com/puppetlabs/puppet}{github.com/puppetlabs/puppet}}
\newcommand{\chefgithub}{\mysmallfont\hreftt{https://github.com/chef/chef}{github.com/chef/chef}}
\newcommand{\ansiblegithub}{\mysmallfont\hreftt{https://github.com/ansible/ansible}{github.com/ansible/ansible}}
\newcommand{\saltgithub}{\mysmallfont\hreftt{https://github.com/saltstack/salt}{github.com/saltstack/salt}}

\newcommand{\fixedcustomercell}[1]{\parbox[l][1.1cm][c]{3.0cm}{#1}}
\newcommand{\puppetcustomers}{\fixedcustomercell{\cern{}, \google{}, \nasa{}, \intel{}, \twitter{}, \paypal{}, \wikipedia{}, \uber{}, \dell{}}}
\newcommand{\chefcustomers}{\fixedcustomercell{\facebook{}, \ibm{}, \hpcompany{}, \mozilla{}}}
\newcommand{\ansiblecustomers}{\fixedcustomercell{\apple{}, \nasa{}, \juniper{}}}
\newcommand{\saltcustomers}{\fixedcustomercell{\linkedin{}, \tdbank{}}}

\newcommand{\puppetenterprise}{\href{https://puppet.com/product}{Puppet Enterprise}}
\newcommand{\chefenterprise}{\href{https://www.chef.io/automate/}{Chef Automate}}
\newcommand{\ansibleenterprise}{\href{https://www.ansible.com/pricing}{Ansible Tower}}
\newcommand{\saltenterprise}{\href{https://saltstack.com/saltstack-enterprise/}{SaltStack Enterprise}}

\newcommand{\puppetdocs}{\hreftt{https://docs.puppet.com/}{docs.puppet.com}}
\newcommand{\chefdocs}{\hreftt{https://docs.chef.io/}{docs.chef.io}}
\newcommand{\ansibledocs}{\hreftt{http://docs.ansible.com/}{docs.ansible.com}}
\newcommand{\saltdocs}{\hreftt{https://docs.saltstack.com/}{docs.saltstack.com}}

\newcommand{\puppetcompany}{\href{https://en.wikipedia.org/wiki/Puppet_(company)}{Puppet,~Inc.}\tablefootnote{Do~kwietnia~2016 firma \href{https://puppet.com/puppet-labs-is-puppet}{nosiła} nazwę \emph{Puppet~Labs}.}}
\newcommand{\chefcompany}{\href{https://www.sec.gov/Archives/edgar/data/1545207/000154520713000002/xslFormDX01/primary_doc.xml}{Chef Software,~Inc.}\tablefootnote{Do~grudnia~2013 firma \href{https://www.chef.io/about/}{nosiła} nazwę \emph{Opscode}.}}
\newcommand{\redhatcompany}{\href{https://www.sec.gov/cgi-bin/browse-edgar?action=getcompany\&CIK=0001087423\&owner=exclude\&count=40\&hidefilings=0}{Red Hat,~Inc.}}
\newcommand{\saltcompany}{\href{https://www.sec.gov/Archives/edgar/data/1570778/000157077813000002/xslFormDX01/primary_doc.xml}{Salt Stack,~Inc.}}

\newcommand{\pricingtitle}{Cena wersji płatnej\tablefootnote{W~tabeli uwzględniono najtańsze standardowe licencje opublikowane na~stronach producentów.}}
\newcommand{\puppetpricing}{\href{https://puppet.com/product/pricing}{\$120 za~1~maszynę/rok}}
\newcommand{\chefpricing}{\href{https://www.chef.io/pricing/}{\$137 za~1~maszynę/rok}}
\newcommand{\ansiblepricing}{\href{https://www.ansible.com/pricing}{\$5,000 za~100~maszyn/rok}}
\newcommand{\saltpricing}{\href{https://saltstack.com/saltstack-enterprise/}{Nie podano}\tablefootnote{Cena zostaje podana po~kontakcie przez e-mail \hreftt{mailto:sales@saltstack.com}{sales@saltstack.com}.}}

\newcommand{\ansiblewinpartialsupport}{\href{http://docs.ansible.com/ansible/intro_installation.html\#control-machine-requirements}{częściowe}}

\newcommand{\usaorwiki}{\href{https://en.wikipedia.org/wiki/Oregon}{OR}}
\newcommand{\usawawiki}{\href{https://en.wikipedia.org/wiki/Washington_(state)}{WA}}
\newcommand{\usancwiki}{\href{https://en.wikipedia.org/wiki/North_Carolina}{NC}}
\newcommand{\usautwiki}{\href{https://en.wikipedia.org/wiki/Utah}{UT}}

\newcommand{\puppetdebrank}{\href{https://qa.debian.org/popcon.php?package=puppet}{6061}}
\newcommand{\chefdebrank}{\href{https://qa.debian.org/popcon.php?package=chef}{12675}}
\newcommand{\ansibledebrank}{\href{https://qa.debian.org/popcon.php?package=ansible}{8547}}
\newcommand{\saltdebrank}{\href{https://qa.debian.org/popcon.php?package=salt}{8796}}
\newcommand{\isconf}{\href{https://en.wikipedia.org/wiki/ISconf}{ISconf}}
\newcommand{\rudder}{\href{https://en.wikipedia.org/wiki/Rudder_(software)}{Rudder}}
\newcommand{\cfengine}{\href{https://en.wikipedia.org/wiki/CFEngine}{CFEngine}}
\newcommand{\radmind}{\href{https://en.wikipedia.org/wiki/Radmind}{Radmind}}

Poza opisanymi do~tej pory czterema rozwiązaniami istnieją również inne:\mynobreakpar
\begin{itemize}
	\item \hrefemph{https://en.wikipedia.org/wiki/Otter_(software)}{Otter}\footnote{\emph{Otter} autorstwa firmy \emph{Inedo} nie~należy mylić \href{https://en.wikipedia.org/wiki/Prover9\#Predecessor}{aplikacją do~automatycznego dowodzenia twierdzeń} i~z~\href{https://pl.wikipedia.org/wiki/Otter\_Browser}{przeglądarką} o~tych samych nazwach.} --- komercyjne oprogramowanie do~automatyzacji głównie systemu Windows, sprzedawane przez firmę \emph{Inedo}~\cite{otter}. Konfiguracja dla systemu Windows odbywa się~przez graficzny interfejs przeglądarki internetowej, a~dla systemów \glslink{unix-like-system}{*nixowych} przez~\ssh{}. Otter jest zintegrowany z~\hrefemph{https://en.wikipedia.org/wiki/PowerShell}{Windows PowerShell}.
	\item\label{itm:cfengine} \emph{\cfengine{}} (skrót od~ang.~\emph{The~\textbf{C}on\textbf{f}iguration \textbf{E}ngine}) --- otwartoźródłowy~(opublikowany na~licencji~\glslink{gpl}{GPL}) system zarządzania konfiguracją autorstwa \href{https://en.wikipedia.org/wiki/Mark_Burgess_(computer_scientist)}{prof.~Marka Burgessa} z~Uniwersytetu w~Oslo~\cite{cfengine}. Projekt jest najstarszy z~całego zestawienia --- narodził się bowiem w~1993~roku w~Departamencie Fizyki Teoretycznej, gdzie pracował autor projektu. W~roku~2009 została ogłoszona komercyjna wersja projektu. \cfengine{} działał pierwotnie tylko na~systemach~\glslink{unix-like-system}{*nixowych}, ale~obecnie wspiera również system Windows. \cfengine{} wyróżnia się na~tle konkurencji tym, że~został napisany w~języku~C, a~nie języku skryptowym lub~innym języku wyższego poziomu jak pozostałe rozwiązania. Rozpoznawalnym użytkownikiem CFEngine jest \hrefemph{https://www.linkedin.com/feed/}{LinkedIn}\footnote{LinkedIn używa lub~używał również oprogramowania \hyperref[sec:salt]{Salt}~\cite{salt-linkedin}.} --- międzynarodowy serwis społecznościowy, specjalizujący się w~kontaktach zawodowo-biznesowych kupiony w~2016~roku przez \hrefemph{https://en.wikipedia.org/wiki/Microsoft}{Microsoft}~\cite{cfengine-linkedin}. \cfengine{} jako jedyny z~zestawienia ma~podstawy teoretyczne stworzone specjalnie na~jego potrzeby (\hrefemph{https://en.wikipedia.org/wiki/Promise\_theory}{promise theory})~\cite{cfengine-whitepaper,mark-burgess-webpage}.
	\item\label{itm:bcfg2} \hrefemph{https://en.wikipedia.org/wiki/Bcfg2}{Bcfg2} --- projekt napisany w~Pythonie, zapoczątkowany przez jedną z~największych amerykańskich placówek badawczych --- \hrefemph{https://en.wikipedia.org/wiki/Argonne_National_Laboratory}{Argonne National Laboratory}\footnote{\hrefemph{https://en.wikipedia.org/wiki/Argonne_National_Laboratory}{Argonne National Laboratory} to~centrum naukowo-badawcze powstałe w~1946~roku, działające pod~opieką \href{https://en.wikipedia.org/wiki/University_of_Chicago}{Uniwersytetu w~Chicago}, powstałe w~ramach \href{https://en.wikipedia.org/wiki/Manhattan_Project}{projektu Manhattan}, którego pierwszym dyrektorem był \href{https://en.wikipedia.org/wiki/Enrico_Fermi}{Enrico Fermi} --- laureat \href{https://en.wikipedia.org/wiki/Nobel_Prize_in_Physics}{Nagrody Nobla z~fizyki} z~roku 1938 i~uczestnik \href{https://en.wikipedia.org/wiki/Manhattan_Project}{projektu Manhattan}.}. Na~tle konkurencyjnych rozwiązań wyróżnia się rozbudowaną funkcjonalnością raportowania statystyk przez klientów. Działa na \hrefemph{https://en.wikipedia.org/wiki/IBM_AIX}{AIX}, \hrefemph{https://en.wikipedia.org/wiki/FreeBSD}{FreeBSD}, \hrefemph{https://en.wikipedia.org/wiki/OpenBSD}{OpenBSD}, \hrefemph{https://en.wikipedia.org/wiki/Macintosh_operating_systems}{Mac~OS~X}, \hrefemph{https://en.wikipedia.org/wiki/OpenSolaris}{OpenSolaris}, \hrefemph{https://en.wikipedia.org/wiki/Solaris_(operating_system)}{Solaris} i~wielu dystrybucjach \gls{gnulinux}: \hrefemph{https://en.wikipedia.org/wiki/Alpine_Linux}{Alpine Linux}, \emph{\arch{}}, \emph{Blag}, \hrefemph{https://en.wikipedia.org/wiki/CentOS}{CentOS}, \emph{\debian{}}, \hrefemph{https://en.wikipedia.org/wiki/Fedora_(operating_system)}{Fedora}, \hrefemph{https://en.wikipedia.org/wiki/Gentoo_Linux}{Gentoo}, \emph{gNewSense}, \emph{Mandriva}, \emph{openSUSE}, \hrefemph{https://en.wikipedia.org/wiki/Red_Hat}{Red~Hat/RHEL}, \emph{SuSE/SLES}, \emph{Trisquel} i~\hrefemph{https://en.wikipedia.org/wiki/Ubuntu_(operating_system)}{Ubuntu}~\cite{bcfg2}.
\end{itemize}

W~pracy nie scharakteryzowano wszystkich istniejących rozwiązań do~zarządzania konfiguracją systemów operacyjnych z~racji na~ich mnogość~\cite{leading-scms}. Nazwy innych, wybranych otwartoźródłowych rozwiązań to~m.in.:~\hrefemph{https://en.wikipedia.org/wiki/Capistrano_(software)}{Capistrano}, \hrefemph{https://en.wikipedia.org/wiki/Cdist}{cdist}, \emph{\isconf{}}, \hrefemph{https://en.wikipedia.org/wiki/LCFG}{LCFG}, \hrefemph{https://en.wikipedia.org/wiki/Juju_(software)}{Juju}, \hrefemph{https://en.wikipedia.org/wiki/OCS_Inventory}{OCS~Inventory}, \hrefemph{https://en.wikipedia.org/wiki/OpenLMI}{OpenLMI}, \hrefemph{https://en.wikipedia.org/wiki/Opsi}{Opsi}, \hrefemph{https://en.wikipedia.org/wiki/PIKT}{PIKT}, \hrefemph{https://en.wikipedia.org/wiki/Quattor}{Quattor}, \emph{\radmind{}}, \hrefemph{https://en.wikipedia.org/wiki/Rex_(software)}{Rex}, \emph{\rudder{}}, \hrefemph{https://en.wikipedia.org/wiki/SmartFrog}{SmartFrog}, \hrefemph{https://en.wikipedia.org/wiki/Spacewalk_(software)}{Spacewalk}, \hrefemph{https://en.wikipedia.org/wiki/Software_Testing_Automation_Framework}{STAF}, \hrefemph{https://en.wikipedia.org/wiki/Synctool}{Synctool}, \hrefemph{https://en.wikipedia.org/wiki/Terraform_(software)}{Terraform}. Nie wszystkie z~nich mają tak rozbudowaną funkcjonalność jak rozwiązania opisane w~niniejszym rozdziale --- np.~\radmind{} zarządza tylko systemem plików, STAF służy do~konfiguracji środowisk testowych, \isconf{}\footnote{Autor \hyperref[sec:puppet]{Puppeta} opisanego w~rozdziale~\ref{sec:puppet} --- \emph{\puppetauthor} --- zanim rozpoczął pracę nad~Puppetem, pracował m.in.~nad~\isconf{} i~\cfengine{}~\cite{luke-kanies-dblp,luke-kanies-cfengine}.} nie ma wyróżnionego serwera, a~\rudder{} bazuje na~\cfengine{} i~systemie kontroli wersji~\href{https://en.wikipedia.org/wiki/Git}{git}.

Określenie \emph{Configuration Management}, na~które powołuje się niniejsza praca do~określenia rodzaju projektowanego oprogramowania, może być kojarzona również z~takimi rozwiązaniami jak~np.~\hrefemph{https://en.wikipedia.org/wiki/Vagrant_(software)}{Vagrant} i~\hrefemph{https://en.wikipedia.org/wiki/Docker_(software)}{Docker}. Rozwiązania te~zostały jednak \href{http://stackoverflow.com/questions/16647069/should-i-use-vagrant-or-docker-for-creating-an-isolated-environment}{zaprojektowane} do~zarządzania \href{http://stackoverflow.com/questions/16047306/how-is-docker-different-from-a-normal-virtual-machine}{środowiskami wirtualnymi}, a~nie bezpośrednio konfiguracją systemu, na~którym działają. Przykładowo \href{https://www.vagrantup.com/intro/index.html}{Vagrant} może wykorzystać do~działania np.~\href{https://en.wikipedia.org/wiki/VMware}{VMWare}, \href{https://en.wikipedia.org/wiki/VirtualBox}{VirtualBox}, \href{https://en.wikipedia.org/wiki/Hyper-V}{Hyper-V}, \href{https://en.wikipedia.org/wiki/Amazon_Web_Services}{AWS} (\hrefemph{https://en.wikipedia.org/wiki/Amazon_Web_Services}{Amazon Web Services}), a~\href{https://www.docker.com/what-docker}{Docker} \href{https://en.wikipedia.org/wiki/Linux_containers}{kontenery Linux}. Co~ciekawe, zarówno \href{https://www.vagrantup.com/docs/provisioning/puppet_apply.html}{Vagrant} jak~i~\href{https://puppet.com/presentations/using-docker-puppet-james-turnbull-kickstarter}{Docker} można łatwo zintegrować z~\hyperref[sec:puppet]{Puppet}.

%------------------------------------------------------------------------------

\section{Podsumowanie}

W~rozdziałach~\ref{sec:puppet}, \ref{sec:chef}, \ref{sec:ansible} i~\ref{sec:salt} zostały opisane cztery, \href{http://www.infoworld.com/article/2609482/data-center/data-center-review-puppet-vs-chef-vs-ansible-vs-salt.html}{prawdopodobnie} najpopularniejsze istniejące rozwiązania dystrybuowania oprogramowania~\cite{leading-scms}. Z~porównania \href{https://www.openhub.net/p/_compare?project_0=Puppet&project_2=salt&project_1=Ansible}{statystyk} użycia tych programów, prowadzonych przez \hreftt{https://www.openhub.net/}{openhub.net} oraz~przez projekt \hrefemph{https://en.wikipedia.org/wiki/Debian}{Debian Popularity Contest} (\hreftt{http://popcon.debian.org/}{popcon.debian.org}), wynika jednoznacznie, że~\href{https://qa.debian.org/popcon.php?package=puppet}{najpopularniejszym} rozwiązaniem z~przedstawionych --- przynajmniej wśród użytkowników Debiana --- jest \href{https://qa.debian.org/popcon.php?package=puppet}{Puppet}, a~najmniej popularnym \href{https://qa.debian.org/popcon.php?package=chef}{Chef}. Według~\hreftt{https://www.openhub.net/}{openhub.net} drugie miejsce pod~względem popularności zajmuje \href{https://qa.debian.org/popcon.php?package=salt}{Salt}, a~trzecie \href{https://qa.debian.org/popcon.php?package=ansible}{Ansible}, a~według statystyk \emph{Debian Popularity Contest} --- odwrotnie. To,~że~obie te~statystyki wskazują Puppet jako najpopularniejsze rozwiązanie, nie znaczy, że~jego konkurencja została daleko w~tyle --- przeciwnie --- wg~\emph{Debian Popularity Contest} linia trendu liczby pobrań Puppeta maleje od~początku 2017~roku, a~Ansible i~Salta stale rośnie od~początku zaistnienia w~repozytorium Debiana\footnote{Analiza trendu w~przedziale od~początku istnienia analizowanych rozwiązań w~repozytorium Debiana (każde z~nich zadebiutowało przed rokiem 2013) do~czasu, w~którym pisana jest niniejsza praca.}. Należy mieć świadomość, że~podane statystyki mogą okazać się niewystarczająco reprezentatywne, aby~uogólniać wnioski dotyczące popularności przedstawionych rozwiązań na~cały sektor~IT. Z~drugiej jednak strony \debian{} jest dystrybucją prowadzącą \href{https://www.debian.org/doc/manuals/debian-faq/ch-ftparchives#s-frozen}{politykę} wersjonowania pakietów sprzyjającą stabilności, przez co~jest to~jedna z~najczęściej wybieranych dystrybucji \glslink{unix-like-system}{*nixowych} instalowanych na~serwerach, a~wydaje się, że~to~głównie one --- środowiska serwerowe --- wykorzystują takie narzędzia jak Puppet, Chef, Ansible i~Salt.

Konfiguracja każdego z~czterech, najpopularniejszych rozwiązań sprowadza się do~opisania oczekiwanego stanu systemu w~języku tworzącym warstwę abstrakcji nad~konfiguracją konkretnych systemów. Jedną z~ról wszystkich wymienionych aplikacji jest przetłumaczenie takiej uniwersalnie zapisanej konfiguracji na~konkretne działania systemu, np.~systemu menadżera pakietów. Każde z~przedstawionych rozwiązań ma~podobny zakres wspieranych najpopularniejszych systemów operacyjnych i~oferowanej podstawowej funkcjonalności, w~tym m.in.~instalację pakietów za~pomocą różnych menadżerów pakietów. Dzięki \href{https://sjp.pwn.pl/poradnia/haslo/modularny-modulowy-i-nie-tylko;3162.html}{modułowości} opisanych rozwiązań, istnieje możliwość względnie łatwego rozszerzenia ich funkcjonalności. Tysiące modułów \hyperref[sec:puppet]{Puppeta}, \hyperref[sec:chef]{Chefa}, \hyperref[sec:ansible]{Ansible} i~\hyperref[sec:salt]{Salt} można znaleźć odpowiednio na~stronach internetowych projektów:\mynobreakpar
\begin{itemize}
	\item Puppet Forge --- \hreftt{https://forge.puppet.com/}{forge.puppet.com},
	\item Chef Supermarket --- \hreftt{https://supermarket.chef.io/cookbooks/}{supermarket.chef.io/cookbooks},
	\item Ansible Docs --- \hreftt{http://docs.ansible.com/ansible/list\_of\_all\_modules.html}{docs.ansible.com/ansible/list\_of\_all\_modules.html},
	\item SaltStack Docs --- \hreftt{https://docs.saltstack.com/en/latest/ref/modules/all/index.html}{docs.saltstack.com/en/latest/ref/modules/all/}.
\end{itemize}

Wszystkie opisane rozwiązania oprócz Ansible i~poza specjalnym \href{https://docs.saltstack.com/en/latest/topics/ssh/}{trybem} działania Salt, działają w~modelu klient--serwer\footnote{\hyperref[sec:salt]{Salt} nazywa swój model komunikacji określeniem \emph{agent-server}, ale~w~istocie nie różni się on~od~modelu \emph{klient--serwer}.} i~co~pewien czas odpytują serwer o~aktualizację konfiguracji (model \emph{pull}). Ansible i~Salt wyróżniają się pod~tym względem --- dzięki użyciu~\ssh{} nie wymagają one instalowania na~klientach aplikacji klienckiej, przez co~nadzorca klientów może w~dowolnym momencie wymusić na~nich instalację nowej konfiguracji (model \emph{push}). Z~jednej strony jest to~zaleta, z~drugiej jednak, np.~Puppet, może być postrzegany jako rozwiązanie bardziej wyrafinowane i~złożone, czego świadectwem jest fakt, że~na~podstawie \hyperref[sec:puppet]{manifestu} tworzy on~skierowany graf zasobów systemu i~dopiero na~jego podstawie ustala kolejność przeprowadzenia konfiguracji klienta. Ansible nie tworzy takiego grafu zależności --- konfiguracja klienta jest wykonywana w~takiej kolejności, w~jakiej administrator wyspecyfikował działania w~pliku konfiguracyjnym. Ewentualne błędy wynikłe z~błędów administratora lub~złej kolejności działań wyspecyfikowanych w~\emph{playbooku}, mogą więc być trudne do~wykrycia. Z~tego powodu, mimo podobnej podstawowej funkcjonalności obu rozwiązań, Puppet wydaje się być rozwiązaniem bardziej kompleksowym i~wyrafinowanym.

Warto pamiętać, że~przedstawione rozwiązania mają za~sobą co~najmniej kilka lat rozwoju~(por. lata powstania projektów w~tabeli~\ref{tab:existing-solutions-comparison}), są~tworzone społecznościowo i~za~większością z~nich stoi firma, która napędza ich~rozwój, dzięki czemu istnieją tysiące modułów obsługujących bardzo wiele różnych aspektów konfiguracji systemu. Przykładowo do~rozwoju projektu \emph{\hyperref[sec:ansible]{Ansible}}, \emph{\hyperref[sec:salt]{Salt}}, \emph{\hyperref[sec:chef]{Chef}}, \emph{\hyperref[sec:puppet]{Puppet}}, \emph{\hyperref[itm:cfengine]{CFEngine}} i~\emph{\hyperref[itm:bcfg2]{Bcfg2}} przyczyniło się odpowiednio co~najmniej: \href{https://github.com/ansible/ansible}{3091}, \href{https://github.com/saltstack/salt}{1935}, \href{https://github.com/chef/chef}{525}, \href{https://github.com/puppetlabs/puppet}{467}, \href{https://github.com/cfengine/core}{87} i~\href{https://github.com/Bcfg2/bcfg2}{55}~osób dodając w~sumie odpowiednio: \href{https://github.com/ansible/ansible}{33964}, \href{https://github.com/saltstack/salt}{87634}, \href{https://github.com/chef/chef}{19939}, \href{https://github.com/puppetlabs/puppet}{26168}, \href{https://github.com/cfengine/core}{14025} i~\href{https://github.com/Bcfg2/bcfg2}{8582}~\hrefemph{https://en.wikipedia.org/wiki/Commit\_(version\_control)}{commitów}\footnote{Na~podstawie statystyk z~dnia 11~listopada~2017~roku udostępnionych na stronach repozytoriów projektów udostępnianych przez \hreftt{https://github.com/}{github.com}}. Dzięki zbiorowemu zaangażowaniu programistów rozwiązania te~są~w~stanie zarządzać niemal każdym aspektem konfiguracji systemu operacyjnego i~jego oprogramowania. Jest to~możliwe również dzięki modułowości oprogramowania i~licencji \emph{\glslink{copyleft}{copyleft}}, na~warunkach których zostały udostępnione.

% TODO dopisać tutaj coś o tym jak moje rozwiązanie jest inne od istniejących

Z~racji na~specyfikę pracy magisterskiej, projektowany protokół nie jest tak rozbudowany i~kompleksowy jak największe z~przedstawionych rozwiązań. W~zamian, przygotowane w~ramach tej~pracy oprogramowanie działa według zupełnie innego pomysłu niż~rozwiązania opisane w~niniejszym rozdziale --- w~przeciwieństwie do~nich, administrator nie musi używać języka specyficznego dla~danego rozwiązania do~opisania oczekiwanej konfiguracji systemu. Wystarczy, że~stacja wzorcowa zostanie przeskanowana przed dokonaniem jakichkolwiek zmian, które administrator chce odzwierciedlić na~stacjach klienckich, następnie administrator skonfiguruje stację wzorcową w~taki sposób, w~jaki chciałby skonfigurować grupę stacji klienckich, a~na~koniec przeskanuje system wzorcowy ponownie, w~wyniku czego powstaje \hyperref[sec:obraz-zmian-konfiguracji]{obraz zmian systemu wzorcowego}, który może być przesłany do~stacji klienckich i~przez nie zastosowany. Wszystkie wymienione kroki implementuje zestaw narzędzi przygotowany w~ramach niniejszej pracy.

\newcommand{\tablelogoheight}{0.9cm}
\newcommand*{\centerheader}[1]{\multicolumn{1}{c|}{\includegraphics[height=\tablelogoheight]{#1}}}

\newcommand{\debcontest}{\specialcell{\setstretch{0.5}Miejsce w~rankingu\\[-0.7em]liczby pobrań \emph{\debian{}}\\[-0.7em]\hrefemph{https://tex.stackexchange.com/a/19678/44382}{Pupularity Contest}\\[-0.7em](stan na~11 XI 2017)}}
\newcommand{\famouscompanies}{\specialcell{\setstretch{0.5}Wybrani znani\\[-0.7em]użytkownicy}}
\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}l@{}}#2\end{tabular}}

\begin{table}[t]
	\scriptsize
	\makebox[1.0\textwidth][c]{ % center too wide table
	\begin{tabular}{l|l|l|l|l}
		                        & \puppetlogo                           & \cheflogo                         & \ansiblelogo                         & \saltlogo                        \\\hline\hline
		Rok powstania           & 2005                                  & 2009                              & 2012                                 & 2011                             \\\hline
		Autor                   & \puppetauthor{}~(USA,~\usaorwiki{})   & \chefauthor{}~(USA,~\usawawiki{}) & \ansibleauthor{}~(USA,~\usancwiki{}) & \saltauthor{} (USA,~\usautwiki{})\\\hline
		Język programowania     & \rubylink{}                           & \rubylink{}, \erlanglink{}        & \pythonlink{}, \powershelllink{}     & \pythonlink{}                    \\\hline
		Architektura            & klient--serwer                        & klient--serwer                    & tylko serwer                         & klient--serwer lub~serwer        \\\hline
		Model komunikacji       & \emph{pull}                           & \emph{pull}                       & \emph{push}                          & \emph{push} i~\emph{pull}        \\\hline
		Nazwa konfiguracji      & \emph{manifest}                       & \emph{recipe} / \emph{cookbook}   & \emph{playbook}                      & ---                              \\\hline
		Wsparcie \gls{gnulinux} & \cmark{}                              & \cmark{}                          & \cmark{}                             & \cmark{}                         \\\hline
		Wsparcie Mac~OS         & \cmark{}                              & \cmark{}                          & \cmark{}                             & \cmark{}                         \\\hline
		Wsparcie Windows        & \cmark{}                              & \cmark{}                          & \ansiblewinpartialsupport{}          & \cmark{}                         \\\hline
		Licencja                & \apachegls{}                          & \apachegls{}                      & \gplgls{}                            & \apachegls{}                     \\\hline
		Wersja komercyjna       & \puppetenterprise{}                   & \chefenterprise{}                 & \ansibleenterprise{}                 & \saltenterprise{}                \\\hline
		\pricingtitle{}         & \puppetpricing{}                      & \chefpricing{}                    & \ansiblepricing{}                    & \saltpricing{}                   \\\hline
		Firma                   & \puppetcompany{}                      & \chefcompany{}                    & \redhatcompany{}                     & \saltcompany{}                   \\\hline
		Strona internetowa      & \puppetpage{}                         & \chefpage{}                       & \ansiblepage{}                       & \saltpage{}                      \\\hline
		Dokumentacja            & \puppetdocs{}                         & \chefdocs{}                       & \ansibledocs{}                       & \saltdocs{}                      \\\hline
		Kod źródłowy            & \puppetgithub{}                       & \chefgithub{}                     & \ansiblegithub{}                     & \saltgithub{}                    \\\hline
		\famouscompanies{}      & \puppetcustomers{}                    & \chefcustomers{}                  & \ansiblecustomers{}                  & \saltcustomers{}                 \\\hline
		\debcontest{}           & \puppetdebrank{}                      & \chefdebrank{}                    & \ansibledebrank{}                    & \saltdebrank{} % https://tex.stackexchange.com/a/19678/44382
	\end{tabular}}
	\caption{Porównanie wybranych cech \emph{\puppetref}, \emph{\chefref}, \emph{\ansibleref}, \emph{\saltref}}
	\label{tab:existing-solutions-comparison}
\end{table}

Podczas projektowania przygotowanego rozwiązania starano się~stworzyć możliwie wiele ułatwień dla~jego modułowej, dalszej rozbudowy. Praca implementuje zarządzanie \emph{elementami} konfiguracji systemu, a~nie jego \emph{każdą} częścią --- w~szczególności zaimplementowane rozwiązanie nie ma~wbudowanego mechanizmu zapewniającego, że~dany \gls{daemon} jest uruchomiony. Zapewnienie uruchomienia \glslink{daemon}{daemona} można zapewnić przez synchronizowanie katalogu z~ustawieniami \hreftt{https://en.wikipedia.org/wiki/Cron}{cron}, który odpowiada za~harmonogramowanie zadań w~systemie. Stworzone oprogramowanie jest za~to~w~stanie śledzić zmiany i~aktualizować m.in.~konfigurację zapisaną w~plikach tekstowych i~oprogramowanie zapisane w~postaci bibliotek i~innych plików binarnych. Szczegółowo opisany sposób działania zaimplementowanego w~ramach tej pracy rozwiązania został przedstawiony w~kolejnych dwóch rozdziałach \ref{ch:protokol} i~\ref{ch:implementacja}.

\end{document}
