\documentclass[thesis]{subfiles}

\begin{document}

%------------------------------------------------------------------------------

\chapter{Istniejące rozwiązania}
\label{ch:istniejace-rozwiazania}

W~niniejszym rozdziale przedstawiono przegląd czterech, prawdopodobnie jednych z~najpopularniejszych w~czasie pisania niniejszej pracy, rozwiązań dla~problemu dystrybuowania oprogramowania w~sieci~\cite{leading-scms,wiki:scm-comparison}.

Wymienione w~tym rozdziale aplikacje, poza możliwością synchronizacji zainstalowanego oprogramowania i~konfiguracji, pozwalają również na~inne manipulacje systemem operacyjnym, np.~zapewnienie istnienia wybranego użytkownika w~systemie, zapewnienie działania zadanego \glslink{demon}{demona} czy~konfigurację interfejsów sieciowych. Takie oprogramowanie jest często nazywane w~skrócie~\emph{Software Configuration Management~(SCM)} implementującym ideę \emph{Infrastructure as~Code}, która polega na~traktowaniu infrastruktury komputerowej jak kodu, który może być zarządzany i~przetwarzany przez programy takie jak \href{https://en.wikipedia.org/wiki/Version_control}{systemy kontroli wersji}, \href{https://en.wikipedia.org/wiki/Test_automation}{automatyczne testy}, \href{https://en.wikipedia.org/wiki/Comparison_of_continuous_integration_software}{systemy ciągłej integracji}~itp.\cite{puppet-iac,wiki:iac,wiki:scm}.

%------------------------------------------------------------------------------

\section{Puppet}
\label{sec:puppet}

Jednym z~najpopularniejszych istniejących rozwiązań problemu dystrybuowania oprogramowania jest projekt Puppet, który jest dedykowany nie tylko dla systemów~\glslink{unix-like-system}{*niksowych}, ale~również dla~systemów \emph{Windows} i~\emph{Mac~OS}~\cite{puppet,puppet-github,puppet-clients}.

Puppet został napisany w~języku programowania \href{https://en.wikipedia.org/wiki/Ruby_(programming_language)}{Ruby}, a~jego rozwój jest wspierany i~wykorzystywany przez wiele czołowych firm i~organizacji w~branży~IT, takich jak: \emph{Google}, \emph{NASA}, \emph{Verizon}, \emph{Sony}, \emph{Disney}, \emph{Uber}, \emph{gettyimages}, \emph{CERN} i~wiele\footnote{Oficjalna strona internetowa Puppet \href{https://puppet.com/company/leadership/luke-kanies}{podaje}, że~Puppet jest używany przez ponad 30~tys. firm.} innych~\cite{puppet,puppet-google,puppet-cern,puppet-chef-disney}. Pierwsza wersja Puppet została opublikowana w~2005~roku przez \href{https://puppet.com/company/leadership/luke-kanies}{Luke'a Kaniesa} na~licencji~\glslink{gpl}{GPL}. Od~wersji 2.0~Puppet jest licencjonowany na~warunkach licencji~\glslink{apache2.0-license}{Apache~2.0}. Istnieje również komercyjna wersja projektu, znana pod~nazwą \emph{Puppet Enterprise}.

Konfiguracja Puppet polega na~napisaniu reguł tekstowych, w~języku niezależnym od~systemu operacyjnego (\hrefemph{https://en.wikipedia.org/wiki/Domain-specific_language}{Domain Specific Language}), przechowywanych zwyczajowo w~plikach z~rozszerzeniem~\texttt{.pp}, zwanych \emph{manifestami}. Reguły są~zapisane w~postaci deklaratywnej, a~nie imperatywnej, tzn.~opisują oczekiwany stan systemu, a~nie sposób przeprowadzenia zmian w~systemie. Struktura manifestu jest w~postaci tablicy asocjacyjnej (struktura danych \hreftt{https://docs.ruby-lang.org/en/trunk/Hash.html}{Hash}) z~języka programowania Ruby. Przykładowe manifesty przedstawiono na~listingach \ref{lst:puppet-openssh-example}, \ref{lst:puppet-motd-example} i~\ref{lst:puppet-httpd-example}~\cite{puppet-examples}. Poprawność składni w~manifeście \path{example.pp} można zweryfikować komendą:
\begin{center}
	\texttt{puppet parser validate example.pp}
\end{center}

Aby~wprowadzić zmiany opisane manifestem \texttt{example.pp}, wystarczy uruchomić komendę:
\begin{center}
	\texttt{puppet apply example.pp}
\end{center}

Przed dokonaniem zmian w~systemie pomocna może być flaga \texttt{-{}-noop}, która uruchomia tryb \emph{dry run}, tzn.~tryb w~którym nie są dokonywane żadne zmiany w~systemie, a~na standardowym wyjściu są drukowane zmiany jakie by~zaszły, gdyby nie użyć tej flagi.

\begin{minipage}{\linewidth} % żeby listing nie był podzielony na 2 stronach
\begin{lstlisting}[language=,numbers=none,caption={Manifest Puppet gwarantujący, że~pakiet \texttt{openssh-client}, dostarczający klienta SSH, jest zainstalowany},label=lst:puppet-openssh-example]
package { 'openssh-client':
  ensure => present,
}
\end{lstlisting}
\end{minipage}

\begin{lstlisting}[language=,numbers=none,caption={Manifest Puppet gwarantujący istnienie pliku \hreftt{https://en.wikipedia.org/wiki/Motd_(Unix)}{/etc/motd} z~komunikatem \texttt{Hello!}, który wyświetla się~użytkownikom systemu po~zalogowaniu},label=lst:puppet-motd-example]
file { 'motd':
  path => '/etc/motd',
  content => 'Hello!',
}
\end{lstlisting}

\begin{lstlisting}[language=,numbers=none,caption={Manifest Puppet gwarantujący, że~\gls{demon} \hreftt{https://httpd.apache.org/}{httpd} jest włączony i~działa},label=lst:puppet-httpd-example]
service { 'httpd':
  ensure => running,
  enable => true,
}
\end{lstlisting}

W~nomenklaturze Puppeta istnieją słowa kluczowe, które odpowiadają abstrakcyjnym typom danych, reprezentującym klientów i~ich oprogramowanie. Najważniejsze z~nich to:\mynobreakpar
\begin{itemize}
\item \texttt{class} --- Nazwany blok kodu Puppet przechowywany w~\hyperlink{itm:puppetmodule}{module}. Służy do~konfiguracji dużej części funkcjonalności aplikacji. Konfiguracja \hyperlink{itm:puppetnode}{węzła} pozwala zadeklarować parametryzowane użycie wielu różnych klas. Deklaracja klasy może być co~najwyżej jedna.
\item \hypertarget{itm:puppetmodule}{\texttt{module}} --- Zbiór klas konfigurujący całą aplikację. Społeczność Puppet dostarcza na~stronie internetowej \hreftt{https://forge.puppet.com/}{forge.puppet.com} wielu modułów do~różnego rodzaju oprogramowania, w~tym np.~do~aplikacji serwerowych i~aplikacji użytkowych. Przykładowe moduły obsługują m.in.~serwer stron internetowych \href{https://forge.puppet.com/puppetlabs/apache}{Apache}, serwer~DNS \href{https://forge.puppet.com/ajjahn/dns}{Bind9}, serwer~\href{https://forge.puppet.com/theforeman/dhcp}{DHCP}, narzędzie blokujące~IP z~nietypowym ruchem sieciowym \href{https://forge.puppet.com/netmanagers/fail2ban}{fail2ban}, \href{https://forge.puppet.com/example42/iptables}{iptables}, przeglądarki \href{https://forge.puppet.com/jamesnetherton/google_chrome}{Chrome}, \href{https://forge.puppet.com/h4x/firefox}{Firefox}, klienty poczty \href{https://forge.puppet.com/hetzner/roundcube}{Roundcube}, \href{https://forge.puppet.com/jgoettsch/thunderbird}{Thunderbird}, komunikator \href{https://forge.puppet.com/jamtur01/xmpp}{XMPP/Jabber} i~tysiące innych. Najpopularniejsze moduły są~weryfikowane przez programistów Puppet i~otrzymują status \emph{Puppet Supported} lub~\emph{Puppet Approved}, przez co~mogą być postrzegane jako zaufane.
\item \hypertarget{itm:puppetnode}{\texttt{node}} --- Węzeł. Reprezentacja jednego lub~wielu klientów.
\item Wbudowane typy zasobów, takie jak: \texttt{cron}, \texttt{exec}, \texttt{file}, \texttt{group}, \texttt{host}, \texttt{maillist}, \texttt{mount}, \texttt{package}, \texttt{router}, \texttt{service}, \texttt{ssh\_authorized\_key}, \texttt{user}, \texttt{vlan}, \texttt{zone}, \texttt{zone\_pool} i~wiele innych. Listę tą można rozszerzać o~własne typy danych np.~przez załadowanie dodatkowych modułów~\cite{puppet-resources-types}.
\end{itemize}
W~praktyce często jest pożądane automatyczne odpytywanie serwera przez klienta. Klient Puppeta domyślnie odpytuje serwer o~zmiany oprogramowania co~30~minut. Konfiguracja serwera odpowiadająca za~zdefiniowanie klas oprogramowania dla~poszczególnych klientów jest przechowywana w~głównym manifeście, zwyczajowo nazywanym \href{https://docs.puppet.com/puppet/latest/dirs_manifest.html#directories:-the-main-manifest(s)}{\path{site.pp}}.

\urldef\etchosts\path{%SystemRoot%\system32\drivers\etc\hosts}

W~przykładach~\ref{lst:puppet-openssh-example}, \ref{lst:puppet-motd-example} i~\ref{lst:puppet-httpd-example} zostały użyte trzy, różne zasoby, odpowiednio: pakiet oprogramowania~(\texttt{package}), plik~(\texttt{file}) oraz~serwis~(\texttt{service}). Puppet udostępnia również inne rodzaje zasobów takie jak: użytkownik~(\texttt{user}), grupa~(\texttt{group}), zdarzenie cykliczne~(\texttt{cron}), wykonanie komendy~(\texttt{exec}), wpis w~pliku \path{/etc/hosts}\footnote{Lub~odpowiedniku pliku \path{/etc/hosts} w~systemach nie \glslink{unix-like-system}{*nixowych}, np.~\etchosts~w~systemach Windows \href{https://en.wikipedia.org/wiki/Hosts_(file)\#Location_in_the_file_system}{od}~wersji \href{https://en.wikipedia.org/wiki/Windows_NT}{Windows~NT} do~(aktualnie najnowszego) \href{https://en.wikipedia.org/wiki/Windows_10}{Windows~10}.}. Pełną listę wbudowanych typów zasobów można uzyskać wywołując komendę \texttt{puppet describe --list}. Aby~dowiedzieć się~więcej o~wybranym typie zasobu \texttt{X}, wystarczy wydać komendę:
\begin{center}
	\texttt{puppet describe~X}
\end{center}

Puppet składa się~z~wielu narzędzi towarzyszących. Jednym z~nich jest \hreftt{https://docs.puppet.com/facter/}{facter}, który na~żądanie zbiera informacje o~systemie i~wyświetla je w~jednym z~możliwych formatów: \hreftt{https://en.wikipedia.org/wiki/JSON}{JSON}, \hreftt{https://en.wikipedia.org/wiki/YAML}{YAML} lub~\hreftt{https://en.wikipedia.org/wiki/Plaintext}{plaintext}, który jest formatem domyślnym. Wywołanie komendy \texttt{facter} bez dodatkowych parametrów, wyświetla wszystkie dane o~systemie, jakie zebrało to~narzędzie.

Dla~nowych użytkowników Puppeta została \href{https://puppet.com/download-learning-vm}{przygotowana} przez opiekunów projektu maszyna wirtualna z~samouczkiem tak, aby użytkownik nie~był skazany na~naukę Puppeta na~własnym systemie~\cite{puppet-vm-tutorial}. W~przypadku błędnej konfiguracji Puppeta, stan maszyny wirtualnej z~samouczkiem może być~łatwo przywrócony, co~może nie~być takie proste w~przypadku nieudanych eksperymentów na~własnym systemie.

%------------------------------------------------------------------------------

\section{Chef}
\label{sec:chef}

Chef jest oprogramowaniem napisanym w~językach programowania \href{https://en.wikipedia.org/wiki/Ruby_(programming_language)}{Ruby} (tak jak Puppet) i~\href{https://en.wikipedia.org/wiki/Erlang_(programming_language)}{Erlang} --- zastosowanym tylko do~API w~części serwerowej. Projekt został zapoczątkowany przez \href{https://blog.chef.io/author/adam/}{Adama Jacoba} na~potrzeby firmy consultingowej, ale~po~zaprezentowaniu go~pracownikowi firmy Amazon --- \href{https://en.wikipedia.org/wiki/Jesse_Robbins}{Jesse Robinsowi} --- został został opublikowany na~zasadach licencji \glslink{apache2.0-license}{Apache~2.0} i~zaadaptowany do~użycia w~firmie Amazon. Pierwsza wersja Chef została opublikowana w~2009~roku.

Chef działa w~architekturze klient-serwer. Serwer może być uruchomiony na~systemach operacyjnych: \emph{CentOS}, \emph{Oracle Linux}, \emph{Red Hat Enterprise Linux} i~\emph{Ubuntu}. Serwer można również próbować uruchomić na~systemach \emph{Mac~OS~X} i~\emph{Microsoft Windows} --- dokumentacja Chef wyszczególnia te~systemy jako nieprzetestowane pod~kątem współpracy z~Chef~\cite{chef-supported-platforms}.

Klientami mogą być systemy działające pod~kontrolą m.in.: \emph{AIX}, \emph{CentOS}, \emph{FreeBSD}, \emph{Mac~OS~X}, \emph{Oracle Linux}, \emph{Red Hat Enterprise Linux}, \emph{Solaris}, \emph{Ubuntu}, \emph{Microsoft Windows}, \emph{Cisco NX-OS} i~\emph{Cisco IOS~XR}~\cite{chef-supported-platforms}. Lista wspieranych systemów operacyjnych dla~maszyn działających w~roli klienta jest większa, ale są~one określone jako \emph{Secondary Platforms} i~\emph{Other Platforms} w~przeciwieństwie do~wymienionych, które są~określane jako~\emph{Foundational Platforms}.

Użytkownikami Chefa, tak jak w~przypadku Puppeta, jest wiele dużych firm i~uniwersytetów, takich jak: \emph{Airbnb}, \emph{Disney}, \emph{Mozilla}, \emph{Facebook}, \emph{HP Public Cloud}, \emph{Prezi}, \emph{Uniwersytet Minnesoty}~\cite{chef-customers,puppet-chef-disney}.

Odpowiednikiem plików konfiguracyjnych, które w~Puppet nazywane są~\emph{manifestami}, są~pliki nazywane w~nomenklaturze Chef \emph{przepisami}~(ang.~\emph{recipe}). Przykładowe przepisy przedstawiono w~przykładach~\ref{lst:chef-apache-example}, \ref{lst:chef-user-example} i~\ref{lst:chef-service-example}. Więcej przykładów można znaleźć w,~bogatej w~przykładowe przepisy, dokumentacji Chef~\cite{chef-examples}.

\begin{lstlisting}[language=,numbers=none,caption={Przepis Chef gwarantujący, że~serwer Apache zostanie zainstalowany niezależnie od~tego jak~się~nazywa pakiet oprogramowania go~dostarczający},label=lst:chef-apache-example]
package 'Install Apache' do
  case node[:platform]
  when 'redhat', 'centos'
    package_name 'httpd'
  when 'ubuntu', 'debian'
    package_name 'apache2'
  end
end
\end{lstlisting}

\begin{lstlisting}[language=,numbers=none,caption={Przepis Chef gwarantujący, że~użytkownik \texttt{xyz} istnieje w~systemie i~ma zadane ustawienia konta},label=lst:chef-user-example]
user 'xyz' do
  comment 'A random user'
  uid '1234'
  gid '1234'
  home '/home/random'
  shell '/bin/bash'
  password '$1$JJsvHslasdfjVEroftprNn4JHtDi'
end
\end{lstlisting}

\begin{lstlisting}[language=,numbers=none,caption={Przepis Chef gwarantujący, że~serwis \texttt{example\_service} jest uruchomiony},label=lst:chef-service-example]
service 'example_service' do
  action :start
end
\end{lstlisting}

%------------------------------------------------------------------------------

\section{Ansible}
\label{sec:ansible}

Ansible jest rozwiązaniem do~zarządzania oprogramowaniem różniącym się od~Puppet i~Chef tym, że~do~konfiguracji klientów \glslink{unix-like-system}{*nixowych} używa~SSH, a~do~klientów Windows \hrefemph{http://superuser.com/questions/184926/winrm-what-it-is-and-how-to-use-it}{WinRM} i~\hrefemph{https://en.wikipedia.org/wiki/PowerShell}{PowerShell}, dzięki czemu klienci nie~muszą uruchamiać żadnych dodatkowych procesów działających w~tle --- Ansible działa w~trybie \emph{agentless}, tzn.~klienci nie mają żadnego dedykowanego oprogramowania do~obsługi Ansible. Autorzy projektu Ansible podkreślają na~swojej stronie internetowej, że~w~przeciwieństwie do~konkurencji, Ansible nie jest skomplikowany, przez co~jego szybkie opanowanie jest łatwe~\cite{ansible}.

Ansible został opublikowany na~licencji~\glslink{gpl}{GPL} w~wersji~3, a~jego pierwsza wersja została wydana w~2012~roku. Projekt został zaimplementowany w~języku Python przez \href{http://michaeldehaan.net/}{\mbox{Michaela} \mbox{Dehaana}}~\cite{ansible-github}.


\begin{lstlisting}[language=,numbers=none,caption={Przykładowy plik konfiguracyjny klientów serwera Ansible (w~numenklaturze Ansible nazywany \hrefemph{http://docs.ansible.com/ansible/intro_inventory.html}{Inventory file}), zwyczajowo zapisywany w~\texttt{/etc/ansible/hosts}, definiujący adresy~IP zarządzanych klientów},label=lst:ansible-inventory-example]
[local]
127.0.0.1

[web]
192.168.22.10
192.168.22.11
\end{lstlisting}

Listing~\ref{lst:ansible-inventory-example} przedstawia przykładową konfigurację serwera dotyczącą klientów zarządzanych przez serwer Ansible~\cite{ansible-example}. Po~zapisaniu takiej konfiguracji, Ansible można wykorzystać do~uruchomienia komendy na~wybranej grupie klientów. Np.~komenda:
\begin{center}
\texttt{ansible all -s -m shell -a 'apt-get install nginx'}
\end{center}
zainstaluje serwer HTTP \hreftt{https://www.nginx.com/}{nginx} na wszystkich klientach. Flaga \texttt{-m} wybiera moduł (w~tym wypadku moduł \texttt{shell}), \texttt{-s} zapewnia, że~komenda będzie uruchomiona z~użyciem \hreftt{https://en.wikipedia.org/wiki/Sudo}{sudo}, a~\texttt{-a} pozwala na~przekazanie parametru do~użytego modułu. Taka forma użycia Ansible jest najprostsza i~nie pozwala w~pełni wykorzystać możliwości Ansible. Trochę lepszym, deklaratywnym sposobem, wykorzystującym moduł~\texttt{apt} jest wywołanie:
\begin{center}
\texttt{ansible all -s -m apt -a 'pkg=nginx state=installed update\_cache=true'}
\end{center}
które zwraca wynik na~standardowym wyjściu w~postaci~\texttt{JSON}:
\begin{lstlisting}[language=,numbers=none,frame=none]
127.0.0.1 | success >> {
    "changed": false
}
\end{lstlisting}
Powyższe sposoby uruchamiania Ansible są wykorzystaniem Ansible~\emph{ad-hoc}. Możliwości Ansible w~pełni ujawniają się, gdy~wykorzystamy \hrefemph{http://docs.ansible.com/playbooks_intro.html}{playbook}, czyli odpowiednik manifestu Puppeta i~przepisu Chefa. Przykładowy \emph{playbook} z~listingu~\ref{lst:ansible-playbook-example} przedstawia sposób zainstalowania na~grupie komputerów o~nazwie \texttt{web}~(por. listing~\ref{lst:ansible-inventory-example}) serwera \texttt{nginx}, stworzenia pliku serwowanego przez serwer, a~następnie uruchomienia \glslink{demon}{demona} serwera. Zmiany opisane przez \emph{playbook} można dokonać za~pomocą komendy:\mynobreakpar
\begin{center}
\texttt{ansible-playbook -s nginx.yml}
\end{center}
gdzie \texttt{-s} to~flaga po~której następuje nazwa pliku~\emph{playbook}. Ansible, tak jak konkurencyjne rozwiązania, potrafi zarządzać oprogramowaniem i~konfiguracją w~sposób warunkowy, dlatego w~praktyce użyteczne konfiguracje są~znacznie bardziej złożone od~przykładowych.

\begin{lstlisting}[numbers=none,language=,caption={Przykładowa konfiguracja klientów serwera Ansible, w~nomenklaturze Ansible nazywana \emph{playbook}},label=lst:ansible-playbook-example]
---
- hosts: web
  vars:
   - docroot: /var/www/serversforhackers.com/public
  tasks:
   - name: Add Nginx Repository
     apt_repository: repo='ppa:nginx/stable' state=present
     register: ppastable

   - name: Install Nginx
     apt: pkg=nginx state=installed update_cache=true
     when: ppastable|success
     register: nginxinstalled
     notify:
      - Start Nginx

   - name: Create Web Root
     when: nginxinstalled|success
     file: dest={{ '{{' }} docroot {{ '}}' }} mode=775 state=directory owner=www-data group=www-data
     notify:
      - Reload Nginx

  handlers:
   - name: Start Nginx
     service: name=nginx state=started

    - name: Reload Nginx
      service: name=nginx state=reloaded
\end{lstlisting}

Ansible może zostać uruchomiony na~wielu różnych systemach~\glslink{unix-like-system}{*nixowych}, takich systemach jak~np.~\emph{Red~Hat}, \emph{Debian}, \emph{CentOS}, \emph{OS~X}, \emph{BSD}. System Windows może działać tylko w~roli klienta. Konfiguracja Ansible jest przechowywana w~plikach tekstowych~\texttt{YAML}.

%------------------------------------------------------------------------------

\section{Salt}
\label{sec:salt}

Salt, nazywany też \emph{SaltStack}, to~otwartoźdłowe oprogramowanie napisane w~Pythonie przez \href{https://www.linkedin.com/in/thhatch/}{Thomasa Hatcha} i~opublikowane na~warunkach licencji \glslink{apache2.0-license}{Apache~2.0}. Funkcjonalność Salt jest podobna do~dotychczas opisanych rozwiązań problemu synchronizacji oprogramowania. Pierwsza wersja Salt powstała w~2011~roku, a~więc jest to~najmłodsze rozwiązanie z~dotychczas przedstawionych~\cite{saltstack}.

Salt pracuje w~modelu serwer-agent --- agenci są~nazywani \emph{Salt~Minions}, a~serwer \emph{Salt~Master}. Komunikacja między serwerem i~agentami odbywa się~asynchronicznie, zgodnie ze~wzorcem \hrefemph{https://en.wikipedia.org/wiki/Publish\%E2\%80\%93subscribe\_pattern}{publish/subscribe}, co~implementują wykorzystane biblioteki \hreftt{http://zeromq.org/}{ZeroMQ} oraz~\hreftt{http://www.tornadoweb.org/}{Tornado}. Podczas projektowania Salt położono duży nacisk na~modularność implementowaną jako \href{https://docs.python.org/3.7/tutorial/modules.html}{Pythonowe moduły}\footnote{W~nomenklaturze Salta moduł Pythonowy rozbudowujący funkcjonalność to~\emph{plug-in} (a~nie~\emph{module}).} tak, aby~dodawanie obsługi nowych zasobów było możliwie łatwe. Salt, podobnie jak Puppet, przechowuje konfigurację w~plikach~\texttt{YAML}, \texttt{JSON}, \texttt{plaintext}, a~do zapewnienia bezpieczeństwa komunikacji używa szyfru blokowego~\gls{aes} w~ramach protokołu~\glslink{ssl/tls}{TLS}. Wspierane systemy operacyjne to~m.in. \emph{\glslink{gnulinux}{Linux}}, \emph{Windows}, \emph{MacOS}, \emph{FreeBSD}, \emph{Solaris} i~\emph{AIX}.

Przykład~\ref{lst:salt-topfile-example} przedstawia plik konfiguracyjny \hrefemph{https://docs.saltstack.com/en/getstarted/fundamentals/top.html\#introducing-the-top-file}{Top file}, znajdujący się zwyczajowo w~pliku \path{/srv/salt/top.sls}. Plik ten~definiuje stan różnych agentów --- w~przedstawionym przykładzie~\ref{lst:salt-topfile-example} są~3~rodzajów agentów zdefiniowanych przez wyrażenia regularne dopasowywane do~nazwy agenta:\mynobreakpar
\begin{enumerate}
	\item grupa wszystkich agentów --- wyrażenie regularne~\texttt{'*'} pasuje do~każdej nazwy agenta,
	\item grupa agentów, których nazwa pasuje do~wyrażenia regularnego~\texttt{'*web*'},
	\item grupa agentów, których nazwa pasuje do~wyrażenia regularnego~\texttt{'*db*'}.
\end{enumerate}
Aby~zastosować zmiany opisane w~pliku konfiguracyjnym~\path{top.sls} wystarczy wydać komendę na~komputerze odgrywającym rolę~\emph{Salt Mastera}:
\begin{center}
	\texttt{salt '*' state.apply}
\end{center}

\begin{lstlisting}[numbers=none,language=,caption={Plik konfiguracyjny \texttt{top.sls} w~formacie \texttt{YAML} definiujący konfigurację dla~3~rodzajów agentów},label=lst:salt-topfile-example]
base:
  '*':
    - vim
    - scripts
    - users
  '*web*':
    - apache
    - python
    - django
  '*db*':
    - mysql
\end{lstlisting}
Nazwy znajdujące się w~pliku konfiguracyjnym pod~wyrażeniami regularnymi --- np.~w~przykładzie~\ref{lst:salt-topfile-example}: \texttt{vim}, \texttt{scripts} i~\texttt{users} pod~wyrażeniem regularnym \texttt{'*'} --- to~nazwy stanów opisanych innymi plikami konfiguracyjnymi nazywanymi plikami stanu~(\emph{State Files}). Przykład~\ref{lst:salt-statefile} przedstawia przykładowy plik stanu \path{nettools.sls} (niewystępujący w~przykładowym pliku~\path{top.sls} w~przykładzie~\ref{lst:salt-topfile-example}). Plik ten~wymusza: instalację pakietów \hreftt{https://wiki.archlinux.org/index.php/rsync}{rsync}, \hreftt{https://lftp.yar.ru/}{lftp} i~\hreftt{https://curl.haxx.se/}{curl} oraz~obecność użytkownika \texttt{fred} z~przypisanym \href{https://superuser.com/questions/144666/what-is-the-difference-between-shell-console-and-terminal}{shellem} \href{https://en.wikipedia.org/wiki/Z_shell}{\path{/bin/zsh}}.

\begin{lstlisting}[numbers=none,language=,caption={Plik stanu \texttt{nettools.sls} definujący 3~pakiety, które agent ma~zainstalować oraz~użytkownika \texttt{fred}, który musi być w~systemie i~mieć przypisany shell~\texttt{/bin/zsh}},label=lst:salt-statefile]
install_network_packages:
  pkg.installed:
    - pkgs:
      - rsync
      - lftp
      - curl
  user.present:
    - name: fred
    - shell: /bin/zsh
\end{lstlisting}

Plik stanu można zastosować bezpośrednio na~wybrany rodzaj agentów przez komendę (a~niekoniecznie przez plik konfiguracyjny~\emph{Top file} agregujący pliki stanu). Np.~komenda:
\begin{center}
\texttt{salt 'minion[0-9]' state.apply nettools}
\end{center}
zastosuje plik stanu \path{nettools.sls} dla~agentów o~nazwach od~\texttt{minion0} do~\texttt{minion9}, a~komenda:
\begin{center}
\texttt{salt -C 'G@os:Ubuntu and minion* or S@192.168.50.*' nettools}
\end{center}
zastosuje plik stanu \path{nettools.sls} dla~agentów pracujących pod~kontrolą systemu operacyjnego \texttt{Ubuntu}, których nazwa pasuje do~wyrażenia regularnego \texttt{minion*} lub~których adres~IP pasuje do~wyrażenia regularnego~\texttt{192.168.50.*}.

Ciekawym trybem pracy Salt jest tryb \emph{Agentless}, który polega na~tym, że~agenci nie muszą mieć zainstalowanego klienckiego oprogramowania~Salt. Do~działania, na maszynach klienckich, wystarczy zainstalowany Python i~SSH. Serwer Salt loguje się~do agentów przez~SSH i~rozpakowuje lekką wersję klienta Salt w~katalogu tymczasowym, który w~zależności od~konfiguracji, po~dokonaniu zmian zleconych przez \emph{Salt Mastera}, jest kasowany z~dysku agenta lub~nie.

%------------------------------------------------------------------------------

\section{Inne rozwiązania}

Poza opisanymi do~tej pory rozwiązaniami istnieją również inne:\mynobreakpar
\begin{itemize}
	\item \hrefemph{https://en.wikipedia.org/wiki/Otter_(software)}{Otter}\footnote{\emph{Otter} autorstwa firmy \emph{Inedo} nie~należy mylić \href{https://en.wikipedia.org/wiki/Prover9\#Predecessor}{aplikacją do~automatycznego dowodzenia twierdzeń} i~z~\href{https://pl.wikipedia.org/wiki/Otter\_Browser}{przeglądarką} o~tych samych nazwach.} --- komercyjne oprogramowanie do~automatyzacji głównie systemu Windows, sprzedawane przez firmę \emph{Inedo}~\cite{otter}. Konfiguracja dla systemu Windows odbywa się~przez graficzny interfejs przeglądarki internetowej, a~dla systemów \glslink{unix-like-system}{*nixowych} przez~SSH. Otter jest zintegrowany z~\hrefemph{https://en.wikipedia.org/wiki/PowerShell}{Windows PowerShell}.
	\item\label{itm:cfengine} \hrefemph{https://en.wikipedia.org/wiki/CFEngine}{CFEngine} (skrót od~ang.~\emph{The~\textbf{C}on\textbf{f}iguration \textbf{E}ngine}) --- otwartoźródłowy~(opublikowany na~licencji~\glslink{gpl}{GPL}) system zarządzania konfiguracją autorstwa \href{https://en.wikipedia.org/wiki/Mark_Burgess_(computer_scientist)}{prof.~Marka Burgessa} z~Uniwersytetu w~Oslo~\cite{cfengine}. Projekt jest najstarszy z~zestawienia --- narodził się bowiem w~1993~roku w~Departamencie Fizyki Teoretycznej, gdzie pracował autor projektu. W~roku~2009 została ogłoszona komercyjna wersja projektu. CFEngine działał pierwotnie tylko na~systemach~\glslink{unix-like-system}{*nixowych}, ale~obecnie wspiera również system Windows. CFEngine wyróżnia się na~tle konkurencji tym, że~został napisany w~języku~C. Rozpoznawalnym użytkownikiem CFEngine jest \hrefemph{https://www.linkedin.com/feed/}{LinkedIn} --- międzynarodowy serwis społecznościowy, specjalizujący się w~kontaktach zawodowo-biznesowych (kupiony w~2016~roku przez \emph{Microsoft})~\cite{cfengine-linkedin}.
	\item\label{itm:bcfg2} \hrefemph{https://en.wikipedia.org/wiki/Bcfg2}{Bcfg2} --- projekt napisany w~Pythonie, zapoczątkowany przez \hrefemph{https://en.wikipedia.org/wiki/Argonne_National_Laboratory}{Argonne National Laboratory} --- centrum naukowo-badawcze powstałe w~ramach \href{https://en.wikipedia.org/wiki/Manhattan_Project}{projektu Manhattan}, którego pierwszym dyrektorem był \href{https://en.wikipedia.org/wiki/Enrico_Fermi}{Enrico Fermi}. Na~tle konkurencyjnych rozwiązań wyróżnia się rozbudowaną funkcjonalnością raportowania statystyk przez klientów. Działa na \emph{AIX}, \emph{FreeBSD}, \emph{OpenBSD}, \emph{Mac OS X}, \emph{OpenSolaris}, \emph{Solaris} i~wielu dystrybucjach \gls{gnulinux}: \emph{Alpine Linux}, \emph{ArchLinux}, \emph{Blag}, \emph{CentOS}, \emph{Debian}, \emph{Fedora}, \emph{Gentoo}, \emph{gNewSense}, \emph{Mandriva}, \emph{openSUSE}, \emph{Red~Hat/RHEL}, \emph{SuSE/SLES}, \emph{Trisquel} i~\emph{Ubuntu}~\cite{bcfg2}.
\end{itemize}

W~pracy nie scharakteryzowano wszystkich istniejących rozwiązań do~zarządzania konfiguracją systemów operacyjnych~\cite{wiki:scm-comparison}. Nazwy innych, wybranych otwartoźródłowych rozwiązań to~m.in.:~\hrefemph{https://en.wikipedia.org/wiki/Capistrano_(software)}{Capistrano}, \hrefemph{https://en.wikipedia.org/wiki/Cdist}{cdist}, \hrefemph{https://en.wikipedia.org/wiki/ISconf}{ISconf}, \hrefemph{https://en.wikipedia.org/wiki/LCFG}{LCFG}, \hrefemph{https://en.wikipedia.org/wiki/Juju_(software)}{Juju}, \hrefemph{https://en.wikipedia.org/wiki/OCS_Inventory}{OCS~Inventory}, \hrefemph{https://en.wikipedia.org/wiki/OpenLMI}{OpenLMI}, \hrefemph{https://en.wikipedia.org/wiki/Opsi}{Opsi}, \hrefemph{https://en.wikipedia.org/wiki/PIKT}{PIKT}, \hrefemph{https://en.wikipedia.org/wiki/Quattor}{Quattor}, \hrefemph{https://en.wikipedia.org/wiki/Radmind}{Radmind}, \hrefemph{https://en.wikipedia.org/wiki/Rex_(software)}{Rex}, \hrefemph{https://en.wikipedia.org/wiki/Rudder_(software)}{Rudder}, \hrefemph{https://en.wikipedia.org/wiki/SmartFrog}{SmartFrog}, \hrefemph{https://en.wikipedia.org/wiki/Spacewalk_(software)}{Spacewalk}, \hrefemph{https://en.wikipedia.org/wiki/Software_Testing_Automation_Framework}{STAF}, \hrefemph{https://en.wikipedia.org/wiki/Synctool}{Synctool}, \hrefemph{https://en.wikipedia.org/wiki/Terraform_(software)}{Terraform}. Nie wszystkie z~nich mają tak rozbudowaną funkcjonalność jak rozwiązania opisane w~niniejszym rozdziale --- np.~Radmind zarządza tylko systemem plików, STAF służy do~konfiguracji środowisk testowych, ISconf nie ma wyróżnionego serwera, a~Rudder bazuje na~CFEngine i~systemie kontroli wersji~\href{https://en.wikipedia.org/wiki/Git}{git}.

Określenie \emph{Configuration Management}, na~które powołuje się niniejsza praca do~określenia rodzaju projektowanego oprogramowania, może być kojarzona również z~takimi rozwiązaniami jak~np.~\hrefemph{https://en.wikipedia.org/wiki/Vagrant_(software)}{Vagrant} i~\hrefemph{https://en.wikipedia.org/wiki/Docker_(software)}{Docker}. Rozwiązania te~zostały jednak \href{http://stackoverflow.com/questions/16647069/should-i-use-vagrant-or-docker-for-creating-an-isolated-environment}{zaprojektowane} do~zarządzania \href{http://stackoverflow.com/questions/16047306/how-is-docker-different-from-a-normal-virtual-machine}{środowiskami wirtualnymi}, a~nie bezpośrednio konfiguracją systemu, na~którym działają. Przykładowo \href{https://www.vagrantup.com/intro/index.html}{Vagrant} może wykorzystać do~działania np.~\href{https://en.wikipedia.org/wiki/VMware}{VMWare}, \href{https://en.wikipedia.org/wiki/VirtualBox}{VirtualBox}, \href{https://en.wikipedia.org/wiki/Hyper-V}{Hyper-V}, \href{https://en.wikipedia.org/wiki/Amazon_Web_Services}{AWS}\footnote{\emph{Amazon Web Services}.}, a~\href{https://www.docker.com/what-docker}{Docker} \href{https://en.wikipedia.org/wiki/Linux_containers}{kontenery Linux}. Co~ciekawe, zarówno \href{https://www.vagrantup.com/docs/provisioning/puppet_apply.html}{Vagrant} jak~i~\href{https://puppet.com/presentations/using-docker-puppet-james-turnbull-kickstarter}{Docker} można łatwo zintegrować z~\hyperref[sec:puppet]{Puppet}.

%------------------------------------------------------------------------------

\section{Podsumowanie}

W~rozdziałach~\ref{sec:puppet}, \ref{sec:chef}, \ref{sec:ansible} i~\ref{sec:salt} zostały opisane cztery, \href{http://www.infoworld.com/article/2609482/data-center/data-center-review-puppet-vs-chef-vs-ansible-vs-salt.html}{prawdopodobnie} najpopularniejsze istniejące rozwiązania dystrybuowania oprogramowania~\cite{leading-scms}. Z~porównania \href{https://www.openhub.net/p/_compare?project_0=Puppet&project_2=salt&project_1=Ansible}{statystyk} użycia tych programów, prowadzonych przez \hreftt{https://www.openhub.net/}{openhub.net} oraz~przez projekt \emph{Debian Popularity Contest} (\hreftt{http://popcon.debian.org/}{popcon.debian.org}), wynika jednoznacznie, że~\href{https://qa.debian.org/popcon.php?package=puppet}{najpopularniejszym} rozwiązaniem z~przedstawionych --- przynajmniej wśród użytkowników Debiana --- jest Puppet, a~najmniej popularnym \href{https://qa.debian.org/popcon.php?package=chef}{Chef}. Wg~\hreftt{https://www.openhub.net/}{openhub.net} drugie miejsce pod~względem popularności zajmuje \href{https://qa.debian.org/popcon.php?package=salt}{Salt}, a~trzecie \href{https://qa.debian.org/popcon.php?package=ansible}{Ansible}. Wg~statystyk \emph{Debian Popularity Contest} --- odwrotnie. To,~że~wg~obu~statystyk najpopularniejszy zdaje się być~Puppet, nie znaczy, że~jego konkurencja zostaje daleko w~tyle --- przeciwnie --- wg~\emph{Debian Popularity Contest} linia trendu liczby pobrań Puppeta maleje od~początku 2017~roku, a~Ansible i~Salta stale rośnie od~początku zaistnienia w~repozytorium Debiana\footnote{Analiza trendu w~przedziale od~początku istnienia analizowanych rozwiązań w~repozytorium Debiana (każde z~nich zadebiutowało przed 2013r.) do~dnia~7~maja~2017r., w~którym pisane są~te~słowa.}. Należy mieć świadomość, że~podane statystyki mogą okazać się niewystarczająco reprezentatywne, aby~uogólniać wnioski dotyczące popularności przedstawionych rozwiązań na~cały sektor~IT. Z~drugiej jednak strony Debian jest dystrybucją prowadzącą \href{https://www.debian.org/doc/manuals/debian-faq/ch-ftparchives#s-frozen}{politykę} wersjonowania pakietów sprzyjającą stabilności, przez co~jest to~jedna z~najczęściej wybieranych dystrybucji \glslink{unix-like-system}{*nixowych} instalowanych na~serwerach, a~to~głównie one --- środowiska serwerowe --- wykorzystują takie narzędzia jak Puppet, Chef, Ansible i~Salt.

\newcommand{\tablelogoheight}{0.9cm}
\newcommand*{\centerheader}[1]{\multicolumn{1}{c|}{\includegraphics[height=\tablelogoheight]{#1}}}
\newcommand{\puppetlogo}{\centerheader{img/Puppet_logo}}
\newcommand{\cheflogo}{\centerheader{img/Chef_logo}}
\newcommand{\ansiblelogo}{\centerheader{img/Ansible_logo}}
\newcommand{\saltlogo}{\multicolumn{1}{c}{\includegraphics[height=\tablelogoheight]{img/SaltStack_logo}}}

\newcommand{\puppetauthor}{\href{https://puppet.com/company/leadership/luke-kanies}{Luke Kanies}}
\newcommand{\chefauthor}{\href{https://blog.chef.io/author/adam/}{Adam Jacob}}
\newcommand{\ansibleauthor}{\href{http://michaeldehaan.net/}{Michael Dehaan}}
\newcommand{\saltauthor}{\href{https://www.linkedin.com/in/thhatch/}{Thomas Hatch}}

\newcommand{\puppetref}{\hyperref[sec:puppet]{Puppet}}
\newcommand{\chefref}{\hyperref[sec:chef]{Chef}}
\newcommand{\ansibleref}{\hyperref[sec:ansible]{Ansible}}
\newcommand{\saltref}{\hyperref[sec:salt]{Salt}}

\newcommand{\rubylink}{\href{https://en.wikipedia.org/wiki/Ruby_(programming_language)}{Ruby}}
\newcommand{\erlanglink}{\href{https://en.wikipedia.org/wiki/Erlang_(programming_language)}{Erlang}}
\newcommand{\pythonlink}{\href{https://en.wikipedia.org/wiki/Python_(programming_language)}{Python}}
\newcommand{\powershelllink}{\href{https://en.wikipedia.org/wiki/PowerShell}{PowerShell}}

\newcommand{\apachegls}{\glslink{apache2.0-license}{Apache~2.0}}
\newcommand{\gplgls}{\glslink{gpl}{GPLv3}}

\newcommand{\puppetpage}{\hreftt{https://puppet.com/}{puppet.com}}
\newcommand{\chefpage}{\hreftt{https://www.chef.io/}{chef.io}}
\newcommand{\ansiblepage}{\hreftt{https://www.ansible.com/}{ansible.com}}
\newcommand{\saltpage}{\hreftt{https://saltstack.com/}{saltstack.com}}

\newcommand{\puppetgithub}{{\tiny\hreftt{https://github.com/puppetlabs/puppet}{github.com/puppetlabs/puppet}}}
\newcommand{\chefgithub}{{\tiny\hreftt{https://github.com/chef/chef}{github.com/chef/chef}}}
\newcommand{\ansiblegithub}{{\tiny\hreftt{https://github.com/ansible/ansible}{github.com/ansible/ansible}}}
\newcommand{\saltgithub}{{\tiny\hreftt{https://github.com/saltstack/salt}{github.com/saltstack/salt}}}

\newcommand{\puppetenterprise}{\href{https://puppet.com/product}{Puppet Enterprise}}
\newcommand{\chefenterprise}{\href{https://www.chef.io/automate/}{Chef Automate}}
\newcommand{\ansibleenterprise}{\href{https://www.ansible.com/pricing}{Ansible Tower}}
\newcommand{\saltenterprise}{\href{https://saltstack.com/saltstack-enterprise/}{SaltStack Enterprise}}

\newcommand{\puppetdocs}{\hreftt{https://docs.puppet.com/}{docs.puppet.com}}
\newcommand{\chefdocs}{\hreftt{https://docs.chef.io/}{docs.chef.io}}
\newcommand{\ansibledocs}{\hreftt{http://docs.ansible.com/}{docs.ansible.com}}
\newcommand{\saltdocs}{\hreftt{https://docs.saltstack.com/}{docs.saltstack.com}}

\newcommand{\puppetcompany}{\href{https://en.wikipedia.org/wiki/Puppet_(company)}{Puppet,~Inc.}\tablefootnote{Do~kwietnia~2016 firma \href{https://puppet.com/puppet-labs-is-puppet}{nosiła} nazwę \emph{Puppet~Labs}.}}
\newcommand{\chefcompany}{\href{https://www.sec.gov/Archives/edgar/data/1545207/000154520713000002/xslFormDX01/primary_doc.xml}{Chef Software,~Inc.}\tablefootnote{Do~grudnia~2013 firma \href{https://www.chef.io/about/}{nosiła} nazwę \emph{Opscode}.}}
\newcommand{\redhatcompany}{\href{https://www.sec.gov/cgi-bin/browse-edgar?action=getcompany\&CIK=0001087423\&owner=exclude\&count=40\&hidefilings=0}{Red Hat,~Inc.}}
\newcommand{\saltcompany}{\href{https://www.sec.gov/Archives/edgar/data/1570778/000157077813000002/xslFormDX01/primary_doc.xml}{Salt Stack,~Inc.}}

\newcommand{\pricingtitle}{Cena wersji płatnej\tablefootnote{W~tabeli uwzględniono najtańsze standardowe licencje opublikowane na~stronach producentów.}}
\newcommand{\puppetpricing}{\href{https://puppet.com/product/pricing}{\$120 za~1~maszynę/rok}}
\newcommand{\chefpricing}{\href{https://www.chef.io/pricing/}{\$137 za~1~maszynę/rok}}
\newcommand{\ansiblepricing}{\href{https://www.ansible.com/pricing}{\$5,000 za~100~maszyn/rok}}
\newcommand{\saltpricing}{\href{https://saltstack.com/saltstack-enterprise/}{Nie podano}\tablefootnote{Cena zostaje podana po~kontakcie przez e-mail \hreftt{mailto:sales@saltstack.com}{sales@saltstack.com}.}}

\newcommand{\ansiblewinpartialsupport}{\href{http://docs.ansible.com/ansible/intro_installation.html\#control-machine-requirements}{Częściowe}}

\newcommand{\usaorwiki}{\href{https://en.wikipedia.org/wiki/Oregon}{OR}}
\newcommand{\usawawiki}{\href{https://en.wikipedia.org/wiki/Washington_(state)}{WA}}
\newcommand{\usancwiki}{\href{https://en.wikipedia.org/wiki/North_Carolina}{NC}}
\newcommand{\usautwiki}{\href{https://en.wikipedia.org/wiki/Utah}{UT}}

\newcommand{\puppetdebrank}{\href{https://qa.debian.org/popcon.php?package=puppet}{5725}}
\newcommand{\chefdebrank}{\href{https://qa.debian.org/popcon.php?package=chef}{12089}}
\newcommand{\ansibledebrank}{\href{https://qa.debian.org/popcon.php?package=ansible}{8844}}
\newcommand{\saltdebrank}{\href{https://qa.debian.org/popcon.php?package=salt}{9014}}

\newcommand{\debcontest}{\specialcell{\setstretch{0.5}Miejsce w~rankingu\\[-0.7em]liczby pobrań \emph{Debian}\\[-0.7em]\hrefemph{https://tex.stackexchange.com/a/19678/44382}{Pupularity Contest}\\[-0.7em](stan na~06.06.2917)}}
\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}l@{}}#2\end{tabular}}

\begin{table}[t]
	\scriptsize
	\makebox[\textwidth][c]{ % center too wide table
	\begin{tabular}{l|l|l|l|l}
		                    & \puppetlogo                     & \cheflogo                       & \ansiblelogo                     & \saltlogo                    \\\hline\hline
		Rok powstania       & 2005                            & 2009                            & 2012                             & 2011                         \\\hline
		Autor               & \puppetauthor~(USA,~\usaorwiki) & \chefauthor~(USA,~\usawawiki)   & \ansibleauthor~(USA,~\usancwiki) & \saltauthor~(USA,~\usautwiki)\\\hline
		Język programowania & \rubylink                       & \rubylink, \erlanglink          & \pythonlink, \powershelllink     & \pythonlink                  \\\hline
		Architektura        & Klient-serwer                   & Klient-serwer                   & Tylko serwer                     & Klient-serwer                \\\hline
		Model komunikacji   & \emph{pull}                     & \emph{pull}                     & \emph{push}                      & \emph{push} i~\emph{pull}    \\\hline
		Nazwa konfiguracji  & \emph{manifest}                 & \emph{recipe} / \emph{cookbook} & \emph{playbook}                  & ---                          \\\hline
		Wsparcie GNU/Linux  & \cmark                          & \cmark                          & \cmark                           & \cmark                       \\\hline
		Wsparcie Mac~OS     & \cmark                          & \cmark                          & \cmark                           & \cmark                       \\\hline
		Wsparcie Windows    & \cmark                          & \cmark                          & \ansiblewinpartialsupport        & \cmark                       \\\hline
		Licencja            & \apachegls                      & \apachegls                      & \gplgls                          & \apachegls                   \\\hline
		Wersja komercyjna   & \puppetenterprise               & \chefenterprise                 & \ansibleenterprise               & \saltenterprise              \\\hline
		\pricingtitle       & \puppetpricing                  & \chefpricing                    & \ansiblepricing                  & \saltpricing                 \\\hline
		Firma               & \puppetcompany                  & \chefcompany                    & \redhatcompany                   & \saltcompany                 \\\hline
		Strona internetowa  & \puppetpage                     & \chefpage                       & \ansiblepage                     & \saltpage                    \\\hline
		Dokumentacja        & \puppetdocs                     & \chefdocs                       & \ansibledocs                     & \saltdocs                    \\\hline
		Kod źródłowy        & \puppetgithub                   & \chefgithub                     & \ansiblegithub                   & \saltgithub                  \\\hline
		\debcontest         & \puppetdebrank                  & \chefdebrank                    & \ansibledebrank                  & \saltdebrank % https://tex.stackexchange.com/a/19678/44382
	\end{tabular}}
	\caption{Porównanie wybranych cech \emph{\puppetref}, \emph{\chefref}, \emph{\ansibleref}, \emph{\saltref}}
	\label{tab:existing-solutions-comparison}
\end{table}

Konfiguracja każdego z~czterech, najpopularniejszych rozwiązań sprowadza się do~opisania oczekiwanego stanu systemu w~języku tworzącym warstwę abstrakcji nad~konfiguracją konkretnych systemów. Jedną z~ról wszystkich wymienionych aplikacji jest przetłumaczenie takiej uniwersalnej konfiguracji na~konkretne działania systemu, np.~systemu menadżera pakietów. Każde z~przedstawionych rozwiązań ma~podobny zakres wspieranych najpopularniejszych systemów operacyjnych i~oferowanej podstawowej funkcjonalności, w~tym m.in.~instalację pakietów za~pomocą różnych menadżerów pakietów. Dzięki modułowości opisanych rozwiązań, istnieje możliwość względnie łatwego rozszerzenia ich funkcjonalności. Tysiące modułów Puppeta, Chefa, Ansible i~Salt można znaleźć odpowiednio na~stronach internetowych projektów:\mynobreakpar
\begin{itemize}
	\item Puppet Forge --- \hreftt{https://forge.puppet.com/}{forge.puppet.com},
	\item Chef Supermarket --- \hreftt{https://supermarket.chef.io/cookbooks/}{supermarket.chef.io/cookbooks},
	\item Ansible Docs --- \hreftt{http://docs.ansible.com/ansible/list\_of\_all\_modules.html}{docs.ansible.com/ansible/list\_of\_all\_modules.html}
	\item SaltStack Docs --- \hreftt{https://docs.saltstack.com/en/latest/ref/modules/all/index.html}{docs.saltstack.com/en/latest/ref/modules/all/}.
\end{itemize}

Wszystkie opisane rozwiązania oprócz Ansible i~poza specjalnym \href{https://docs.saltstack.com/en/latest/topics/ssh/}{trybem} działania Salt, działają w~modelu klient-serwer\footnote{Salt nazywa swój model komunikacji określeniem \emph{agent-server}, ale~w~istocie nie różni się on~od~modelu \emph{klient-serwer}.} i~co~pewien czas odpytują serwer o~aktualizację konfiguracji (model \emph{pull}). Ansible i~Salt wyróżniają się pod~tym względem --- dzięki użyciu~SSH nie wymagają one instalowania na~klientach aplikacji klienckiej, przez co~nadzorca klientów może w~dowolnym momencie wymusić instalację nowej konfiguracji na~kontrolowanych komputerach (model \emph{push}). Z~jednej strony jest to~zaleta, z~drugiej jednak, np.~Puppet, może być postrzegany jako rozwiązanie bardziej wyrafinowane i~złożone, czego świadectwem jest fakt, że~na~podstawie \hyperref[sec:puppet]{manifestu} tworzy on~skierowany graf zasobów i~dopiero na~jego podstawie ustala kolejność przeprowadzenia konfiguracji klienta. Ansible nie tworzy takiego grafu zależności --- konfiguracja klienta jest wykonywana w~takiej kolejności, w~jakiej administrator wyspecyfikował działania w~pliku konfiguracyjnym. Ewentualne błędy wynikłe z~błędów administratora lub~złej kolejności działań wyspecyfikowanych w~\emph{playbooku}, mogą więc być trudne do~wykrycia. Z~tego powodu, mimo podobnej podstawowej funkcjonalności obu rozwiązań, Puppet wydaje się być rozwiązaniem bardziej kompleksowym.

Warto pamiętać, że~przedstawione rozwiązania mają za~sobą co~najmniej kilka lat rozwoju~(por. tebelę~\ref{tab:existing-solutions-comparison}) i~są~rozwiązaniami tworzonymi społecznościowo, dzięki czemu istnieją tysiące modułów obsługujących bardzo wiele różnych aspektów konfiguracji systemu. Przykładowo do~rozwoju projektu \emph{\hyperref[sec:ansible]{Ansible}}, \emph{\hyperref[sec:salt]{Salt}}, \emph{\hyperref[sec:chef]{Chef}}, \emph{\hyperref[sec:puppet]{Puppet}}, \emph{\hyperref[itm:cfengine]{CFEngine}} i~\emph{\hyperref[itm:bcfg2]{Bcfg2}} przyczyniło się odpowiednio co~najmniej: \href{https://github.com/ansible/ansible}{2717}, \href{https://github.com/saltstack/salt}{1815}, \href{https://github.com/chef/chef}{510}, \href{https://github.com/puppetlabs/puppet}{447}, \href{https://github.com/cfengine/core}{84} i~\href{https://github.com/Bcfg2/bcfg2}{55}~osób dodając w~sumie odpowiednio: \href{https://github.com/ansible/ansible}{30552}, \href{https://github.com/saltstack/salt}{82608}, \href{https://github.com/chef/chef}{19368}, \href{https://github.com/puppetlabs/puppet}{25215}, \href{https://github.com/cfengine/core}{13884} i~\href{https://github.com/Bcfg2/bcfg2}{8532}\hrefemph{https://en.wikipedia.org/wiki/Commit\_(version\_control)}{commitów}\footnote{Na~podstawie statystyk z~dnia 6~czerwca~2017~roku, udostępnionych na stronach repozytoriów projektów udostępnianych przez \hreftt{https://github.com/}{github.com}}. Dzięki zbiorowemu zaangażowaniu programistów rozwiązania te~są~w~stanie zarządzać niemal każdym aspektem konfiguracji systemu operacyjnego i~jego oprogramowania. Jest to~możliwe również dzięki modułowości oprogramowania i~licencji \glslink{copyleft}{copyleft}, na~warunkach których zostały udostępnione.

Z~racji na~specyfikę pracy magisterskiej, projektowany protokół nie jest tak rozbudowany jak największe z~przedstawionych rozwiązań. W~zamian, podczas projektowania protokołu starano się~stworzyć możliwie wiele ułatwień dla~jego modułowej, dalszej rozbudowy. Niniejsza praca implementuje zarządzanie elementami konfiguracji systemu --- w~szczególności zaimplementowane rozwiązanie nie ma~wbudowanego mechanizmu do~zapewnienia istnienia np.~plików specjalnych i~mechanizmu zapewniającego, że~dany \gls{demon} jest uruchomiony\footnote{Chyba, że~administrator sam napisze taki skrypt i~go~umieści w~odpowiednim katalogu tworzonego obrazu konfiguracji --- np.~w~katalogu \hreftt{https://en.wikipedia.org/wiki/Cron}{crona}.}. Stworzone oprogramowanie jest za~to~w~stanie śledzić zmiany i~aktualizować m.in.~konfigurację zapisaną w~plikach tekstowych i~oprogramowanie zapisane w~postaci plików binarnych.

\end{document}
