\documentclass[thesis]{subfiles}

\begin{document}

\chapter{Protokół komunikacji}
\label{ch:protokol}

Celem niniejszej pracy jest ułatwienie pracy administratora komputerowego przez zaprojektowanie i~zaimplementowanie protokołu umożliwiającego propagowanie zmian w~systemie plików, pakietów oraz~elementów konfiguracji do~stacji roboczych pod~kontrolą systemu operacyjnego \glslink{gnulinux}{Linux/GNU} lub~innego systemu \glslink{unix-like-system}{*nix}, a~także elastycznego standardu opisu zmian oraz~narzędzi dla~ich rejestrowania i~dostosowywania. Tak~przedstawiony cel wydaje się być zbliżony do~celu jaki postawili przed sobą twórcy istniejących rozwiązań, przedstawionych w~rozdziale~\ref{ch:istniejace-rozwiazania}, jednak pomysł na~jego realizację w~ramach tej pracy jest zasadniczo inny od~istniejących implementacji.

%------------------------------------------------------------------------------

\section{Idea działania}

Typowy scenariusz użycia dowolnego z~przedstawionych w~rozdziale~\ref{ch:istniejace-rozwiazania}. czterech rozwiązań, polega w~uproszczeniu na~tym, że~administrator komputerowy przygotowuje zestaw plików konfiguracyjnych, będących abstrakcyjnym, tzn.~niezależnym od~konkretnego systemu, \href{https://martinfowler.com/bliki/DomainSpecificLanguage.html}{wyrażaniem} wymagań administratora w~stosunku do~konfiguracji systemów klienckich. Tak przygotowane pliki konfiguracyjne są~następnie przetwarzane --- w~zależności od~rozwiązania --- przez aplikację serwera lub~klienta, a~wynik przetworzenia jest docelową konfiguracją klienta, do~której klient się dostosowuje. W~zależności od~rozwiązania, klient odpytuje serwer co~pewien czas o~aktualizację oprogramowania (model \emph{pull}) --- tak się dzieje np.~w~\hyperref[sec:puppet]{Puppet}, \hyperref[sec:chef]{Chef} i~w~zwykłym trybie pracy \hyperref[sec:salt]{Salt} --- lub~serwer wymusza zmiany na~kliencie (model \emph{push}) --- jak np.~w~\hyperref[sec:ansible]{Ansible} i~w~trybie \emph{agentless} w~\hyperref[sec:salt]{Salt}. Po~zastosowaniu się do~zmian konfiguracji przesłanych przez serwer do~klienta, klient, w~zależności od~rozwiązania, może poinformować serwer o~powodzeniu lub~niepowodzeniu przeprowadzonej instalacji i~może przesłać dodatkowe logi, z~których serwer może przygotować np.~kompleksowe raporty.

Rozwiązanie stworzone w~ramach niniejszej pracy działa w~odmienny sposób. Zaprojektowany zestaw narzędzi zwalnia administratora komputerowego z~konieczności przygotowania plików konfiguracyjnych, szczegółowo opisujących konfigurację klientów, jak ma~to~miejsce w~istniejących rozwiązaniach, opisanych w~rozdziale~\ref{ch:istniejace-rozwiazania}. Takie podejście ma~praktyczną zaletę polegającą na~tym, że~administrator nie musi poznawać języka (\hrefemph{https://en.wikipedia.org/wiki/Domain-specific_language}{Domain Specific Language}), którym posługuje się aplikacja do~abstrakcyjnego opisania wzorcowej konfiguracji.

Typowy przykład użycia rozwiązania stworzonego w~ramach tej~pracy polega na~tym, że~administrator, przed dokonaniem jakichkolwiek zmian, które chce, aby~były odzwierciedlone na~stacjach klienckich, skanuje system, który jest wzorcem oprogramowania i~konfiguracji dla~klientów. W~typowym przypadku, pierwsze takie skanowanie zostaje przeprowadzonym na~,,czystym'' systemie operacyjnym, tzn.~dopiero co~zainstalowanym i~niezmodyfikowanym. W~wyniku przeprowadzonego skanowania systemu powstaje plik opisujący stan systemu, który jest stanem referencyjnym, tzn.~takim, do~którego będą porównywane wyniki kolejnych skanowań. Po~wykonaniu skanowania, administrator konfiguruje przeskanowany uprzednio system, tak, jak chciałby skonfigurować stacje klienckie. Wszystkie zmiany, które wykona na~systemie wzorcowym\footnote{W~dalszej części pracy, określenie \emph{system wzorcowy} będzie skrótowo utożsamiany z~systemem, którego konfiguracja została przeskanowana i~na podstawie której powstał obraz zmian dla~klientów.}, zostają wykryte i~odnotowane podczas drugiego skanowania, którego wynikiem jest drugi plik opisujący stan systemu po~dokonaniu zmian w~konfiguracji przez administratora. Na~podstawie tych dwóch plików stanów, administrator, za~pomocą przygotowanych w~ramach tej pracy aplikacji, otrzymuje obraz zmian, który zostanie przesłany do~klientów i~zastosowany przez nich. Przed przeniesieniem obrazu zmian konfiguracji na~stację kliencką, klient powinien mieć już zainstalowany system operacyjny, który zostanie tylko skonfigurowany za~pomocą otrzymanej obrazu zmian konfiguracji.

Kolejne trzy rozdziały~\ref{sec:tworzenie-obrazu-konfiguracji}, \ref{sec:przeslanie-obrazu-konfiguracji} i~\ref{sec:zastosowanie-obrazu-konfiguracji} opisują wszystkie trzy etapy użycia zaprojektowanego zestawu narzędzi, tzn.~kolejno --- stworzenie obrazu zmian konfiguracji stacji wzorcowej, przesłanie jej do~klienta i~zastosowanie jej przez system klienta.

%------------------------------------------------------------------------------

\section{Tworzenie obrazu zmian konfiguracji}
\label{sec:tworzenie-obrazu-konfiguracji}

Tworzenie obrazu zmian konfiguracji wzorcowej, tzn.~zestawu plików składających się na~konfigurację, która zostanie zastosowana na~maszynach klienckich, odbywa się w~trzech lub~czterech krokach, w~zależności od~tego czy stacja wzorcowa była wcześniej skanowana\footnote{Przez \emph{skanowanie} rozumie się przeanalizowanie systemu plików stacji wzorcowej w~poszukiwaniu zmian konfiguracji lub~ustalenie konfiguracji referencyjnej w~przypadku pierwszego skanowania.} --- w~wyniku czego powstał plik podsumowujący stan systemu --- czy nie była i~taki plik jeszcze nie powstał. Jeśli stacja nie była wcześniej skanowana, to~do~wygenerowania obrazu konfiguracji jest wymagane wykonanie następujących czterech kroków:\mynobreakpar
\begin{enumerate}
	\item \hypertarget{itm:pierwsze-skanowanie} Pierwsze skanowanie tej części systemu plików stacji wzorcowej, którą administrator chce przenieść na~maszyny klienckie. Skanowanie odbywa się za~pomocą programu skanera, korzystającego z~programu~\href{http://aide.sourceforge.net/}{AIDE}, opisanego szerzej w~rozdziale~\ref{sec:aide},  dotyczącym implementacji projektu. W~wyniku skanowania powstaje plik tekstowy ze~\href{https://en.wikipedia.org/wiki/Hash_function}{skrótami}~(np.~\href{https://en.wikipedia.org/wiki/MD5}{MD5}, \href{https://en.wikipedia.org/wiki/SHA-1}{SHA1}, \href{https://en.wikipedia.org/wiki/Cyclic_redundancy_check}{CRC32} lub~innymi) przeskanowanych plików, definiującymi referencyjny stan systemu, do~którego będą porównywane wyniki skanowań systemu po~dokonaniu zmian konfiguracji na~nim. Ustawienie parametrów skanowania, w~tym m.in.~zakresu skanowanych katalogów i~wybór funkcji skrótu odbywa się za~pomocą konfiguracji programu~\href{http://aide.sourceforge.net/}{AIDE}, opisanej w~rozdziale~\ref{sec:aide}.
	\item \hypertarget{itm:dokonanie-zmian} Dokonanie zmian w~konfiguracji maszyny wzorcowej, tak, jakby była maszyną kliencką, której konfigurację administrator chce dostosować do~wzorca. Wszystkie pliki maszyny wzorcowej, które ulegną zmianie od~czasu pierwszego skanowania oraz~wszystkie usunięte i~nowe pliki, które odpowiednio --- znajdowały lub~znajdują się --- w~katalogach skanowanych podczas pierwszego skanowania, zostaną wzięte pod~uwagę\footnote{Decyzja zawarciu tych plików w~obrazie zmian konfiguracji wzorcowej zależy od~administratora.} podczas \hyperlink{itm:stworzenie-obrazu-konfiguracji}{ostatniego etapu} tworzenia obrazu zmian konfiguracji dla~maszyny klienckiej. Pozostałe, niezmienione pliki zostają zignorowane, tzn.~nie znajdą się one w~wynikowym obrazie zmian konfiguracji stacji wzorcowej.
	\item \hypertarget{itm:drugie-skanowanie} Drugie skanowanie tej samej części systemu plików co~podczas pierwszego skanowania. Drugie skanowanie nie odbywa się identycznie jak pierwsze, ponieważ bierze ono pod~uwagę plik stanu systemu powstały po~uruchomieniu pierwszego skanowania. Wynikiem drugiego skanowania jest plik zmian konfiguracji systemu od~czasu pierwszego skanowania. W~szczególności w~utworzonym pliku nie ma informacji o~plikach których skróty się nie zmieniły od~czasu pierwszego skanowania.
	\item \hypertarget{itm:stworzenie-obrazu-konfiguracji} Stworzenie obrazu konfiguracji dla~maszyn klienckich na~podstawie plików powstałych w~wyniku przeprowadzonych dwóch skanowań systemu --- najstarszego (\hyperlink{itm:pierwsze-skanowanie}{referencyjnego}) i~najmłodszego --- oraz na~podstawie decyzji administratora, który ma~możliwość dokonania zmian po~skanowaniu systemu, ale~przed stworzeniem takiego obrazu. Obraz zmian konfiguracji jest tworzony na~podstawie porównywania najstarszego i~najnowszego stanu systemu wzorcowego, a~nie dwóch ostatnich, najnowszych stanów systemu, ponieważ takie podejście upraszcza obsługę sytuacji, w~których część klientów zastosowała się do~najnowszych zmian oferowanych przez system wzorcowy, a~część jest opóźniona np.~o~kilka aktualizacji. Obraz konfiguracji to~archiwum plików z~\href{https://unix.stackexchange.com/questions/43605/how-do-i-copy-a-folder-keeping-owners-and-permissions-intact}{zachowanymi} m.in.~\href{https://wiki.archlinux.org/index.php/File_permissions_and_attributes}{prawami użytkowników, grup i~atrybutami plików}. Archiwum to~może być udostępnione maszynie klienckiej przez stację wzorcową przez sieć lub~alternatywnie administrator może przenieść taki obraz na~maszynę klienta w~dowolny inny sposób. Zastosowanie obrazu konfiguracji na~maszynie klienckiej zostało opisane w~rozdziale~\ref{sec:zastosowanie-obrazu-konfiguracji}.
\end{enumerate}

Powyższe kroki zobrazowano na~rys.~\ref{fig:cykl-skanowan} przedstawiającym maszynę stanów z~wyróżnionymi czterema stanami --- $S$, $Q_1$, $Q_2$ i~$Q_3$. Stan jest określony przez trzy zmienne logiczne --- $K_1$, $K_2$ i~$L$. Zmienna $K_1$~oznacza istnienie pliku stanu systemu wzorcowego, utworzonego podczas pierwszego skanowania~go --- taki plik jest referencyjnym plikiem stanu, tzn.~takim, do~którego są~porównywane wyniki kolejnych skanowań systemu wzorcowego. Zmienna $K_2$~oznacza istnienie pliku stanu systemu wzorcowego, utworzonego podczas kolejnych jego skanowań. Zmianna $L$~oznacza, że~plik stanu utworzony podczas drugiego (i~kolejnych) skanowań jest aktualny, tzn.~że~po~dokonaniu zmian w~konfiguracji wzorcowej, administrator uruchomił skanowanie stacji wzorcowej, w~czasie którego powstał zaktualizowany plik stanu konfiguracji systemu wzorcowego\footnote{Założono, że~$L\in S$ i~$L\in Q_1$, tzn.~że~jeśli nie dokonano jeszcze drugiego skanowania systemu, to~porównawczy plik stanu jest pusty i~aktualny.}. Krok~\hyperlink{itm:pierwsze-skanowanie}{1} odpowiada przejściu między stanami $S\rightarrow Q_1$, krok~\hyperlink{itm:dokonanie-zmian}{2} przejściu między stanami $Q_1\rightarrow Q_2$ oraz~$Q_3\rightarrow Q_2$, a~krok~\hyperlink{itm:drugie-skanowanie}{3} odpowiada przejściu między stanami~$Q_2\rightarrow Q_3$. \hyperlink{itm:stworzenie-obrazu-konfiguracji}{Punkt~4} odpowiada przejściu ze~stanu $Q_3$ do~stanu niezaznaczonego na~\hyperref[fig:cykl-skanowan]{rysunku}, w~którym poza tym, że~zachodzi $\{K_1, K_2, L\}$, to~istnieje też wygenerowany, aktualny obraz zmian konfiguracji. Pozostałe stany niezamieszczone na~\hyperref[fig:cykl-skanowan]{rysunku} --- np.~stan~$\{\neg K_1,K_2,L\}$ --- są traktowane przez aplikację tworzącą obraz zmian konfiguracji jako stany błędne, w~których administrator musi podjąć własne działania, aby~przejść do~jednego z~poprawnych stanów, tj.~$S$, $Q_1$, $Q_2$ lub~$Q_3$. Jeśli stacja wzorcowa była już wcześniej skanowana i~istnieje plik stanu konfiguracji stacji wzorcowej, to~proces tworzenia obrazu zmian konfiguracji obejmuje tylko trzy kroki --- krok~\hyperlink{itm:dokonanie-zmian}{2}, \hyperlink{itm:drugie-skanowanie}{3} i~\hyperlink{itm:stworzenie-obrazu-konfiguracji}{4}.

\begin{figure}
	\centering
	\begin{tikzpicture}[>=latex',shorten >=1pt,auto,node distance=3.75cm]
		\node[initial,state,accepting] (S)      {S};
		\node[state] (q1) [right of=S]  {$Q_1$};
		\node[state] (q2) [right of=q1] {$Q_2$};
		\node[state] (q3) [right of=q2] {$Q_3$};

		\path[->] (S)  edge[font=\footnotesize]           node[align=center] {skanowanie\\systemu}  (q1);
		\path[->] (q1) edge[font=\footnotesize]           node[align=center] {zmiany\\konfiguracji} (q2);
		\path[->] (q2) edge[font=\footnotesize]           node[align=center] {skanowanie\\systemu}  (q3);
		\path[->] (q3) edge[font=\footnotesize,bend left] node[align=center] {zmiany\\konfiguracji} (q2);
	\end{tikzpicture}
	\caption[Cykl skanowań systemu wzorcowego]{Cykl skanowań systemu wzorcowego, gdzie $S=\{\neg K_1, \neg K_2, L\}$, $Q_1=\{K_1, \neg K_2, L\}$, $Q_2=\{K_1, \neg K_2, \neg L\}$, $Q_3=\{K_1, K_2, L\}$, a~$K_1$, $K_2$ i~$L$ oznaczają odpowiednio, że~\begin{inparaenum}[(1)] \protect\item istnieje referencyjny pliku stanu systemu wzorcowego, utworzony podczas pierwszego skanowania~go \protect\item istnieje porównawczy plik stanu systemu wzorcowego, tworzony podczas kolejnych skanowań \protect\item porównawczy plik stanu jest aktualny \end{inparaenum}}
	\label{fig:cykl-skanowan}
\end{figure}

%------------------------------------------------------------------------------

\section{Przesłanie obrazu zmian konfiguracji}
\label{sec:przeslanie-obrazu-konfiguracji}

Obraz zmian konfiguracji utworzony przez stację wzorcową może być przeniesiony na~stację klienta przez połączenie sieciowe zapoczątkowane przez aplikację klienta lub~ręcznie, tzn.~np.~przez przeniesienie takiego obrazu zmian na~system klienta przez~\href{https://en.wikipedia.org/wiki/Network_File_System}{NFS}, na~\hrefemph{http://sjp.pwn.pl/poradnia/haslo/Odmieniamy-pendrive;11159.html}{pendrivie} lub~w~dowolny inny sposób. Wariant przesłania obrazu zmian konfiguracji przez sieć jest elastyczny, ponieważ obraz może być udostępniony przez serwer korzystając z~dowolnego protokołu implementowanego przez klienta. W~implementacji przygotowanej w~ramach tej pracy klient implementuje protokoły \href{https://en.wikipedia.org/wiki/Trivial_File_Transfer_Protocol}{TFTP}~(\emph{Trivial File Transfer Protocol}), \href{https://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol}{SFTP}~(\emph{SSH File Transfer Protocol}), \href{https://en.wikipedia.org/wiki/File_Transfer_Protocol}{FTP} oraz~własny protokół przez połączenie~\glslink{tcpip}{TCP}. Domyślna konfiguracja aplikacji klienckiej korzysta ze~standardowych dla~tych protokołów portów, czyli odpowiednio --- \href{https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml?search=69}{UDP~69}, \href{https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml?search=22}{TCP~22}, \href{https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml?search=21}{TCP~21} oraz~\href{https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml?search=4440}{TCP~4440} dla~połączenia przez własny protokół. Protokoły TFTP i~FTP, w~przeciwieństwie do~SFTP i~własnego protokołu, nie gwarantują bezpieczeństwa, w~szczególności nie gwarantują, że~otrzymane dane pochodzą od~serwera, do~którego klient zgłosił się po~obraz konfiguracji, dlatego powinny być użyte w~ostateczności~(patrz rozdział~\ref{sec:security}). W~przypadku użycia protokołu TFTP, FTP lub~SFTP administrator musi ustawić w~aplikacji klienta ścieżkę adresu do~pliku obrazu.

%------------------------------------------------------------------------------

\section{Zastosowanie obrazu zmian konfiguracji}
\label{sec:zastosowanie-obrazu-konfiguracji}

Maszyna kliencka pobiera obraz zmian konfiguracji korzystając z~TFTP, FTP, SFTP lub~własnego protokołu. Jeśli aplikacja korzysta z~TFTP, FTP lub~SFTP i~posiada certyfikat serwera, to~poza obrazem \href{https://superuser.com/a/426345/139893}{może} pobrać i~zweryfikować podpis cyfrowy pobranego obrazu. W~przypadku SFTP i~własnego protokołu takie ręczne sprawdzenie nie jest konieczne, ponieważ uwierzytelnienie i~integralność są~zapewnione przez~te~protokoły.

Zastosowanie obrazu zmian przez system maszyny klienckiej odbywa się za~pomocą przygotowanej aplikacji rozpakowującej obraz zmian konfiguracji i~kopiującej go~w~odpowiednie miejsca systemu plików. W~przypadku wykrycia konfliktów aplikacja umożliwia administratorowi ich~rozwiązanie lub~wymuszenie nadpisania.

%------------------------------------------------------------------------------

\section{Bezpieczeństwo protokołu}
\label{sec:security}

Uwzględnienie aspektów bezpieczeństwa jest ważne dla~powodzenia każdego projektu protokołu, szczególnie takiego, który umożliwia serwerowi na~zarządzanie konfiguracją dziesiątek, setek lub~tysięcy klientów. Zaniedbanie bezpieczeństwa protokołu lub~jego wadliwa implementacja może umożliwić atakującemu na~przejęcie kontroli nad~wszystkimi klientami, np.~przez przesłanie klientom złośliwych aktualizacji oprogramowania lub~konfiguracji.

Istnieje wiele powszechnych technik ataków protokołów sieciowych. Jednymi z~najpopularniejszych są:\mynobreakpar

\begin{itemize}
	\item \hypertarget{itm:mitm} \protect\hrefemph{https://en.wikipedia.org/wiki/Man-in-the-middle_attack}{Man In The Middle~(MITM)} --- technika ataku polegająca na~tym, że~atakujący nasłuchuje komunikacji między klientem i~serwerem i~modyfikuje przesyłane dane albo~sam tworzy nowe i~,,wstrzykuje'' je~między pakiety klienta i~serwera.
	\item \hrefemph{https://en.wikipedia.org/wiki/Replay_attack}{Replay Attack} --- technika ataku polegająca na~tym, że~poprawne (\href{https://www.ibm.com/support/knowledgecenter/en/SSAW57_8.0.0/com.ibm.websphere.nd.doc/info/ae/ae/rwbs_secconsider6wssec.html}{nawet} podpisane cyfrowo) dane podsłuchane w~czasie wcześniejszych sesji komunikacyjnych między klientem i~serwerem, są~powtarzane po~jakimś czasie w~innym kontekście komunikacyjnym\footnote{Technika ta~może być szczególnie \href{https://en.wikipedia.org/wiki/Rolling_code}{dotkliwa} np.~dla~posiadaczy samochodów z~podatnymi układami \href{https://en.wikipedia.org/wiki/Remote_keyless_system}{zdalnego zamka centralnego} samochodu, posiadaczy bram garażowych sterowanych zdalnie~itp.}.
\end{itemize}

W~celu uniknięcia podatności protokołu na~wymienione i~inne, popularne rodzaje ataków, należy zagwarantować bezpieczeństwo protokołu co~najmniej pod~względem uwierzytelnienia serwera i~integralności komunikacji. Poufność komunikacji nie jest zazwyczaj konieczna, ponieważ konfiguracja klientów zazwyczaj nie jest poufna, a~oprogramowanie przesyłane do~klientów jest powszechnie dostępne w~\href{https://wiki.archlinux.org/index.php/official_repositories}{repozytoriach pakietów}. W~przypadku potrzeby szyfrowania przesyłanego obrazu klient może wybrać połączenie przez protokół SFTP gwarantujący poza uwierzytelnieniem serwera i~integralnością komunikacji również poufność.

Uwierzytelnienie serwera przez klienta jest krytyczne dla~bezpieczeństwa protokołu. Gdyby nie ono, to~atakujący mógłby podawać się za~serwer i~przesłać klientowi dowolną konfigurację i~oprogramowanie. Warto zauważyć, że~nawet gdyby komunikacja była szyfrowana, ale nie uwierzytelniana, to~atakujący mógłby również podjąć próby ataku \emph{replay attack}. W~celu uniknięcia tego problemu wykorzystano certyfikat \href{https://en.wikipedia.org/wiki/X.509}{X.509} dla~serwera udostępniającego konfiguracje klientów~\cite{wiki:x509}.

Wygenerowanie takiego certyfikatu cyfrowego wymaga podpisania go~przez centrum certyfikacji~(\gls{ca})~\cite{wiki:ca}. Ze~względu na~brak potrzeby posiadania w~trakcie implementacji certyfikatu podpisanego przez uznane~\gls{ca}, a~także ze~względu na~względnie duże koszty finansowe i~czasowe z~tym związane, w~czasie implementacji wykorzystano certyfikat podpisany przez siebie~(\hrefemph{https://en.wikipedia.org/wiki/Self-signed_certificate}{self-signed certificate}). Konfiguracja klienta pozwala w~trybie \texttt{debug} zaufać takiemu certyfikatowi. Oczywiście, w~przypadku wdrożenia projektu, należałoby postarać się o~certyfikat podpisany przez uznany~\gls{ca}.

Wygenerowanie i~podpisanie certyfikatu zostało wykonane z~użyciem \gls{openssl}. Listing~\ref{lst:openssl-gencert} przedstawia jak wygenerować klucze publiczny i~prywatny \gls{rsa} o~długości 4096~bitów, a~następnie, jak wykorzystać klucz prywatny do~wygenerowania żądania podpisania certyfikatu (\hrefemph{https://en.wikipedia.org/wiki/Certificate_signing_request}{Certificate Signing Request}) i~na jego podstawie podpisać certyfikat~X.509~\cite{openssl-cookbook,wiki:csr}.\\% Czemu taki mał odstęp bez nowej linii? o.O

\begin{lstlisting}[numbers=none,caption={Wygenerowanie i~podpisanie certyfikatu X.509},label=lst:openssl-gencert]
$ openssl genrsa -aes256 -out rsa_aes256_4096.key 4096
$ openssl req -new -key rsa_aes256_4096.key -out request.csr
$ openssl req -new -config request.cnf -key fd.key -out request.csr
$ openssl x509 -req -days 365 -in request.csr -signkey rsa_aes256_4096.key -out certificate.pem
\end{lstlisting}

\begin{lstlisting}[numbers=none,caption={Plik z~konfiguracją certyfikatu X.509},label=lst:openssl-request-config]
[req]
default_bits       = 4096
default_keyfile    = rsa_aes256_4096.key
prompt             = no
distinguished_name = dn
req_extensions     = ext
input_password     = minipw

[dn]
CN                 = Patryk
OU                 = MiNI
emailAddress       = bezap@student.mini.pw.edu.pl
O                  = PW
L                  = Warsaw
ST                 = Masovian
C                  = PL

[ext]
subjectAltName     = DNS:www.mini.pw.edu.pl,DNS:*.mini.pw.edu.pl
\end{lstlisting}

Listing~\ref{lst:openssl-request-config} przedstawia przykładową zawartość pliku \path{request.cnf}, który służy do~konfiguracji żądania podpisania certyfikatu. Certyfikat jest zaufany jeśli istnieje ważny\footnote{Tzn.~żaden certyfikat w~ciągu nie stracił ważności.} ciąg podpisów cyfrowych, który zaczyna się~od~\gls{ca}, a~kończy na~naszym certyfikacie. Aby sprawdzić czy~certyfikat jest przez nas zaufany, wystarczy wydać komendę:
\begin{lstlisting}[numbers=none,frame=none]
$ openssl verify -verbose certificate.pem
\end{lstlisting}

Aby~\href{http://stackoverflow.com/questions/10782826/digital-signature-for-a-file-using-openssl}{podpisać} skrót~\href{https://en.wikipedia.org/wiki/SHA-2}{SHA256} pliku \path{config.img} za~pomocą certyfikatu \path{certificate.pem} i~zapisać wynik takiej operacji do~pliku~\path{signature} wystarczy wydać komendę\footnote{W~zaimplementowanej aplikacji operacja podpisania obrazu konfiguracji wzorcowej jest wykonywana z~poziomu biblioteki OpenSSL, a~nie z~poziomu linii komend.}:

\begin{lstlisting}[numbers=none,frame=none]
$ openssl dgst -sha256 -sign certificate.pem -out signature config.img
\end{lstlisting}

Obraz konfiguracji podpisany certyfikatem, poza uwierzytelnieniem gwarantuje również integralność pliku, tzn.~gwarantuje, że~nikt go nie zmodyfikował przeprowadzając atak \emph{\hyperlink{itm:mitm}{Man In the Middle}}.

\end{document}
