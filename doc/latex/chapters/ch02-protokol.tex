\documentclass[thesis]{subfiles}

\begin{document}

\chapter{Protokół komunikacji}
\label{ch:protokol}

Celem niniejszej pracy jest ułatwienie pracy administratora komputerowego przez zaprojektowanie i~zaimplementowanie protokołu umożliwiającego propagowanie zmian w~systemie plików, pakietów oraz~elementów konfiguracji do~stacji roboczych pod~kontrolą systemu operacyjnego \glslink{gnulinux}{Linux/GNU} lub~innego systemu \glslink{unix-like-system}{*nix}, a~także elastycznego standardu opisu zmian oraz~narzędzi dla~ich rejestrowania i~dostosowywania. Tak~przedstawiony cel może wydawać się podobny lub~identyczny do~celu jaki postawili przed sobą twórcy istniejących rozwiązań, przedstawionych w~rozdziale~\ref{ch:istniejace-rozwiazania}, jednak pomysł na~jego realizację w~ramach tej pracy zasadniczo różni się od~istniejących implementacji.

%------------------------------------------------------------------------------

\section{Idea działania}

Typowy scenariusz użycia dowolnego z~przedstawionych w~rozdziale~\ref{ch:istniejace-rozwiazania} czterech rozwiązań, polega w~uproszczeniu na~tym, że~administrator komputerowy przygotowuje zestaw plików konfiguracyjnych, będących abstrakcyjnym, tzn.~niezależnym od~systemu klienta, \href{https://martinfowler.com/bliki/DomainSpecificLanguage.html}{wyrażaniem} wymagań administratora w~stosunku do~konfiguracji systemów klienckich. Tak~przygotowane pliki konfiguracyjne są~następnie przetwarzane --- w~zależności od~rozwiązania --- przez aplikację serwera lub~klienta, a~wynik przetworzenia jest docelową konfiguracją klienta, do~której klient się dostosowuje. W~zależności od~rozwiązania, klient odpytuje serwer co~pewien czas o~aktualizację oprogramowania (model \emph{pull}) --- tak się dzieje np.~w~\hyperref[sec:puppet]{Puppet}, \hyperref[sec:chef]{Chef} i~w~zwykłym trybie pracy \hyperref[sec:salt]{Salt} --- lub~serwer wymusza zmiany na~kliencie (model \emph{push}) --- jak np.~w~\hyperref[sec:ansible]{Ansible} i~w~trybie \emph{agentless} w~\hyperref[sec:salt]{Salt}. Klient po~zastosowaniu się do~zmian konfiguracji przesłanych przez serwer, w~zależności od~rozwiązania, może poinformować serwer o~powodzeniu lub~niepowodzeniu przeprowadzonej instalacji przesyłając dodatkowe logi, z~których serwer może przygotować np.~kompleksowe raporty.

Rozwiązanie stworzone w~ramach niniejszej pracy działa w~odmienny sposób. Zaprojektowany zestaw narzędzi zwalnia administratora komputerowego z~konieczności przygotowania plików konfiguracyjnych szczegółowo opisujących konfigurację klientów, jak ma~to~miejsce w~istniejących rozwiązaniach, opisanych w~rozdziale~\ref{ch:istniejace-rozwiazania}. Takie alternatywne podejście ma~praktyczną zaletę polegającą na~tym, że~administrator nie musi poznawać i~używać języka --- nazywanego często określeniem \hrefemph{https://en.wikipedia.org/wiki/Domain-specific_language}{Domain Specific Language} --- którym posługuje się aplikacja do~abstrakcyjnego opisania wzorcowej konfiguracji.

Typowy przykład użycia rozwiązania stworzonego w~ramach niniejszej~pracy polega na~tym, że~administrator przed dokonaniem na~stacji wzorcowej jakichkolwiek zmian, które chce, aby~były śledzone i~obecne na~stacjach klienckich, ustawia listę katalogów i~plików, które chce odzwierciedlić na~stacjach klienckich, a~następnie skanuje po~raz pierwszy system wzorcowy\footnote{Przez \emph{skanowanie} rozumie się przeanalizowanie systemu plików stacji wzorcowej w~poszukiwaniu zmian konfiguracji względem poprzedniego skanowania lub~ustalenie pierwszej konfiguracji referencyjnej w~przypadku pierwszego skanowania. W~dalszej części pracy, określenie \emph{system wzorcowy} będzie skrótowo utożsamiany z~systemem, którego konfiguracja została przeskanowana i~na podstawie której, za~pomocą \hyperref[sec:srv-app]{aplikacji serwera}, powstaje \hyperref[sec:obraz-zmian-konfiguracji]{obraz zmian konfiguracji} dla~klientów.}, tzn.~system który jest wzorcem oprogramowania i~konfiguracji dla~klientów. W~typowym przypadku, pierwsze takie skanowanie zostaje przeprowadzone na~,,czystym'' systemie operacyjnym, tzn.~dopiero co~zainstalowanym i~niezmodyfikowanym. W~wyniku przeprowadzonego skanowania powstaje plik opisujący stan systemu, który jest stanem referencyjnym, tzn.~takim, do~którego będą porównywane wyniki kolejnych skanowań, już~po~dokonaniu zmian w~systemie wzorcowym. Po~przeskanowaniu systemu wzorcowego administrator konfiguruje system wzorcowy, tak, jak chciałby skonfigurować stacje klienckie. Wszystkie zmiany, których dokona na~systemie wzorcowym w~obrębie śledzonych katalogów, zostają wykryte i~odnotowane podczas kolejnego skanowania, którego wynikiem jest kolejny plik opisujący nowy stan systemu --- już~po~dokonaniu zmian w~konfiguracji przez administratora. Administrator korzystając z~przygotowanej w~ramach tej~pracy \hyperref[sec:srv-app]{aplikacji serwera} porównującej takie dwa, niekoniecznie utworzone bezpośrednio po~sobie wyniki skanowań systemu wzorcowego, otrzymuje \hyperref[sec:obraz-zmian-konfiguracji]{obraz zmian konfiguracji wzorcowej}, który może zostać udostępniony przez serwer, przesłany do~klienta i~zastosowany przez niego.% Przed przeniesieniem obrazu zmian konfiguracji na~stację kliencką, klient powinien mieć już zainstalowany działający system operacyjny, który zostanie tylko skonfigurowany za~pomocą otrzymanego obrazu zmian konfiguracji.

Rozdział~\ref{sec:obraz-zmian-konfiguracji} opisuje dokładniej z~czego składa się wygenerowany obraz zmian konfiguracji systemu, a~trzy następne rozdziały \ref{sec:tworzenie-obrazu-konfiguracji}, \ref{sec:przeslanie-obrazu-konfiguracji} i~\ref{sec:zastosowanie-obrazu-konfiguracji} opisują wszystkie trzy etapy użycia zaprojektowanego zestawu narzędzi, tzn.~kolejno --- stworzenie obrazu zmian konfiguracji stacji wzorcowej, przesłanie jej na~maszynę klienta i~zastosowanie przez aplikację kliencką. Opis interfejsu aplikacji realizującej pomysł przedstawiony w~rozdziale~\ref{ch:protokol} został omówiony w~rozdziale~\ref{ch:implementacja}.

%------------------------------------------------------------------------------

\section{Obraz zmian konfiguracji systemu wzorcowego}
\label{sec:obraz-zmian-konfiguracji}

Obraz zmian konfiguracji wzorcowej to~archiwum z~\href{https://unix.stackexchange.com/questions/43605/how-do-i-copy-a-folder-keeping-owners-and-permissions-intact}{zachowanymi} m.in.~\href{https://wiki.archlinux.org/index.php/File_permissions_and_attributes}{prawami użytkowników, grup i~innymi atrybutami} spakowanych plików\footnote{Rodzaj użytego sposobu kompresji obrazu zmian konfiguracji systemu wzorcowego jest konfigurowalny --- domyślnie jest to~archiwum z~rozszerzeniem \path{tar.gz}, tzn.~archiwum spakowane za~pomocą programu \hreftt{https://en.wikipedia.org/wiki/Tar_(computing)}{tar} i~zarchiwizowane za~pomocą programu \hreftt{https://en.wikipedia.org/wiki/Gzip}{gzip}. Zachowanie atrybutów spakowanych plików jest istotne, ponieważ jest to~element konfiguracji systemu wzorcowego.}, stworzone przez \hyperref[sec:srv-app]{aplikację serwera} na~podstawie wyników przeprowadzonych skanowań systemu wzorcowego za~pomocą skanera~\hyperref[sec:aide]{AIDE}~(patrz rozdział~\ref{sec:aide}). W~skład takiego archiwum wchodzą pliki, które służą \hyperref[sec:cli-app]{aplikacji klienckiej} do~dostosowania się do~zmian konfiguracji narzuconych przez stację wzorcową, w~tym~m.in.:\mynobreakpar
\begin{itemize}
	\item drzewo katalogów i~plików\footnote{Domyślnie poza zwykłymi plikami brane są~pod uwagę również \href{https://en.wikipedia.org/wiki/Unix_file_types}{pliki specjalne}, w~tym m.in.~\href{https://en.wikipedia.org/wiki/Network_socket}{gniazda sieciowe}, \href{https://en.wikipedia.org/wiki/Unix_domain_socket}{gniazda UNIX}, \href{https://en.wikipedia.org/wiki/Named_pipe}{potoki nazwane (FIFO)}, \href{https://en.wikipedia.org/wiki/Symbolic_link}{dowiązania symboliczne}, pliki urządzeń \href{https://en.wikipedia.org/wiki/Device_file\#Block_devices}{blokowe} i~\href{https://en.wikipedia.org/wiki/Device_file\#Character_devices}{znakowe}. Zakres rodzajów skanowanych plików jest konfigurowalny.} dodanych do~systemu wzorcowego od~czasu ostatniej aktualizacji klienta --- aplikacja kliencka doda te~pliki i~katalogi do~swojego systemu,
	\item drzewo katalogów i~plików, których zawartość została zmieniona na~systemie wzorcowym od~czasu ostatniej aktualizacji klienta --- aplikacja kliencka nadpisze nimi swoje pliki i~katalogi,
	\item lista ścieżek do~plików i~katalogów usuniętych z~systemu wzorcowego od~czasu ostatniej aktualizacji klienta --- aplikacja kliencka usunie te~pliki i~katalogi ze~swojego systemu,
	\item lista ścieżek plików, katalogów i~ich \href{https://serverfault.com/a/584102/289017}{atrybutów}, w~tym m.in.~uprawnienia, właściciel~(\hreftt{https://en.wikipedia.org/wiki/User_identifier}{UID}), grupa~(\hreftt{https://en.wikipedia.org/wiki/Group_identifier}{GID}), \href{http://leksykot.top.hell.pl/lx3/N/atime_mtime_ctime}{czasy} dostępu \texttt{atime}, modyfikacji \texttt{mtime}, zmiany \texttt{ctime}~itp. --- lista zawiera tylko te~pliki i~katalogi, których atrybuty zostały zmienione od~czasu ostatniej aktualizacji klienta --- aplikacja kliencka zmieni atrybuty tych plików i~katalogów na~swoim systemie, tak, aby~były identyczne z~tymi wymienionymi na~liście,
	\item plik stanu opisujący oczekiwany stan konfiguracji systemu, z~którego klient zadeklarował się aktualizować --- plik ten~jest pomocny dla~aplikacji klienckiej do~wykrycia samowolnych (niezalecanych, ponieważ mogących prowadzić do~konfliktów) zmian konfiguracji klienckiej od~czasu ostatniej aktualizacji klienta.
\end{itemize}

W~przypadku zaistnienia sytuacji konfliktowych, administrator może za~pomocą \hyperref[sec:cli-app]{aplikacji klienckiej} interaktywnie porównać atrybuty oraz~zawartość konfliktowych plików, aby~na~tej~podstawie podjąć decyzję którą wersję pliku zachować lub~alternatywnie może wymusić automatyczne \hyperlink{itm:cli-force}{domyślne zachowanie} aplikacji klienckiej zastosowującej obraz zmian na~systemie klienta. Przykładami sytuacji konfliktowych są~sytuacje w~których od~czasu ostatniej aktualizacji klienta:
\begin{itemize}
	\item na~systemie wzorcowym powstał śledzony plik lub~katalog, który już istnieje na~systemie klienckim i~ich atrybuty lub~zawartości są~różne,
	\item na~systemie wzorcowym i~klienckim powstał śledzony plik lub~katalog o~tej samej ścieżce o~różnych atrybutach lub~zawartości,
	\item atrybuty lub~zawartość śledzonego pliku została zmieniona zarówno na~systemie klienckim, jak i~systemie wzorcowym i~zmiany te~nie są~identyczne.
	\item z~systemu klienckiego został usunięty śledzony plik lub~katalog, a~z~systemu wzorcowego~nie,
	\item na~systemie klienckim zostały zmodyfikowane atrybuty lub~zawartość śledzonego pliku lub~katalogu, a~na~systemie wzorcowym~nie.
\end{itemize}

Pliki stanów powstałe podczas kolejnych skanowań systemu wzorcowego są~wersjonowane, tzn.~każdy taki plik stanu ma~unikalny identyfikator, który jest wykorzystywany przez aplikację \hyperref[sec:cli-app]{kliencką} i~\hyperref[sec:srv-app]{serwera}. Identyfikatory te~są~potrzebne aplikacji serwera do~stworzenia \hyperref[sec:obraz-zmian-konfiguracji]{obrazu zmian konfiguracji systemu wzorcowego}, ponieważ obraz ten~jest tworzony na~podstawie wyników dwóch skanowań systemu wzorcowego identyfikowanych identyfikatorami --- najnowszego oraz tego, który opisuje deklarowany przez klienta aktualny stan konfiguracji systemu klienckiego.

Przywracanie poprzedniego stanu systemu wzorcowego i~klienckiego nie jest \emph{explicite} możliwe ze~względu na~to, że~stacja wzorcowa nie utrzymuje bazy różnic między plikami zmodyfikowanymi w~następujących po~sobie skanowaniach\footnote{Takie różnice plików tekstowych mogłaby tworzyć np.~komenda \hreftt{https://linux.die.net/man/1/diff}{diff}.}, a~same pliki systemu wzorcowego nie są~wersjonowane, a~jedynie ich~skrótowo opisany stan. Przywrócenie stanu systemu klienta może się odbyć przez ,,ręczne'' cofnięcie zmian na~systemie wzorcowym, przeskanowanie nowej konfiguracji wzorcowej, stworzenie nowego obrazu konfiguracji, rozpropagowanie go~do~stacji klienckich i~zastosowanie przez aplikację kliencką --- etapy skanowania, tworzenia nowego obrazu, rozpropagowanie i~zastosowanie go~przez klienta mogą być (w~zależności od~sposobu użycia aplikacji) w~pełni zautomatyzowane.

Jeśli na~przykład na~systemie wzorcowym dokonano już~3~skanowań systemu, w~wyniku których powstały 3~pliki stanu, opisujące stan początkowy $Q_0$~systemu wzorcowego oraz~dokonane na~nim~2~zestawy zmian $Q_1\rightarrow Q_2$, $Q_3\rightarrow Q_4$~(patrz rys.~\ref{fig:ciag-skanowan}) i~klient nigdy do~tej pory nie synchronizował swojej konfiguracji z~systemem wzorcowym, to~może on~zażądać od~serwera wzorcowego aktualizacji ze~stanu~$Q_0$ do~stanu aktualnie najnowszego, czyli w~tym przypadku do~stanu~$Q_5$. Klienci i~stacja wzorcowa na~początku całego procesu skanowań i~zmian konfiguracji powinni być tym~samym stanie~$Q_0$, co~najmniej w~zakresie synchronizowanych plików, aby~uniknąć początkowych konfliktów konfiguracji. W~szczególności systemy klienckie i~system wzorcowy powinny działać na~tej samej lub~zgodnej \href{https://en.wikipedia.org/wiki/List_of_instruction_sets}{architekturze procesora}\footnote{Architektura procesora (np.~\href{https://en.wikipedia.org/wiki/X86-64}{AMD64}, \href{https://en.wikipedia.org/wiki/X86}{x86}, \href{https://en.wikipedia.org/wiki/ARM_architecture}{ARM}) wpływa na~kod binarny programów i~bibliotek, które stacja kliencka domyślnie synchronizuje ze~stacją wzorcową.} oraz~mieć zainstalowaną tę~samą dystrybucję \glslink{gnulinux}{Linux}. Wymagania te~najłatwiej spełnić rozpoczynając używanie przygotowanego oprogramowania na~dowolnych, ale~takich samych, dopiero co~zainstalowanych systemach operacyjnych Linux. Przygotowane oprogramowanie można również uruchomić na~różnych systemach Linux klienta i~systemu wzorcowego, ale~powinny być to~dystrybucje podobne pod~względem sposobu konfiguracji systemu --- przykładem mogą być~niektóre dystrybucje wywodzące się z~systemu \hrefemph{https://en.wikipedia.org/wiki/Debian}{Debian} jak np.~\hrefemph{https://en.wikipedia.org/wiki/Ubuntu_(operating_system)}{Ubuntu}, \hrefemph{https://en.wikipedia.org/wiki/Linux_Mint}{Linux Mint}~itp.

\begin{figure}
	\centering
	\begin{tikzpicture}[>=latex',shorten >=1pt,auto,node distance=2.5cm]
		\node[state,initial] (q0)       {$Q_0$};
		\node[state] (q1) [right of=q0] {$Q_1$};
		\node[state] (q2) [right of=q1] {$Q_2$};
		\node[state] (q3) [right of=q2] {$Q_3$};
		\node[state] (q4) [right of=q3] {$Q_4$};
		\node[state] (q5) [right of=q4] {$Q_5$};

		\path[->] (q0) edge[font=\scriptsize]        node[align=center] {skanowanie\\systemu}  (q1);
		\path[->] (q1) edge[font=\scriptsize,dashed] node[align=center] {zmiany\\konfiguracji} (q2);
		\path[->] (q2) edge[font=\scriptsize]        node[align=center] {skanowanie\\systemu}  (q3);
		\path[->] (q3) edge[font=\scriptsize,dashed] node[align=center] {zmiany\\konfiguracji} (q4);
		\path[->] (q4) edge[font=\scriptsize]        node[align=center] {skanowanie\\systemu}  (q5);
	\end{tikzpicture}
	\caption{Przykładowy ciąg 3~skanowań i~2~zmian konfiguracji systemu wzorcowego --- linią przerywaną zobrazowano zmiany konfiguracji systemu wzorcowego, linią ciągłą skanowania systemu wzorcowego, a~wierzchołkami stan konfiguracji systemu wzorcowego}
	\label{fig:ciag-skanowan}
\end{figure}

 Obraz zmian konfiguracji systemu wzorcowego nie zawiera plików zbędnych z~punktu widzenia bieżącej aktualizacji klienta, tzn.~m.in.~takich plików, których zawartość i~atrybuty nie zmieniły się~od~ostatniej aktualizacji klienta, w~szczególności takich które zostały dodane do~systemu wzorcowego, a~następnie, przed dokonaniem skanowania systemu wzorcowego, w~wyniku którego powstał plik stanu opisujący stan systemu wzorcowego, do~którego klient chce aktualizować swoją konfigurację, zostały usunięte z~systemu wzorcowego.

%------------------------------------------------------------------------------

\section{Tworzenie obrazu zmian konfiguracji}
\label{sec:tworzenie-obrazu-konfiguracji}

Pracę z~aplikacją \hyperref[sec:srv-app]{serwera} i~\hyperref[sec:cli-app]{klienta} należy rozpocząć od~dostosowania zakresu katalogów i~plików śledzonych przez oprogramowanie systemu wzorcowego. W~ramach przygotowanego oprogramowania dostarczono domyślną konfigurację, jednak przed skorzystaniem z~niej należy upewnić się, że~spełnia ona~oczekiwania administratora. Poza~konfiguracją zakresu skanowanego systemu plików istnieje również oddzielna konfiguracja innych parametrów programu \hyperref[sec:cli-app]{klienta} i~\hyperref[sec:srv-app]{serwera}\footnote{Np.~ścieżka do~certyfikatu cyfrowego serwera, którym zostają podpisane \hyperref[sec:obraz-zmian-konfiguracji]{obrazy zmian konfiguracji}, port nasłuchu na~klientów, czas między skanowaniami, ustawienia logowania zdarzeń podczas działania aplikacji~itp.}, którą również warto przejrzeć i~dostosować do~własnych potrzeb.

Po~dokonaniu takiej wstępnej (meta)konfiguracji można stworzyć \hyperref[sec:obraz-zmian-konfiguracji]{obraz zmian konfiguracji wzorcowej}. Proces tworzenia takiego obrazu odbywa się w~trzech krokach:\mynobreakpar
\begin{enumerate}
	\item \hypertarget{itm:pierwsze-skanowanie} Skanowanie tej części systemu plików stacji wzorcowej, którą administrator chce przenieść na~maszyny klienckie. Skanowanie odbywa się za~pomocą skanera~\href{http://aide.sourceforge.net/}{AIDE} (patrz rozdział~\ref{sec:aide}). W~wyniku skanowania powstaje plik stanu, tj.~plik tekstowy z~wybranymi w~konfiguracji własnościami skanowanych plików, takimi jak np.~jego wielkość, ilość zajmowanych bloków pamięci, właściciel i~grupa pliku, liczba dowiązań, czas modyfikacji~itp. Na~podstawie wybranych własności liczone są~dla~wszystkich śledzonych plików wartości funkcji \href{https://en.wikipedia.org/wiki/Hash_function}{skrótu}~(np.~\href{https://en.wikipedia.org/wiki/MD5}{MD5}, \href{https://en.wikipedia.org/wiki/SHA-1}{SHA1}, \href{https://en.wikipedia.org/wiki/Cyclic_redundancy_check}{CRC32}), które definiują referencyjny stan systemu, do~którego będą porównywane wyniki kolejnych skanowań systemu, już~po~dokonaniu zmian konfiguracji na~nim. W~przypadku zmiany którejkolwiek własności pliku, wartość funkcji skrótu zmienia się, co~zostaje odnotowane przez \hyperref[sec:aide]{AIDE} jako zmiana stanu systemu wzorcowego. Ustawienie parametrów skanowania, w~tym m.in.~zakresu skanowanych katalogów i~wybór funkcji skrótu, odbywa się za~pomocą konfiguracji programu~\href{http://aide.sourceforge.net/}{AIDE}, opisanej w~rozdziale~\ref{sec:aide} dotyczącym implementacji projektu.
	\item \hypertarget{itm:dokonanie-zmian} Dokonanie zmian w~konfiguracji maszyny wzorcowej, tak, jakby była maszyną kliencką, której konfigurację administrator chce dostosować do~systemu wzorcowego. Wszystkie śledzone pliki maszyny wzorcowej, które uległy zmianie oraz~wszystkie nowe pliki, które zostały dodane do~śledzonych katalogów od~czasu ostatniego skanowania systemu wzorcowego, zostają dołączone do~\hyperref[sec:obraz-zmian-konfiguracji]{archiwum plików} tworzonego podczas ostatniego --- \hyperlink{itm:stworzenie-obrazu-konfiguracji}{trzeciego} etapu tworzenia obrazu zmian konfiguracji. Pliki, które zostały usunięte z~systemu wzorcowego lub~których atrybuty zostały zmienione od~czasu ostatniej aktualizacji klienta, również zostają dodane do~takiego archiwum w~odpowiednio --- liście plików usuniętych i~liście ścieżek do~plików i~ich atrybutów. Pozostałe, niezmienione w~żaden sposób pliki zostaną zignorowane, tzn.~nie znajdą się one w~wynikowym obrazie zmian konfiguracji stacji wzorcowej.
	\item \hypertarget{itm:stworzenie-obrazu-konfiguracji} Stworzenie dla~maszyn klienckich archiwum plików będącego właściwym \hyperref[sec:obraz-zmian-konfiguracji]{obrazem zmian konfiguracji systemu wzorcowego} (patrz rozdział~\ref{sec:obraz-zmian-konfiguracji}) na~podstawie programowego porównania dwóch plików stanów powstałych w~wyniku przeprowadzonych skanowań systemu wzorcowego --- najnowszego dostępnego na~systemie wzorcowym i~aktualnego pliku stanu klienta. Stworzone archiwum plików może być udostępnione maszynie klienckiej przez stację wzorcową przez sieć lub~alternatywnie administrator może przenieść taki obraz na~maszynę klienta w~dowolny inny sposób (patrz rozdział~\ref{sec:przeslanie-obrazu-konfiguracji}). Zastosowanie obrazu konfiguracji na~maszynie klienckiej zostało opisane w~rozdziale~\ref{sec:zastosowanie-obrazu-konfiguracji}.
\end{enumerate}

Powyższe kroki zobrazowano na~poglądowym rysunku~\ref{fig:cykl-skanowan} przedstawiającym maszynę stanów z~wyróżnionymi pięcioma stanami --- $Q_0$, $Q_1$, $Q_2$, $Q_3$ i~$Q_4$. Każdy stan został określony przez trzy zmienne logiczne --- $k_1$, $k_2$ i~$k_3$. Zmienna $k_1$~oznacza istnienie pliku stanu systemu wzorcowego, utworzonego podczas pierwszego skanowania~go. Zmienna $k_2$~oznacza istnienie dowolnego pliku stanu systemu wzorcowego, utworzonego podczas dowolnego kolejnego jego skanowania. Zmienna $k_3$~oznacza, że~najnowszy plik stanu jest aktualny, tzn.~że~po~dokonaniu zmian w~konfiguracji wzorcowej, zostało uruchomione skanowanie stacji wzorcowej, w~czasie którego powstał nowy, zaktualizowany plik stanu konfiguracji systemu wzorcowego\footnote{Założono, że~$k_3\in Q_0$, tzn.~że~jeśli nie dokonano jeszcze drugiego skanowania systemu, to~najnowszy plik stanu jest pusty i~aktualny.}.

\begin{figure}
	\centering
	\begin{tikzpicture}[>=latex',shorten >=1pt,auto,node distance=3.1cm]
		\node[initial,state] (q0)       {$Q_0$};
		\node[state] (q1) [right of=q0] {$Q_1$};
		\node[state] (q2) [right of=q1] {$Q_2$};
		\node[state] (q3) [right of=q2] {$Q_3$};
		\node[state] (q4) [right of=q3] {$Q_4$};

		\path[->] (q0) edge[font=\scriptsize]            node[align=center] {skanowanie\\systemu}  (q1);
		\path[->] (q1) edge[font=\scriptsize,dashed]     node[align=center] {zmiany\\konfiguracji} (q2);
		\path[->] (q2) edge[font=\scriptsize]            node[align=center] {skanowanie\\systemu}  (q3);
		\path[->] (q3) edge[font=\scriptsize,dashed]     node[align=center] {zmiany\\konfiguracji} (q4);
		\path[->] (q4) edge[font=\scriptsize,bend left]  node[align=center] {skanowanie\\systemu}  (q3);
		\path[->] (q3) edge[font=\scriptsize,loop below] node[align=center] {tworzenie\\obrazu zmian\\konfiguracji} (q3);
		\path[->] (q4) edge[font=\scriptsize,loop below] node[align=center] {tworzenie\\obrazu zmian\\konfiguracji} (q4);
	\end{tikzpicture}
	\caption[Cykl skanowań systemu wzorcowego]{Kompletny cykl skanowań systemu wzorcowego, gdzie $Q_0=\{\neg k_1, \neg k_2, k_3\}$, $Q_1=\{k_1, \neg k_2, k_3\}$, $Q_2=\{k_1, \neg k_2, \neg k_3\}$, $Q_3=\{k_1, k_2, k_3\}$, $Q_4=\{k_1, k_2, \neg k_3\}$ a~$k_1$, $k_2$ i~$k_3$ oznaczają odpowiednio, że~\begin{inparaenum}[(1)] \protect\item istnieje pliku stanu systemu wzorcowego, utworzony podczas pierwszego skanowania~go \protect\item istnieje porównawczy plik stanu systemu wzorcowego, tworzony podczas kolejnych skanowań \protect\item najnowszy plik stanu jest aktualny \end{inparaenum}}
	\label{fig:cykl-skanowan}
\end{figure}

Krok~\hyperlink{itm:pierwsze-skanowanie}{1} odpowiada przejściu między stanami $Q_0\rightarrow Q_1$, $Q_2\rightarrow Q_3$ lub~$Q_4\rightarrow Q_3$, krok~\hyperlink{itm:dokonanie-zmian}{2} przejściu między stanami $Q_1\rightarrow Q_2$ lub~$Q_3\rightarrow Q_4$, a~krok~\hyperlink{itm:dokonanie-zmian}{3} przejściu to~pętla~$Q_4\rightarrow Q_4$. Pozostałe stany pominięte na~rysunku~\ref{fig:cykl-skanowan} --- tj.~stany~$\{\neg k_1,k_2,k_3\}$, $\{\neg k_1,k_2,\neg k_3\}$ i~$\{\neg k_1,\neg k_2,\neg k_3\}$ --- są~traktowane przez \hyperref[sec:srv-app]{aplikację serwera} tworzącą obraz zmian konfiguracji jako stany błędne, w~których administrator musi podjąć własne działania, aby~przejść do~jednego z~poprawnych stanów, tj.~$Q_0$, $Q_1$, $Q_2$, $Q_3$ lub~$Q_4$. Warto zauważyć, że~wygenerowanie \hyperref[sec:obraz-zmian-konfiguracji]{obrazu konfiguracji wzorcowej} jest możliwe tylko jeśli najnowszy plik stan jest aktualny, tzn.~że~po~dokonaniu wszystkich zmian w~konfiguracji systemu wzorcowego zostało uruchomione jego skanowanie. \hyperref[sec:srv-app]{Aplikacja serwera} przed wygenerowaniem zmian obrazu konfiguracji wymusza sprawdzenie czy~plik stanu jest aktualny. Jeśli nie jest, to~domyślnie zostaje uruchomione skanowanie systemu wzorcowego.

%------------------------------------------------------------------------------

\section{Przesłanie obrazu zmian konfiguracji}
\label{sec:przeslanie-obrazu-konfiguracji}

\hyperref[sec:obraz-zmian-konfiguracji]{Obraz zmian konfiguracji} utworzony przez stację wzorcową może być przeniesiony na~stację klienta przez połączenie sieciowe zapoczątkowane przez aplikację klienta (model \emph{pull}) lub~ręcznie, tzn.~np.~przez przeniesienie takiego obrazu zmian na~system klienta przez~\href{https://en.wikipedia.org/wiki/Network_File_System}{NFS}, na~\hrefemph{http://sjp.pwn.pl/poradnia/haslo/Odmieniamy-pendrive;11159.html}{pendrivie} lub~w~dowolny inny sposób.

Wariant przesłania obrazu zmian konfiguracji przez sieć jest elastyczny, ponieważ obraz może być udostępniony przez serwer korzystając z~dowolnego protokołu implementowanego przez klienta. W~implementacji przygotowanej w~ramach tej pracy klient implementuje protokoły \href{https://en.wikipedia.org/wiki/Trivial_File_Transfer_Protocol}{TFTP}~(\emph{Trivial File Transfer Protocol}), \href{https://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol}{SFTP}~(\emph{SSH File Transfer Protocol}), \href{https://en.wikipedia.org/wiki/File_Transfer_Protocol}{FTP} oraz~własny protokół przez połączenie~\glslink{tcpip}{TCP}. Domyślna konfiguracja aplikacji klienckiej korzysta ze~standardowych dla~tych protokołów portów, czyli odpowiednio --- \href{https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml?search=69}{UDP~69}, \href{https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml?search=22}{TCP~22}, \href{https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml?search=21}{TCP~21} oraz~\href{https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml?search=4440}{TCP~4440} dla~połączenia przez własny protokół. Protokoły TFTP i~FTP, w~przeciwieństwie do~SFTP i~własnego protokołu, nie gwarantują bezpieczeństwa, w~szczególności nie gwarantują, że~otrzymane dane pochodzą od~serwera, do~którego klient zgłosił się po~obraz konfiguracji, dlatego powinny być użyte w~ostateczności~(patrz rozdział~\ref{sec:security}). W~przypadku użycia protokołu TFTP, FTP lub~SFTP administrator musi ustawić w~aplikacji klienta ścieżkę adresu do~pliku obrazu i~inne dane konieczne do~nawiązania połączenia.

%------------------------------------------------------------------------------

\section{Zastosowanie obrazu zmian konfiguracji}
\label{sec:zastosowanie-obrazu-konfiguracji}

Maszyna kliencka pobiera obraz zmian konfiguracji korzystając z~TFTP, FTP, SFTP lub~własnego protokołu. Jeśli aplikacja korzysta z~TFTP, FTP lub~SFTP i~posiada certyfikat serwera, to~poza obrazem \href{https://superuser.com/a/426345/139893}{może} pobrać i~zweryfikować podpis cyfrowy pobranego obrazu. W~przypadku SFTP i~własnego protokołu takie ręczne sprawdzenie nie jest konieczne, ponieważ uwierzytelnienie i~integralność są~zapewnione przez~te~protokoły.

Zastosowanie obrazu zmian przez system maszyny klienckiej odbywa się za~pomocą przygotowanej \hyperref[sec:cli-app]{aplikacji klienckiej}, która rozpakowuje obraz zmian konfiguracji i~kopiuje go~w~odpowiednie miejsca systemu plików. W~przypadku wykrycia konfliktów aplikacja umożliwia administratorowi ich~rozwiązanie lub~wymuszenie nadpisania. Instrukcja użycia aplikacji klienckiej została opisana w~rozdziale~\ref{sec:cli-app}.

%------------------------------------------------------------------------------

\section{Bezpieczeństwo protokołu}
\label{sec:security}

Wydaje się, że~uwzględnienie aspektów bezpieczeństwa jest ważne dla~powodzenia każdego projektu protokołu sieciowego, szczególnie takiego, który umożliwia serwerowi na~zarządzanie konfiguracją dziesiątek, setek lub~tysięcy klientów. Zaniedbanie bezpieczeństwa protokołu lub~jego wadliwa implementacja może umożliwić atakującemu na~przejęcie kontroli nad~wszystkimi klientami, np.~przez przesłanie klientom złośliwych aktualizacji oprogramowania lub~konfiguracji.

Istnieje wiele powszechnych technik ataków protokołów sieciowych. Jednymi z~najpopularniejszych~są:\mynobreakpar

\begin{itemize}
	\item \hypertarget{itm:mitm} \protect\hrefemph{https://en.wikipedia.org/wiki/Man-in-the-middle_attack}{Man In The Middle~(MITM)} --- technika ataku polegająca na~tym, że~atakujący nasłuchuje komunikacji między klientem i~serwerem i~modyfikuje przesyłane dane albo~sam tworzy nowe i~,,wstrzykuje'' je~między pakiety klienta i~serwera.
	\item \hrefemph{https://en.wikipedia.org/wiki/Replay_attack}{Replay Attack} --- technika ataku polegająca na~tym, że~poprawne (\href{https://www.ibm.com/support/knowledgecenter/en/SSAW57_8.0.0/com.ibm.websphere.nd.doc/info/ae/ae/rwbs_secconsider6wssec.html}{nawet} podpisane cyfrowo) dane podsłuchane w~czasie wcześniejszych sesji komunikacyjnych między klientem i~serwerem, są~powtarzane po~jakimś czasie w~innym kontekście komunikacyjnym\footnote{Technika ta~może być szczególnie \href{https://en.wikipedia.org/wiki/Rolling_code}{dotkliwa} np.~dla~posiadaczy samochodów z~podatnymi układami \href{https://en.wikipedia.org/wiki/Remote_keyless_system}{zdalnego zamka centralnego} samochodu, posiadaczy bram garażowych sterowanych zdalnie~itp.}.
\end{itemize}

W~celu uniknięcia podatności protokołu na~wymienione i~inne, popularne rodzaje ataków, należy zagwarantować bezpieczeństwo protokołu co~najmniej pod~względem uwierzytelnienia serwera i~integralności komunikacji. Poufność komunikacji nie jest zazwyczaj konieczna, ponieważ konfiguracja klientów zazwyczaj nie jest poufna, a~oprogramowanie przesyłane do~klientów jest powszechnie dostępne w~\href{https://wiki.archlinux.org/index.php/official_repositories}{repozytoriach pakietów} różnych dystrybucji \glslink{gnulinux}{Linux}. W~przypadku potrzeby szyfrowania przesyłanego obrazu klient może wybrać połączenie przez protokół SFTP gwarantujący, poza uwierzytelnieniem serwera i~integralnością komunikacji, również poufność.

Uwierzytelnienie serwera przez klienta jest krytyczne dla~bezpieczeństwa protokołu, ponieważ gdyby nie ono, to~atakujący mógłby podszywać się za~serwer i~przesłać klientowi dowolną konfigurację i~oprogramowanie. Warto zauważyć, że~nawet gdyby komunikacja była szyfrowana, ale nie uwierzytelniana, to~atakujący mógłby również podjąć próby ataku \emph{replay attack}. W~celu uniknięcia tego problemu wykorzystano certyfikat \href{https://en.wikipedia.org/wiki/X.509}{X.509} dla~systemu wzorcowego będącego jednocześnie serwerem udostępniającym swoją konfigurację systemom klienckim~\cite{wiki:x509}.

Wygenerowanie takiego certyfikatu cyfrowego wymaga podpisania go~przez centrum certyfikacji~(\gls{ca})~\cite{wiki:ca}. Ze~względu na~brak potrzeby posiadania w~trakcie implementacji certyfikatu podpisanego przez uznane~\gls{ca}, a~także ze~względu na~względnie duże koszty finansowe i~czasowe z~tym związane, w~czasie implementacji wykorzystano certyfikat podpisany przez siebie~(\hrefemph{https://en.wikipedia.org/wiki/Self-signed_certificate}{self-signed certificate}). Konfiguracja klienta pozwala w~trybie \texttt{debug} zaufać takiemu certyfikatowi. Oczywiście, w~przypadku wdrożenia projektu, należałoby postarać się o~certyfikat podpisany przez uznany~\gls{ca}.

Wygenerowanie i~podpisanie certyfikatu zostało wykonane z~użyciem \gls{openssl}. Listing~\ref{lst:openssl-gencert} przedstawia jak wygenerować klucze publiczny i~prywatny \gls{rsa} o~długości 4096~bitów, a~następnie, jak wykorzystać klucz prywatny do~wygenerowania żądania podpisania certyfikatu (\hrefemph{https://en.wikipedia.org/wiki/Certificate_signing_request}{Certificate Signing Request}) i~na jego podstawie podpisać certyfikat~X.509~\cite{openssl-cookbook,wiki:csr}.

\begin{lstlisting}[numbers=none,caption={Wygenerowanie i~podpisanie certyfikatu X.509},label=lst:openssl-gencert]
$ openssl genrsa -aes256 -out rsa_aes256_4096.key 4096
$ openssl req -new -key rsa_aes256_4096.key -out request.csr
$ openssl req -new -config request.cnf -key fd.key -out request.csr
$ openssl x509 -req -days 365 -in request.csr -signkey rsa_aes256_4096.key -out certificate.pem
\end{lstlisting}

\begin{lstlisting}[numbers=none,caption={Plik z~konfiguracją certyfikatu X.509},label=lst:openssl-request-config]
[req]
default_bits       = 4096
default_keyfile    = rsa_aes256_4096.key
prompt             = no
distinguished_name = dn
req_extensions     = ext
input_password     = minipw

[dn]
CN                 = Patryk
OU                 = MiNI
emailAddress       = bezap@student.mini.pw.edu.pl
O                  = PW
L                  = Warsaw
ST                 = Masovian
C                  = PL

[ext]
subjectAltName     = DNS:www.mini.pw.edu.pl,DNS:*.mini.pw.edu.pl
\end{lstlisting}

Listing~\ref{lst:openssl-request-config} przedstawia przykładową zawartość pliku \path{request.cnf}, który służy do~konfiguracji żądania podpisania certyfikatu. Certyfikat jest zaufany jeśli istnieje ważny\footnote{Tzn.~żaden certyfikat w~ciągu nie stracił ważności.} ciąg podpisów cyfrowych, który zaczyna się~od~\gls{ca}, a~kończy na~naszym certyfikacie. Aby sprawdzić czy~certyfikat jest zaufany przez nasz system, wystarczy wydać komendę:
\begin{lstlisting}[numbers=none,frame=none]
$ openssl verify -verbose certificate.pem
\end{lstlisting}

Aby~\href{http://stackoverflow.com/questions/10782826/digital-signature-for-a-file-using-openssl}{podpisać} skrót~\href{https://en.wikipedia.org/wiki/SHA-2}{SHA256} pliku \path{config.img} za~pomocą certyfikatu \path{certificate.pem} i~zapisać wynik takiej operacji do~pliku~\path{signature} wystarczy wydać komendę\footnote{W~zaimplementowanej aplikacji operacja podpisania obrazu konfiguracji wzorcowej jest wykonywana z~poziomu biblioteki OpenSSL, a~nie z~poziomu linii komend.}:

\begin{lstlisting}[numbers=none,frame=none]
$ openssl dgst -sha256 -sign certificate.pem -out signature config.img
\end{lstlisting}

Obraz konfiguracji podpisany certyfikatem, poza uwierzytelnieniem gwarantuje również integralność pliku, tzn.~gwarantuje, że~nikt go nie zmodyfikował przeprowadzając atak \emph{\hyperlink{itm:mitm}{Man In the Middle}}.

\end{document}
