\documentclass[thesis]{subfiles}

\begin{document}

\chapter{Protokół komunikacji}
\label{ch:protokol}

Celem niniejszej pracy jest ułatwienie pracy administratora komputerowego przez zaprojektowanie i~zaimplementowanie protokołu umożliwiającego propagowanie zmian w~systemie plików, pakietów oraz~elementów konfiguracji do~stacji roboczych pod~kontrolą systemu operacyjnego \glslink{gnulinux}{Linux/GNU} lub~innego systemu \glslink{unix-like-system}{*nix}, a~także elastycznego standardu opisu zmian oraz~narzędzi dla~ich rejestrowania i~dostosowywania. Tak postawiony cel wydaje się być zbliżony do~celu jaki postawili przed sobą twórcy istniejących rozwiązań, przedstawionych w~rozdziale~\ref{ch:istniejace-rozwiazania}, jednak pomysł na~jego realizację w~ramach tej pracy jest zasadniczo inny od~istniejących implementacji.

%------------------------------------------------------------------------------

\section{Idea pomysłu}

Typowy scenariusz użycia dowolnego z~przedstawionych czterech, istniejących rozwiązań, polega w~uproszczeniu na~tym, że~administrator komputerowy przygotowuje zestaw plików konfiguracyjnych, będących abstrakcyjnym, tzn.~niezależnym od~konkretnego systemu, \href{https://martinfowler.com/bliki/DomainSpecificLanguage.html}{wyrażaniem} wymagań administratora w~stosunku do~konfiguracji systemów klienckich. Tak przygotowane pliki konfiguracyjne są~następnie przetwarzane --- w~zależności od~rozwiązania --- przez aplikację serwera lub~klienta, a~wynik przetworzenia jest docelową konfiguracją klienta, do~której klient się dostosowuje. W~zależności od~rozwiązania, klient odpytuje serwer co~pewien czas o~aktualizację oprogramowania --- tak się dzieje np.~w~\hyperref[sec:puppet]{Puppet}, \hyperref[sec:chef]{Chef} i~w~zwykłym trybie pracy \hyperref[sec:salt]{Salt} --- lub~serwer wymusza zmiany na~kliencie --- jak np.~w~\hyperref[sec:ansible]{Ansible} i~w~trybie \emph{agentless} w~\hyperref[sec:salt]{Salt}. Po~zastosowaniu się do~zmian konfiguracji przesłanych od~serwera, klient, w~zależności od~rozwiązania, może poinformować serwer o~powodzeniu lub~niepowodzeniu przeprowadzonej instalacji i~może przesłać dodatkowe logi, z~których serwer może przygotować np.~kompleksowe raporty.

Rozwiązanie stworzone w~ramach niniejszej pracy działa w~odmienny sposób. Zaprojektowany zestaw narzędzi zwalnia administratora komputerowego z~przygotowania plików konfiguracyjnych opisujących szczegółowo konfigurację klientów, jak ma~to~miejsce w~opisanych w~\hyperref[ch:istniejace-rozwiazania]{poprzednim rozdziale} istniejących rozwiązaniach. Typowy przykład użycia zaproponowanego rozwiązania polega na~tym, że~administrator, przed dokonaniem jakichkolwiek zmian, które chce, aby~były odzwierciedlone na~stacjach klienckich, skanuje system, który jest wzorcem oprogramowania i~konfiguracji dla~klientów. W~typowym przypadku takie skanowanie zostaje przeprowadzonym na~,,czystym'', tzn.~dopiero co~zainstalowanym, niezmodyfikowanym systemie operacyjnym. W~wyniku przeprowadzonego skanowania systemu powstaje plik tekstowy opisujący stan systemu. Po~wykonaniu skanowania, administrator konfiguruje przeskanowany uprzednio system, tak, jak chciałby skonfigurować stacje klienckie. Wszystkie zmiany, które wykona na~systemie wzorcowym\footnote{W~dalszej części pracy, określenie \emph{system wzorcowy} będzie skrótowo utożsamiany z~systemem, którego konfiguracja została przeskanowana i~na podstawie której powstał obraz zmian dla~klientów.}, zostają wykryte podczas drugiego skanowania, którego wynikiem jest drugi plik opisujący stan systemu po~dokonaniu zmian w~konfiguracji przez administratora. Na~podstawie tych dwóch plików stanów, administrator, za~pomocą przygotowanych w~ramach tej pracy aplikacji, otrzymuje obraz zmian, który zostanie przesłany do~klientów i~zastosowany przez nich. Zastosowanie obrazu zmian przez klienta odbywa się również za~pośrednictwem aplikacji stworzonej w~ramach tej~pracy.

%------------------------------------------------------------------------------

\section{Bezpieczeństwo protokołu}
\label{sec:security}

Uwzględnienie aspektów bezpieczeństwa jest krytyczne dla~powodzenia każdego poważnego projektu protokołu, szczególnie takiego, który umożliwia serwerowi na~zarządzanie konfiguracją dziesiątek, setek lub~tysięcy klientów. Zaniedbanie bezpieczeństwa protokołu lub~jego wadliwa implementacja, może umożliwić atakującemu na~przejęcie kontroli nad~wszystkimi klientami, np.~przez przesłanie klientom złośliwych aktualizacji oprogramowania lub~konfiguracji.

Istnieje wiele powszechnych technik ataków protokołów sieciowych. Najpopularniejsze z~nich to:\mynobreakpar

\begin{itemize}
	\item \hypertarget{itm:mitm} \protect\hrefemph{https://en.wikipedia.org/wiki/Man-in-the-middle_attack}{Man In The Middle~(MITM)} --- technika ataku polegająca na~tym, że~atakujący nasłuchuje komunikacji między klientem i~serwerem i~modyfikuje przesyłane dane albo~sam tworzy nowe i~,,wstrzykuje'' je~między pakiety klienta i~serwera.
	\item \hrefemph{https://en.wikipedia.org/wiki/Replay_attack}{Replay Attack} --- technika ataku polegająca na~tym, że~poprawne (\href{https://www.ibm.com/support/knowledgecenter/en/SSAW57_8.0.0/com.ibm.websphere.nd.doc/info/ae/ae/rwbs_secconsider6wssec.html}{nawet} podpisane cyfrowo) dane podsłuchane w~czasie wcześniejszych sesji komunikacyjnych między klientem i~serwerem, są~powtarzane po~jakimś czasie w~innym kontekście komunikacyjnym\footnote{Technika ta~może być szczególnie \href{https://en.wikipedia.org/wiki/Rolling_code}{dotkliwa} np.~dla~posiadaczy samochodów z~podatnymi układami \href{https://en.wikipedia.org/wiki/Remote_keyless_system}{zdalnego zamka centalnego} samochodu, posiadaczy bram garażowych sterowanych zdalnie~itp.}.
\end{itemize}

W~celu uniknięcia podatności protokołu na~wymienione i~inne, popularne rodzaje ataków, należy zagwarantować bezpieczeństwo protokołu co~najmniej pod~względem uwierzytelnienia serwera i~integralności komunikacji. Poufność komunikacji nie jest konieczna, ponieważ konfiguracja klientów nie jest poufna, a~pakiety oprogramowania przesyłane do~klientów są~powszechnie dostępne w~\href{https://wiki.archlinux.org/index.php/official_repositories}{repozytoriach pakietów}. Ponadto poufność w~trybie multicastowym byłoby bardzo trudno zagwarantować, ponieważ \href{https://www.google.pl/search?q=multicast+encryption}{nie istnieje} żaden powszechnie uznany standard gwarantujący \href{http://www.cisco.com/c/dam/en/us/products/collateral/ios-nx-os-software/ip-multicast/prod_presentation0900aecd80473105.pdf}{poufność} w~komunikacji multicastowej. Poufność oparta na~współdzieleniu klucza kryptograficznego przez wszystkich lub~część klientów, który byłby użyty do~szyfrowania symetrycznego (np.~popularnym szyfrem~\gls{aes}) byłby kryptograficznie słabym rozwiązaniem ze~względu na~powielenie tajnego klucza. W~przypadku potrzeby szyfrowania elementów konfiguracji pakietów, można ją~zapewnić w~ramach unicastowego połączenia klienta z~serwerem buforującym pakiety oprogramowania.

W~kolejnych podrozdziałach zostały opisane metody, które zostały wykorzystane do~zapewnienia poszczególnych elementów, składających się na~bezpieczeństwo protokołu. Wszystkie opisane dalej algorytmy i~metody kryptograficzne zostały wykorzystane przez niniejszy projekt przez wykorzystanie biblioteki \hreftt{http://www.pyopenssl.org/}{pyOpenSSL}, będącej interfejsem otwartoźródłowej biblioteki kryptograficznej~\texttt{\gls{openssl}} dla~języka Python, implementującej m.in.~protokół kryptograficzny~\gls{ssl/tls}.

%---------------------------------------

\subsection{Uwierzytelnienie}

Uwierzytelnienie serwera przez klienta jest krytyczne dla~bezpieczeństwa protokołu. Gdyby nie ono, to~atakujący mógłby podawać się za~serwer i~przesłać klientowi dowolną konfigurację i~oprogramowanie, co~jest szczególnie łatwe w~wykorzystanym protokole multicastowym niekorzystającym z~opcji filtrowania \hyperlink{igmpv3-filtering}{dostępnego} w~IGMPv3. Warto zauważyć, że~nawet gdyby komunikacja była szyfrowana, ale nie uwierzytelniana, to~atakujący mógłby również podjąć próby ataku \emph{replay attack}. W~celu uniknięcia tego problemu wykorzystano certyfikat \href{https://en.wikipedia.org/wiki/X.509}{X.509} dla~serwera rozgłaszającego konfiguracje klientów~\cite{wiki:x509}.

Wygenerowanie takiego certyfikatu cyfrowego wymaga podpisania go~przez centrum certyfikacji~(\gls{ca})~\cite{wiki:ca}. Ze~względu na~brak potrzeby posiadania w~trakcie implementacji certyfikatu podpisanego przez uznane~\gls{ca}, a~także ze~względu na~względnie duże koszty finansowe i~czasowe z~tym związane, w~czasie implementacji wykorzystano certyfikat podpisany przez siebie~(\hrefemph{https://en.wikipedia.org/wiki/Self-signed_certificate}{self-signed certificate}). Konfiguracja klienta pozwala w~trybie \texttt{debug} zaufać takiemu certyfikatowi. Oczywiście, w~przypadku wdrożenia projektu, należałoby postarać się o~certyfikat podpisany przez uznany~\gls{ca}.

Wygenerowanie i~podpisanie certyfikatu zostało wykonane z~użyciem \gls{openssl}. Listing~\ref{lst:openssl-gencert} przedstawia jak wygenerować klucze publiczny i~prywatny \gls{rsa} o~długości 4096~bitów, a~następnie, jak wykorzystać klucz prywatny do~wygenerowania żądania podpisania certyfikatu (\hrefemph{https://en.wikipedia.org/wiki/Certificate_signing_request}{Certificate Signing Request}) i~na jego podstawie podpisać certyfikat~X.509~\cite{openssl-cookbook,wiki:csr}.\\% Czemu taki mał odstęp bez nowej linii? o.O

\begin{lstlisting}[numbers=none,caption={Wygenerowanie i~podpisanie certyfikatu X.509},label=lst:openssl-gencert]
$ openssl genrsa -aes256 -out rsa_aes256_4096.key 4096
$ openssl req -new -key rsa_aes256_4096.key -out request.csr
$ openssl req -new -config request.cnf -key fd.key -out request.csr
$ openssl x509 -req -days 365 -in request.csr -signkey rsa_aes256_4096.key -out certificate.pem
\end{lstlisting}

\begin{lstlisting}[numbers=none,caption={Plik z~konfiguracją certyfikatu X.509},label=lst:openssl-request-config]
[req]
default_bits       = 4096
default_keyfile    = rsa_aes256_4096.key
prompt             = no
distinguished_name = dn
req_extensions     = ext
input_password     = minipw

[dn]
CN                 = Patryk
OU                 = MiNI
emailAddress       = bezap@student.mini.pw.edu.pl
O                  = PW
L                  = Warsaw
ST                 = Masovian
C                  = PL

[ext]
subjectAltName     = DNS:www.mini.pw.edu.pl,DNS:*.mini.pw.edu.pl
\end{lstlisting}

Listing~\ref{lst:openssl-request-config} przedstawia przykładową zawartość pliku \path{request.cnf}, który służy do~konfiguracji żądania podpisania certyfikatu. Certyfikat jest zaufany jeśli istnieje ważny\footnote{Tzn.~żaden certyfikat w~ciągu nie stracił ważności.} ciąg podpisów cyfrowych, który zaczyna się~od~\gls{ca}, a~kończy na~naszym certyfikacie. Aby sprawdzić czy~certyfikat jest przez nas zaufany, wystarczy wydać komendę:
\begin{lstlisting}[numbers=none]
$ openssl verify -verbose certificate.pem
\end{lstlisting}

%------------------------------------------------------------------------------

\subsection{Integralność}

Integralność komunikacji jest konieczna, aby zapobiec atakom typu \emph{\hyperlink{itm:mitm}{Man In the Middle}}, polegającym na~modyfikacji komunikacji między serwerem i~klientem, \href{https://en.wikipedia.org/wiki/Digital_signature\#Integrity}{niezależnie} od~tego czy jest ona~szyfrowana czy nie. Do~zapewnienia integralności danych używana jest \href{https://www.ibm.com/support/knowledgecenter/SSFKSJ_7.0.1/com.ibm.mq.csqzas.doc/sy11300_.htm}{funkcja skrótu} zastosowana na~wysłanych danych, a~następnie podpisana certyfikatem cyfrowym. W~zależności od~konfiguracji do~tego celu może użyta np.~\emph{SHA384}, \emph{SHA256} czy~\emph{SHA1}.

\end{document}
