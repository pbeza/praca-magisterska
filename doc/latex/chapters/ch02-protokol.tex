\documentclass[thesis]{subfiles}

\begin{document}

\chapter{Protokół komunikacji}

Celem niniejszej pracy jest ułatwienie pracy administratora komputerowego przez zaprojektowanie i~zaimplementowanie protokołu umożliwiającego propagowanie zmian w~systemie plików, pakietów oraz~elementów konfiguracji do~stacji roboczych pod~kontrolą systemu operacyjnego \glslink{gnulinux}{Linux/GNU} lub~innego systemu \glslink{unix-like-system}{*nix}, a~także elastycznego standardu opisu zmian oraz~narzędzi dla~ich rejestrowania i~dostosowywania. Cel ten jest zbliżony do~celu jaki postawili przed sobą twórcy istniejących rozwiązań przedstawionych w~rozdziale~\ref{ch:istniejace-rozwiazania}, jednak realizacja projektu przeprowadzonego w~ramach niniejszej pracy jest zasadniczo inna od~realizacji zaimplementowanej w~istniejących rozwiązaniach. Typowy scenariusz użycia dowolnego z~przedstawionych istniejących rozwiązań polega na~tym, że~administrator komputerowy przygotowuje zestaw plików konfiguracyjnych, będących abstrakcyjnym, tzn.~niezależnym od~konkretnego systemu, wyrażaniem wymagań administratora w~stosunku do~konfiguracji systemów klienckich. Tak przygotowane pliki konfiguracyjne są~następnie przetwarzane przez aplikację serwera, a~wynik przetworzenia jest przesyłany do~klienta. Klient następnie tłumaczy\footnote{Wyjątkiem jest \hyperref[sec:ansible]{Ansible}, który nie ma wydzielonej aplikacji klienckiej. Proces tłumaczenia konfiguracji na~komendy specyficzne dla~danego systemu odbywa się po~stronie serwera.} otrzymaną abstrakcyjnie wyrażoną konfigurację na~konkretną konfigurację swojego systemu.

Rozwiązanie projektowane w~ramach niniejszej pracy nie korzysta z~abstrakcyjn

Tak~przedstawiony cel jest zbliżony do~tego, w~wymaga w~szczególności zaprojektowania sposobu działania narzędzi wchodzących w~skład aplikacji administratora komputerowego, która umożliwia przygotowanie obrazu systemu plików dla~maszyny klienckiej oraz sposobu działania aplikacji klienckiej, która zastosuje taki obraz. Zestaw narzędzi stworzony w~ramach niniejszej pracy, mimo podobnego celu do~tego, Wszystkie istniejące rozwiązania przedstawione w  ich oczekiwanego stanu konfiguracji., a~następnie umożliwia klientom zastosowanie się do~tej konfiguracji, aby~osiągnęły stan oczekiwany przez serwer. Takie deklaratywne podejście do~problemu dystrybucji oprogramowania, które opisuje~\emph{co}, a~nie~\emph{jak}, klienci mają zmienić w~swojej konfiguracji, aby~dostosować się do~wymagań postawionych przez administratora sieci komputerowej, jest nazywane określeniem \hrefemph{https://en.wikipedia.org/wiki/Infrastructure_as_Code}{Infrastructure as~Code~(IaC)}.
Wszystkie istniejące rozwiązania przedstawione w~rozdziale~ działają w~podobny sposób --- administrator sieci komputerowej przygotowuje


Tak~przedstawiony cel może nasunąć na~myśl pomysł wykorzystania do~implementacji protokołu dystrybucji oprogramowania bezpołączeniowego protokołu opartego na~\hrefemph{https://en.wikipedia.org/wiki/IP_multicast}{multicastowym} rozsyłaniu konfiguracji klientów przez serwer. Należy jednak pamiętać, że~warstwą transportową dla~metod multicastowych jest protokół~\href{https://en.wikipedia.org/wiki/User_Datagram_Protocol}{UDP}, który z~zasady działania jest zawodny, tzn.~nie gwarantuje, że~pakiety nie zostaną zduplikowane i~że~każdy wysłany pakiet dotrze do~celu, a~nawet jeśli dotrze, to~niekoniecznie w~takiej kolejności w~jakiej był wysłany~\cite{rfc1112}. Ponadto protokół~UDP nie uwzględnia m.in.~kontroli przepływu, tzn.~w~szczególności pakiety mogą przychodzić do~odbiorcy szybciej niż~ten może je~przetworzyć.

\begin{figure}
	\centering
	\includegraphics[width=0.8\textwidth]{img/unicast-vs-multicast}
	\caption{Zobrazowanie porównania unicastu i~multicastu\\(na~podst.~\href{http://zeromq.wdfiles.com/local--files/whitepapers\%3Adesign-v05/pgm2.png}{rys.} opublikowanego na~stronie internetowej~\href{http://zeromq.org/}{ØMQ} na~warunkach licencji \glslink{copyleft}{copyleft} \href{https://creativecommons.org/licenses/by-sa/3.0/}{CC~BY-SA~3.0})}
	\label{fig:unicast-vs-multicast}
\end{figure}

Naturalną alternatywą dla~protokołu~UDP jest~TCP, jednak TCP, w~porównaniu do~UDP, jest złożonym protokołem połączeniowym wartswy transportowej, w~ramach którego przesyła się~wiele dodatkowych metadanych gwarantujących niezawodność połączenia, której nie zapewnia~UDP. Rozsyłanie przez serwer tej samej konfiguracji dużej liczbie klientów korzystając z~TCP wiązałoby się~z~nawiązywaniem połączenia z~każdym z~nich z~osobna, co~wydaje się być zbędne i~w~konsekwencji nieoptymalne~(por.~rys.~\ref{fig:unicast-vs-multicast}).

Kompromisem mógłby być taki \hyperlink{server-role}{podział} zadań serwera w~protokole dystrybucji zadań, aby do~części z~nich wykorzystać protokół oparty na~TCP, a~do~pozostałej części protokół oparty na~UDP. Innym pomysłem mogłoby być wykorzystanie alternatywnego dla~TCP i~UDP protokołu warstwy transportowej. Jednym z~przykładów takiego protokołu jest~\href{https://en.wikipedia.org/wiki/QUIC}{QUIC}~(\emph{Quick UDP Internet Connections}) opracowany przez firmę Google i~stosowany domyślnie w~przeglądarce internetowej \hrefemph{https://www.google.pl/chrome/}{Chrome} do~nawiązywania połączeń ze~stronami internetowymi obsługiwanymi przez serwery Google. Celem projektowym QUIC było zminimalizowanie opóźnień w~protokole~TCP, upodabniając go~do UDP, jednocześnie zachowując zalety TCP i~dodając bezpieczeństwo połączenia oparte na~protokole~\gls{ssl/tls}~\cite{quic-wire-layout-spec,quic-crypto,quic-roskind}. W~czasie pisania tej~pracy QUIC nie jest jeszcze ustandaryzowany przez~\gls{ietf}, chociaż w~czerwcu~2016~roku powstał zespół, który pracuje nad~jego standaryzacją~\cite{quic-draft,quic-workinggroup}.

Innym przykładem alternatywnego protokołu warstwy transportowej jest~\href{https://en.wikipedia.org/wiki/Pragmatic_General_Multicast}{PGM}~(\emph{Pragmatic General Multicast}), który został zaprojektowany przez firmę \hrefemph{http://www.cisco.com/}{Cisco} z~myślą o~aplikacjach z~względnie prostymi wymaganiami dotyczącymi niezawodności, korzystających z~potencjału multicastingu~\cite{pgm-rfc}. Założenia projektowe~PGM zostały przedstawione w~\href{https://tools.ietf.org/html/rfc3208}{RFC3208} i~są~bardzo bliskie potrzebom projektowanego protokołu, dlatego warstwą transportową projektowanego rozwiązania jest~PGM zaimplementowany w~ramach projektu \hrefemph{https://code.google.com/archive/p/openpgm/}{OpenPGM} i~wykorzystany w~bibliotece~\href{http://zeromq.org/}{ØMQ}\footnote{Znanej też pod~nazwą~\hrefemph{http://zeromq.org/}{ZeroMQ}.}. Implementacja ta~\href{http://api.zeromq.org/2-1:zmq-pgm}{umożliwia} działanie~PGM w~dwóch trybach: PGM oraz~ePGM~(\emph{Encapsulated PGM}) --- pierwszy z~trybów implementuje wariant, w~którym datagramy PGM~są umieszczane bezpośrednio na~nagłówku~IP (tak jak w~oryginalnym zamyśle~PGM opisanym w~RFC3208), a~drugi polega na~enkapsulacji datagramu~PGM w~datagramie~UDP, co~może być szczególnie użyteczne w~sieciach z~restrykcyjnymi \emph{firewallami}. % Przy tej okazji warto wspomnieć, że~w~IPv6 wycofano \emph{broadcast} na~rzecz multicastingu.

Niniejszy rozdział ma~na~celu opis architektury i~aspektów bezpieczeństwa zaprojektowanego protokołu dystrybucji oprogramowania.

%Motywacją dlaOpracowany protokół komunikacji opiera się na~protokole~TCP. Bezpieczeństwo protokołu zapewnia wykorzystanie biblioteki OpenSSL, która implementuje protokół~SSL/TLS. Oba te~elementy, tzn.~opracowany protokół aplikacji oraz~wykorzystana biblioteka OpenSSL, działają w~warstwie aplikacji modelu~\gls{tcpip}.

%------------------------------------------------------------------------------

\section{Protokół PGM}
\label{sec:pgm}

Problem braku standaryzacji protokołów niezawodnego multicastingu został dostrzeżony przez organizację~\gls{ietf}, która jeszcze~w~latach~90. powołała zespoły \hrefemph{https://irtf.org/concluded/rmrg}{IRTF~Reliable Multicast Research Group} oraz~\hrefemph{https://ietf.org/wg/concluded/rmt}{Reliable Multicast Transport Working Group}, mające na~celu rozwiązywać problemy w~proponowanych protokołach niezawodnego multicastingu~\cite{reliable-multicast-journal,reliable-multicast-transport}. Efektem prac tych zespołów są~dziesiątki dokumentów~\gls{rfc}, m.in.~\href{https://tools.ietf.org/html/rfc2357.html}{RFC2357} i~\href{https://tools.ietf.org/html/rfc2887}{RFC2887}, które określają wymagania jakie muszą spełniać protokoły niezawodnego multicastingu, jednak żaden z~opracowanych dokumentów~\gls{rfc} nie został przyjęty jako standard~\cite{rfc2887,rfc2357}. Prace nad~niezwodnym multicastem prowadziły i~prowadzą również firmy, np.~Cisco --- autor~PGM.

Protokół \href{https://tools.ietf.org/html/rfc3208}{PGM}~(\emph{Pragmatic General Multicast}, a~pierwotnie \emph{Pretty Good Multicasting}) to~protokół do~rozgłaszania pakietów, korzystający z~multicastingu, dzięki czemu wystarczy, że~w~czasie danej sesji rozgłoszeniowej, serwer wyśle tylko raz to, co~ma do~zakomunikowania swoim klientom~\cite{pgm-rfc}~(patrz~rys.~\ref{fig:unicast-vs-multicast}). Powielenie wiadomości do~wszystkich klientów, którzy zgłosili chęć otrzymywania multicastu odbywa się na~poziomie działania routera, do~którego klient jest podłączony bezpośrednio lub~pośrednio, tzn.~np.~za~pomocą przełączników sieciowych~(\emph{switchy}). Dołączenie i~opuszczenie grupy multicastowej przez klienta odbywa się w~sieciach IPv4 dzięki~protokołowi warstwy sieciowej \href{https://en.wikipedia.org/wiki/Internet_Group_Management_Protocol}{IGMP}~(\emph{Internet Group Management Protocol}), a~w~sieciach IPv6 dzięki protokołowi~\href{https://en.wikipedia.org/wiki/Multicast_Listener_Discovery}{MLD}~(\emph{Multicast Listener Discovery}), wbudowanemu w~protokół \href{https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol_version_6}{ICMPv6}~(\emph{Internet Control Message Protocol version~6}). Protokół IGMP~istnieje w~trzech wersjach: IGMPv1, IGMPv2, IGMPv3 --- opisanych odpowiednio w~dokumentach:~\href{https://tools.ietf.org/html/rfc1112}{RFC1112}, \href{https://tools.ietf.org/html/rfc2236}{RFC2236} i~\href{https://tools.ietf.org/html/rfc3376}{RFC3376} (zaktualizowany przez~\href{https://tools.ietf.org/html/rfc4604}{RFC4604}). Protokół MLD~został opisany~w~\href{https://tools.ietf.org/html/rfc3810}{RFC3810} i~został zaktualizowany w~\href{https://tools.ietf.org/html/rfc4604}{RFC4604}.

Protokół~PGM różni się od~zwykłego multicastu opartego na~protokole~UDP m.in.~tym, że~pakiety zostają oznaczone sekwencyjnie liczbami całkowitymi, dzięki czemu klienci są~w~stanie stwierdzić czy~jakieś pakiety zostały ,,zgubione'' i~wymagają retransmisji. Jeśli klient wykryje, że~nie otrzymał wszystkich pakietów, ma~możliwość przez pewien, z~góry zdefiniowany czas\footnote{Formalnie okno czasowe (\emph{Transmit Window}), w~ramach którego klient może poprosić o~retransmisję pakietów, może być zdefiniowane za~pomocą czasu, liczby bajtów lub~liczby pakietów.}, wysłać prośbę o~retransmisję zadanych pakietów. W~przeciwieństwie do~protokołu UDP, PGM~gwarantuje, że~klient albo odbierze wszystkie pakiety i~ich ewentualne retransmisje, albo wykryje nieodwracalną utratę pakietów.

W~PGM każde źródło multicastu ma~przydzielony unikalny identyfikator TSI~(\emph{Transport Session Identifier}) będący wynikiem konkatenacji identyfikatora~GSI\footnote{\href{https://tools.ietf.org/html/rfc3208\#page-33}{RFC3208~zaleca}, aby~za~GSI przyjąć wartość funkcji haszującej~\href{https://en.wikipedia.org/wiki/MD5}{MD5} dla~48~najmłodszych (najmniej znaczących) bitów \href{https://tools.ietf.org/html/rfc2535\#section-4}{sygnatury~DNS} serwera.}~(\emph{Global Source~ID}) oraz~portu używanego przez serwer. Podczas normalnego działania protokołu PGM, serwer wysyła multicastem dane do~klientów w~pakietach \texttt{ODATA}\footnote{Nazwa pakietu \texttt{ODATA} i~inne nazwy pakietów PGM przywołane w~tym rozdziale pochodzą z~\href{https://tools.ietf.org/html/rfc3208}{RFC3208}, definiującego protokół~PGM.} (\emph{Original Data}), a~klienci, jeśli wykryją brakujące pakiety, wysyłają unicastem do~ostatniego routera na~drodze od~serwera do~klienta pakiet \texttt{NAK}~(\emph{Negative Acknowledgment}) tak długo, jak długo nie otrzymają w~odpowiedzi pakietu \texttt{NCF}~(\emph{NAK Confirmation}). Serwer numeruje kolejnymi liczbami całkowitymi (cyklicznie) z~zakresu~$[0,~2^{32}-1]$ każdy kolejny pakiet \texttt{ODATA} z~danymi przekazanymi przez warstwę aplikacji. Router który otrzyma pakiet \texttt{NAK} przekazuje go do~routera poziom wyżej w~hierarchii sieciowej lub, jeśli router jest podłączony bezpośrednio do~serwera, przekazuje \texttt{NAK} serwerowi. Na~każdym poziomie przekazywania \texttt{NAK} w~górę drzewa, którego korzeniem jest serwer, zostaje rozesłany multicastem pakiet \texttt{NCF} tylko na~tym interfejsie, na~którym przyszedł pakiet~\texttt{NAK}. Pakiety \texttt{NAK} pokonują dokładnie tą~samą drogę co~dane \texttt{ODATA}, tylko od~końca, co~jest ważne dla~przesyłanych pakietów naprawczych \texttt{RDATA}~(\emph{Repair Data}), ponieważ routery otrzymując~\texttt{NAK} zapamiętują m.in.~to, że~otrzymały taki pakiet i~numer interfejsu na~którym go~otrzymały, ustanawiając stan naprawczy~(\emph{Repair State}). Jeśli pakiet naprawczy \texttt{RDATA} zostałby wysłany do~routera, który nie ma ustawionego stanu naprawczego, to~zostałby zignorowany. Pomiędzy pakietami \texttt{ODATA} są~co~jakiś czas przesyłane pakiety SPM~(\emph{Source Path Messages}), dzięki którym pakiety \texttt{NAK} wracają dokładnie tą~ścieżką od~klienta do~serwera, którą zostałby wysłany pakiet \texttt{ODATA}. W~szczególności, dzięki~SPM klient wie który router obsługujący~PGM jest ostatni na~drodze od~źródła do~niego samego i~do~tego właśnie routera kieruje unicastem pakiety~\texttt{NAK}. Klient nie może prosić swerwer o~retransmisję żadnego pakietu dopóki nie odbierze co~najmniej jednego pakietu~SPM. ,,Zgubione'' pakiety są~retransmitowane w~odpowiedzi na~pakiety \texttt{NAK} pakietami \texttt{RDATA} przez serwer lub~tzw.~DLR~(\emph{Designated Local Repairer}), którym może być któryś z~routerów obsługujących~protokół PGM.

Rysunek~\ref{fig:NAKflow} przedstawia diagram reprezentujący maszynę stanu dla~algorytmu wysyłania przez klienta pakietu~\texttt{NAK}. Odbiór pakietu \texttt{RDATA} lub~\texttt{ODATA} w~dowolnym stanie powoduje natychmiastowe przejście do~stanu terminalnego (niezaznaczonego na~rys.~\ref{fig:NAKflow}), zakończonego sukcesem. Stan \texttt{BACK\_OFF-STATE} trwa przez pewien, losowany z~pewnego przedziału, czas \texttt{NAK\_RB\_IVL} i~służy zmniejszeniu obciążenia sieci przez wykrycie ewentualnych odpowiedzi~\texttt{NCF}\footnote{Wysłanych w~reakcji na~pakiety~\texttt{NAK} innych klientów.} dotyczących pakietów, które klient chce otrzymać. Stan \texttt{WAIT\_NCF\_STATE} reprezentuje czas \texttt{NAK\_RPT\_IVL} przez który klient oczekuje na~odpowiedź~\texttt{NCF} --- jeśli jej nie otrzymana, to~wysyłany jest kolejny pakiet~\texttt{NAK}. Stan \texttt{WAIT\_DATA\_STATE} reprezentuje czas przez który klient czeka na~dane~\texttt{RDATA} --- jeśli ich nie otrzyma, to~cały proces zaczyna się od~nowa.

\begin{figure}
	\centering
	\includegraphics[width=0.62\textwidth]{img/PGF_protocol_NAK_flow_diagram}
	\caption{Diagram stanów dla~procesu generowania pakietów~\texttt{NAK} w~protokole~PGM~(źródło:~\href{https://tools.ietf.org/html/rfc3208\#page-25}{RFC3208})~\cite{pgm-rfc}}
	\label{fig:NAKflow}
\end{figure}

Schemat pamięci pakietów \texttt{ODATA} i~\texttt{RDATA} został przedstawiony na~rysunku~\ref{fig:odata-packet}. Pierwsze 32~bajty to~pola wspólne dla~wszystkich typów pakietów w~protokole~PGM, czyli nagłówek pakietu. W~skład nagłówka wchodzą:\mynobreakpar

\begin{itemize}
	\item \texttt{Source~Port} (2~bajty) --- Port źródłowy serwera~(tak jak w~nagłówku~UDP).
	\item \texttt{Destination~Port} (2~bajty) --- Port docelowy klienta~(tak jak w~nagłówku~UDP).
	\item \texttt{Type} (1~bajt) --- Flaga określająca czy jest to~pakiet \texttt{ODATA}~(\texttt{0x04}) czy~\texttt{RDATA}~(\texttt{0x05}).
	\item \texttt{Options} (1~bajt) --- Pole, którego każdy z~bitów oznacza co~innego --- ustawiony najbardziej znaczący bit (zerowy bit) tej flagi oznacza, że~do pakietu dołączono co~najmniej jedno czterobajtowe rozszerzenie \hyperlink{itm:optext}{\texttt{Option Extensions}}. Pierwszy bit\footnote{Licząc od~zera.} oznacza, że~\hyperlink{itm:optext}{opcje} pakietu są~istotne dla routerów i~muszą być przez nie interpretowane. Siódmy (czyli najmniej znaczący bit) i~szósty bit odpowiadają za~obsługę \href{https://en.wikipedia.org/wiki/Reed\%E2\%80\%93Solomon\_error\_correction}{algorytmu Reeda--Salomona} do~korekcji błędów.
	\item \texttt{Checksum} (2~bajty) --- Suma kontrolna obowiązkowa tylko dla~pakietów \texttt{ODATA} i~\texttt{RDATA}.
	\item \texttt{Global Source~ID} (6~bajtów) --- Identyfikator serwera. \href{https://tools.ietf.org/html/rfc3208\#page-33}{RFC3208~zaleca}, aby~za~GSI przyjąć wartość funkcji haszującej~\href{https://en.wikipedia.org/wiki/MD5}{MD5} dla~48~najmłodszych (najmniej znaczących) bitów \href{https://tools.ietf.org/html/rfc2535\#section-4}{sygnatury~DNS} serwera.
	\item \texttt{TSDU~Length} (4~bajty) --- Długość \hyperlink{itm:datasec}{sekcji danych} wyrażona w~bajtach\footnote{Formalnie długość ta~jest wyrażona w~\emph{oktetach}, a~nie bajtach, ponieważ istnieją systemy, których bajt nie ma 8~bitów. W~ramach tej pracy \emph{bajt} i~\emph{oktet} zostały utożsamione.}.
	\item \texttt{Data Packet Sequence Number} (4~bajty) --- Identyfikator przypisany przez serwer.
	\item \texttt{Trailing Edge Sequence Number} (4~bajty) --- Identyfikator najstarszego pakietu w~oknie czasowym.
	\item \hypertarget{itm:optext}{\texttt{Option Extensions}} (wielokrotność 4~bajtów) --- Dodatkowe opcje protokołu~PGM, np.~obsługa korekcji błędów Reeda--Salomona (\emph{Forward Error Correction}), mechanizmy zapobieganiu przeciążeniu sieci~(\emph{Congestion Control})~itp.
	\item \hypertarget{itm:datasec}{\texttt{Data}} --- Dane z~warstwy aplikacji serwera.
\end{itemize}

\newcommand\packetheader{%
	\begin{leftwordgroup}{Nagłówek\\pakietów\\protokołu\\PGM}%
		\bitbox{16}{Source Port}%
		\bitbox{16}{Destination Port}\\
		\bitbox{8}{Type}%
		\bitbox{8}{Options}%
		\bitbox{16}{Checksum}\\
		\wordbox{1}{Global Source~ID}\\
		\bitbox{16}{Global Source~ID}%
		\bitbox{16}{TSDU~Length}
	\end{leftwordgroup}\\
}

\begin{figure}
	\centering
	\hspace*{-6em}
	\begin{bytefield}{32}
		\bitheader{0,7,8,15,16,23,24,31}\\
		\packetheader
		\wordbox{1}{Data Packet Sequence Number}\\
		\wordbox{1}{Trailing Edge Sequence Number}\\
		\wordbox{1}{Option Extensions when present ...}\\
		\wordbox[lrt]{1}{Data ...}\\
		\skippedwords\\
		\wordbox[lrb]{2}{\vdots}
	\end{bytefield}
	\caption{Schemat pamięci pakietów~\texttt{ODATA} i~\texttt{RDATA} w~protokole~PGM}
	\label{fig:odata-packet}
\end{figure}

PGM~specyfikuje mechanizmy minimalizacji przekazywanych duplikatów \texttt{NAK}~w~górę drzewa oraz~procedurę, dzięki której pakiety naprawcze \texttt{RDATA} nie są~przekazywane do~tych części sieci, z~których nie były wysyłane pakiety~\texttt{NAK}. PGM~może bez utraty funkcjonalności (ale~z~częściową stratą wydajności) działać w~sieciach, w~których część lub~żaden router nie implementuje tego protokołu. W~przypadku korzystania z~protokołu~IP jako warstwy sieciowej, ze~względu na~konieczność warunkowego przetwarzania pakietów~\texttt{SPM}, \texttt{NCF} i~\texttt{RDATA}, muszą one mieć ustawioną flagę \hrefemph{https://tools.ietf.org/html/rfc2113}{IP~Router Alert}, która wymusza na~routerach ich specjalne potraktowanie.

Warto zauważyć, że~w~tak zaprojektowanym protokole, w~przeciwieństwie np.~do~protokołu~TCP, nie ma pakietów~\texttt{ACK}, które potwierdzałyby odbiór pakietów \texttt{ODATA} przez klientów. Dzięki temu zyskujemy niezawodność multicastingu, jednocześnie nie tracąc jego zalet --- szybkości i~skalowalności.

%Multicast jest stosunkowo rzadko używany wśród aplikacji, częściej jest używany w~protokołach routingu i~niskopoziomowych protokołach do~odkrywania topologii sieci.

%------------------------------------------------------------------------------

\section{Architektura protokołu}

Zaprojektowany protokół działa w~modelu klient--serwer. Serwer spełnia rolę nadzorcy nad~oprogramowaniem i~konfiguracją klientów. Specyfikacja konfiguracji klientów zarządzanych przez serwer jest przechowywana w~plikach tekstowych zapisanych na~serwerze w~formacie \hreftt{https://en.wikipedia.org/wiki/YAML}{YAML}\footnote{Wybór tego formatu plików konfiguracyjnych jest podyktowany dużą czytelnością konfiguracji zapisanej w~tym formacie.}, opisujących oczekiwaną konfigurację klientów w~sposób deklaratywny. Serwer nie utrzymuje żadnego rejestru ani~bazy danych faktycznego stanu oprogramowania zainstalowanego na~maszynach klientów --- taka baza jest zbędna, a~jej ewentualna obecność wymagałaby bardzo dużo miejsca na~dysku serwera, kłopotliwej synchronizacji i~przechowywania stanu spełniania \href{https://en.wikipedia.org/wiki/Dependency_hell}{zależności} między pakietami klienta\footnote{Żadne istniejące rozwiązanie opisane w~rozdziale~\ref{ch:istniejace-rozwiazania} nie przechowuje takiej bazy.}. Serwer jedynie przechowuje czytelne dla~człowieka i~komputera pliki konfiguracyjne, niezależne od~dystrybucji \glslink{gnulinux}{Linux} klientów, opisujące oczekiwany stan konfiguracji klientów, które przesyła do~klientów, aby~te~dostosowały się do~tak opisanej konfiguracji.

W~uproszczeniu działanie protokołu sprowadza się do~okresowego\footnote{Okres propagacji konfiguracji jest konfigurowalny za~pomocą pliku konfiguracyjnego serwera.} rozgłaszania konfiguracji klientów multicastem za~pomocą protokołu~\hyperref[sec:pgm]{PGM}, zapewniającym komunikację niezawodną, uporządkowaną i~pozbawioną duplikatów pakietów. Niezawodność PGM~należy rozumieć w~ten sposób, że~PGM gwarantuje, że~odbiorca multicastu odbierze wszystkie rozgłoszone pakiety lub~wykryje ich nieodwracalną utratę w~danej sesji rozgłoszeniowej, co~wiąże się z~zasadą działania protokołu~PGM, który utrzymuje okno czasowe, w~którym znajdują się~pakiety, które nadawca musi być w~stanie retransmitować jeśli okaże się, że~któryś z~odbiorców wyśle pakiet~\texttt{NAK}. Tak~rozesłana konfiguracja jest zapisana w~formacie, który jest niezależny od~żadnej konkretnej dystrybucji \glslink{gnulinux}{Linux} --- zawiera ona~m.in. informację o~tym jakie pakiety oprogramowania powinny być zainstalowane i~odinstalowane z~systemu klienta, w~tym, w~szczególności zawiera informację o~nazwie i~wersji pakietu oprogramowania, repozytorium z~jakiego ma~być pobrany, konfiguracji, która ma~nadpisać domyślną i~wiele innych, opcjonalnych parametrów. Przez \emph{pakiet oprogramowania} należy rozumieć oficjalne, dostarczone przez opiekunów danej dystrybucji \glslink{gnulinux}{Linux}, skompresowane pliki instalacyjne programów, zarządzane przez menadżer pakietów dystrybucji. W~kontekście implementacji dostarczonej w~ramach niniejszej pracy są~to pakiety oprogramowania formatu~\hreftt{https://en.wikipedia.org/wiki/Deb_(file_format)}{deb} i~\hreftt{https://en.wikipedia.org/wiki/Tar_(computing)}{tar.xz} oraz~odpowiadające im~menadżery pakietów \hreftt{https://www.debian.org/doc/manuals/apt-guide/ch2.html}{APT}~(\hrefemph{https://wiki.debian.org/Apt}{Advanced Package Tool})\footnote{W~dystrybucji \emph{Debian} są~dostępne m.in.~menadżery pakietów \hreftt{https://en.wikipedia.org/wiki/Advanced_Packaging_Tool}{APT}, \hreftt{https://en.wikipedia.org/wiki/Aptitude_(software)}{aptitude} i~\hreftt{https://en.wikipedia.org/wiki/Synaptic_(software)}{Synaptic}, które korzystają z~właściwego, niskopoziomowego menadżera pakietów \hreftt{https://en.wikipedia.org/wiki/Dpkg}{dpkg}. Pakiety~\texttt{.deb} są~też używane w~innych dystrybucjach bazujących na~\emph{Debianie}, np.~\hrefemph{https://en.wikipedia.org/wiki/Ubuntu_(operating_system)}{Ubuntu}, \hrefemph{https://en.wikipedia.org/wiki/Linux_Mint}{Linux~Mint}, \hrefemph{https://en.wikipedia.org/wiki/Knoppix}{Knoppix} i~wielu innych.} i~\hreftt{https://www.archlinux.org/pacman/pacman.8.html}{pacman} pochodzące odpowiednio z~dystrybucji \hrefemph{https://en.wikipedia.org/wiki/Debian}{Linux~Debian} i~\hrefemph{https://en.wikipedia.org/wiki/Arch_Linux}{Linux~Arch}.

\begin{figure}[b]
	\centering
	\begin{bytefield}{32}
		\bitheader{0,7,8,15,16,23,24,31}\hypertarget{max-resp-time}{}\hypertarget{igmpv2-type}{}\\
		\bitbox{8}{Type}%
		\bitbox{8}{Max Resp Time}%
		\bitbox{16}{Checksum}\hypertarget{group-address}{}\\
		\wordbox{1}{Group Address}
	\end{bytefield}
	\caption{Schemat pamięci wszystkich rodzajów pakietów w~protokole~\href{https://tools.ietf.org/html/rfc2236\#page-2}{IGMPv2}}
	\label{fig:igmpv2}
\end{figure}

Każdy klient jest przyporządkowany do~pewnej niepustej grupy komputerów, które otrzymują identyczną konfigurację w~czasie jej~multicastowego rozgłoszenia przez serwer. Zanim jednak klient odbierze konfigurację, musi zadeklarować do~której grupy (lub do~których grup) chce należeć i~poinformować o~tym router. W~tym celu klient korzysta z~protokołu IGMP i~dołącza do~wybranej grupy przez wysłanie pakietu \hrefemph{https://tools.ietf.org/html/rfc3376\#page-13}{Membership Report Message}~(dla~którego \hyperlink{igmpv2-type}{\texttt{Type~=~0x16}}), który zobrazowano na~schematach pamięci~\ref{fig:igmpv2} i~\ref{fig:igmpv3} odpowiednio dla~IGMPv2 i~IGMPv3. W~IGMPv2 klient wypełnia pole \hyperlink{group-address}{\texttt{Group Address}} adresem~IP z~puli adresów multicastowych, który odpowiada wybranej grupie komputerów, której oprogramowanie chce pozyskać. Adres ten jest ustawiany przez administratora sieci w~konfiguracji serwera i~klienta. Pole~\hyperlink{max-resp-time}{\texttt{Max~Resp~Time}}\footnote{Pole to~ma~znaczenie w~pakietach \emph{Membership Query}~(\hyperlink{igmpv2-type}{\texttt{Type~=~0x11}}) wysyłanych przez serwer. Określa ono czas przez jaki klient może wysyłać pakiety \emph{Membership Report Message}~(\hyperlink{igmpv2-type}{\texttt{Type~=~0x16}}).} dla~omawianego typu pakietu jest wyzerowane.

\hypertarget{igmpv3-filtering} Pakiet IGMPv3 jest bardziej rozbudowany od~swoich poprzedników~(por.~rys.~\ref{fig:igmpv3}) i~umożliwia dodatkowe filtrowanie otrzymywanych pakietów --- klient może określić nie tylko adresy multicastowe, w~ramach których chce otrzymywać pakiety, ale~może też zawęzić źródła pochodzenia multicastu do~określonej listy numerów~IP. Pola \hyperlink{group-rec}{\texttt{Group Record}} są~polami złożonymi~(patrz~rys.~\ref{fig:igmpv3-group-record}) --- zawierają m.in.~\hyperlink{group-record-multicast-addr}{adres multicastowy} i~\hyperlink{group-record-ip-list}{listę adresów~IP} będących filtrem pochodzenia multicastu. Większość systemów operacyjnych oraz~routerów --- nawet tych domowych --- implementuje protokół~IGMPv3. Przełączniki sieciowe~(\emph{switche}) często implementują \hrefemph{https://en.wikipedia.org/wiki/IGMP_snooping}{IGMP~snooping} (zdefiniowany w~\href{https://tools.ietf.org/html/rfc4541}{RFC4541}), dzięki któremu, nasłuchując komunikacji~IGMP między klientami i~routerami wiedzą jak nie przekazywać multicastu do~tych podsieci, których klienci nie zapisywali się do~żadnej grupy multicastowej. Ważną konsekwencją zastosowania protokołu multicastowego jest to,~że serwer nie ma~możliwości poznania listy swoich klientów --- wynika to~wprost z~natury protokołów multicastowcyh, w~których klienci mogą się pojawiać i~znikać w~dowolnym momencie, nie informując o~tym serwera, będącego źródłem multicastu. Nieznajomość tożsamości klientów przez serwer w~protokole dystrybucji oprogramowania jest kompromisem między wydajnością, a~dodatkową funkcjonalnością, jaką byłaby znajomość listy klientów przez serwer.

\begin{figure}
	\centering
	\begin{bytefield}{32}
		\bitheader{0,7,8,15,16,23,24,31}\\
		\bitbox{8}{Type}%
		\bitbox{8}{Reserved}%
		\bitbox{16}{Checksum}\\
		\bitbox{16}{Reserved}%
		\bitbox{16}{\small Number of Group Records~(M)}\hypertarget{group-rec}{}\\
		\wordbox{1}{Group Record [1]}\\
		\wordbox{2}{\vdots}\\
		\wordbox{1}{Group Record [M]}
	\end{bytefield}
	\caption{Schemat pamięci rodzajów pakietów \emph{Membership Report Message} w~protokole~\href{https://tools.ietf.org/html/rfc3376\#page-13}{IGMPv3}}
	\label{fig:igmpv3}
\end{figure}

\begin{figure}
	\centering
	\begin{bytefield}{32}
		\bitheader{0,7,8,15,16,23,24,31}\\
		\bitbox{8}{Record Type}%
		\bitbox{8}{Aux Data Len}%
		\bitbox{16}{Number of Sources~(N)}\hypertarget{group-record-multicast-addr}\\
		\wordbox{1}{Multicast Address}\hypertarget{group-record-ip-list}{}\\
		\wordbox{1}{Source Address [1]}\\
		\wordbox{2}{\vdots}\\
		\wordbox{1}{Source Address [N]}\\
		\wordbox{1}{Auxiliary Data}
	\end{bytefield}
	\caption{Schemat pamięci pola \protect\hyperlink{group-rec}{\texttt{Group Record}} pakietu \emph{Membership Report Message} w~protokole~\href{https://tools.ietf.org/html/rfc3376\#page-14}{IGMPv3}}
	\label{fig:igmpv3-group-record}
\end{figure}

Protokół multicastowy bardzo dobrze sprawdza się w~rozsyłaniu tych samych, uniwersalnie zapisanych (tj.~niezależnych od~systemu operacyjnego) konfiguracji swoim klientom, jednak należy mieć świadomość, że~rozesłane konfiguracje są~\emph{de~facto} metakonfiguracjami, które służą do~pobrania właściwych pakietów oprogramowania i~ustawienia właściwej konfiguracji systemów klienckich. Serwer podczas każdej sesji rozgłoszeniowej rozsyła pełny, oczekiwany opis konfiguracji klientów, a~nie pełny obraz oprogramowania gotowego do~zainstalowania, opisany przez tę~konfigurację. Rozsyłanie multicastem za~każdym razem całego obrazu oprogramowania mogłoby oznaczać przesyłanie nawet kilku gigabajtów danych, podczas gdy~najczęściej większość z~tych danych została odebrana i~zastosowana przez klientów podczas wcześniejszych sesji multicastowych. Z~tego powodu klienci, po~odebraniu konfiguracji rozesłanej multicastem, muszą sami zgłosić się do~serwera buforującego pakiety oprogramowania pobrane z~\href{http://sjp.pwn.pl/poradnia/haslo/;228}{Internetu}. Innym problemem przy~rozsyłaniu od~razu gotowych obrazów oprogramowania do~klientów --- niezależnie czy multicastem czy unicastem --- byłaby konieczność umożliwienia klientom pobrania brakujących zależności, których przewidzenie z~góry przez serwer byłoby bardzo trudne lub~niemożliwe, ponieważ każdy pakiet może zależeć od~wielu innych, z~których każdy inny od~jeszcze innych~itd. Serwer buforujący oprogramowanie ma~za zadanie buforować przez pewien konfigurowalny czas wszystkie pakiety, których potrzebują klienci, aby~to~samo oprogramowanie nie było pobierane wielokrotnie (kilkusetkrotnie w~przypadku setek klientów potrzebujących tej samej konfiguracji). Serwer buforujący pakiety jest bardzo ważnym elementem, który może znacznie odciążyć sieć, ponieważ pakiet potrzebny grupie~$N$ klientów zostanie pobrany tylko raz, a~nie $N$~razy. Co~ciekawe, żadne z~istniejących rozwiązań opisanych w~rozdziale~\ref{ch:istniejace-rozwiazania} nie ma~wbudowanego takiego serwera pośredniczącego\footnote{Co~\href{https://groups.google.com/forum/?fromgroups\#!topic/puppet-users/kszE7LDWejU}{nie znaczy}, że~nie można takiego dodać ręcznie.} --- np.~w~\hyperref[sec:puppet]{Puppet} i~\hyperref[sec:salt]{Salt} każdy klient sam pobiera brakujące pakiety z~Internetu.

\hypertarget{server-role} Rola serwera w~opracowanym protokole jest potrójna:\mynobreakpar
\begin{enumerate}
	\item\hypertarget{itm:server-role-1} serwer rozgłasza multicastem do~wszystkich zainteresowanych klientów uniwersalnie zapisany opis stanu oprogramowania, które powinno zostać zainstalowane na~maszynach klienckich,
	\item\hypertarget{itm:server-role-2} serwer buforujący pakiety oprogramowanie (\hrefemph{https://wiki.archlinux.org/index.php/Package_Proxy_Cache}{Package Proxy Cache}), na~żądanie klientów, wysyła im~unicastem oprogramowanie opisane w~konfiguracji otrzymanej multicastem; serwer ten~pozwala administratorowi nadpisanie domyślnej konfiguracji wybranych pakietów,
	\item serwer przez cały czas nasłuchuje na~porcie~UDP na~logi z~przeprowadzonych przez klientów instalacji oprogramowania,~aby administrator sieci mógł podjąć działania naprawcze w~przypadku np.~niepowodzeń instalacji na~maszynach klienckich.
\end{enumerate}
Z~tak dokonanego podziału ról serwera wynika, że~oprogramowanie serwera dystrybuującego oprogramowanie, może być uruchomione na~jednym, dwóch lub~trzech różnych serwerach --- taka elastyczność konfiguracji sprzyja rozłożeniu obciążenia serwera na~trzy maszyny. Rozdzielenie \hyperlink{itm:server-role-1}{punktu pierwszego} i~\hyperlink{itm:server-role-2}{drugiego} jest spowodowane, poza opisanymi wcześniej problemami wynikającymi z~przesyłania od~razu całego obrazu oprogramowania, również tym, że~komputery klienckie w~jednej grupie multicastowej mogą mieć nie tylko różne systemy operacyjne, ale~też różne modele programowe procesora~(\hrefemph{https://en.wikipedia.org/wiki/Instruction_set}{Instruction Set Architecture} --- ISA), np.~\hrefemph{https://en.wikipedia.org/wiki/X86}{x86}, \hrefemph{https://en.wikipedia.org/wiki/ARM_architecture}{ARM}, \hrefemph{https://en.wikipedia.org/wiki/PowerPC}{PowerPC}~\href{https://en.wikipedia.org/wiki/List_of_instruction_sets}{itd.} W~konsekwencji klienci, nawet jeśli otrzymają od~serwera listę nazw tych samych pakietów do~zainstalowania, to~potencjalnie muszą pobrać różne archiwa oprogramowania, skompilowane dla~różnych~ISA. Propozycją rozwiązania tego problemu mogłoby być np.~rozsyłanie przez serwer kodów źródłowych programów do~klientów, aby~mogły one same skompilować potrzebne programy --- takie rozwiązanie byłoby jednak bardzo kłopotliwe technicznie, ze~względu na~ogromne zróżnicowanie metod kompilacji, przekazywania flag kompilacji i~z~innych, czasami prozaicznych przyczyn --- np.~z~powodu braku odpowiedniego kompilatora na~maszynie klienta, który mógłby przeprowadzić taką kompilację. Rozwiązaniem tego problemu mógłby być dalszy podział grup multicastowych w~celu podzielenia klientów na~różne kategorie sprzętowe, ale i~takie rozwiązanie jest niedoskonałe, ponieważ w~praktyce często zdarza się, że~część klientów ma już zainstalowaną część oprogramowania wymaganego przez serwer, podczas gdy~inni klienci go~nie mają.

Rys.~\ref{fig:schemat-komunikacji} przedstawia schemat komunikacji klienta i~serwera (lub~serwerów w~zależności od~konfiguracji). Strzałka~1 oznacza regularnie rozsyłany multicast niosący~\hyperref[sec:security]{podpisany cyfrowo} opis konfiguracji klientów. Strzałka~2 to~połączenie klienta do~serwera buforującego pakiety oprogramowania w~celu pobrania pakietów wymaganych przez serwer multicastowy. Serwer buforujący może mieć już niektóre, albo nawet wszystkie, pakiety które chce pobrać klient, dlatego w~rzeczywistości strzałki~3 i~4 reprezentujące pobranie przez serwer buforujący pakietów z~Internetu, mogą być zbędne przynajmniej dla~niektórych pakietów.

\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{img/schemat-komunikacji}
	\caption{Schemat komunikacji klienta i~serwera (lub~serwerów --- w~zależności od~konfiguracji)}
	\label{fig:schemat-komunikacji}
\end{figure}

Jeśli w~chwili~$t$ serwer rozkazał swoim klientom instalację zbioru pakietów~$A$ i~klient~$X$ zainstalował te~pakiety przed chwilą~$t+1$, w~której serwer rozkazał instalację pewnego zbioru pakietów~$B$, to~jeśli:\mynobreakpar

\begin{itemize}
	\item $A=B$, to~w~chwili~$t+1$ klient niczego nie zmienia w~swojej konfiguracji\footnote{Chyba, że~serwer rozkazał również aktualizację zainstalowanego już oprogramowania klientów, ale~to wykluczamy na~potrzeby tych rozważań.}. Warto zauważyć, że~w praktyce sytuacja, w~której~$A=B$, zdarza się najczęściej, ponieważ typowe czasy rozgłaszania konfiguracji serwera to~kilkadziesiąt minut\footnote{Np.~w~\hyperref[sec:puppet]{Puppet} domyślny czas między synchronizacjami z~serwerem wynosi~30~minut.} lub~kilka godzin, podczas gdy~administrator sieci zazwyczaj nie zmienia tak często rozgłaszanej konfiguracji klientów.
	\item $A\neq B\;\wedge\;\exists_{p\in A}\;p\not\in B$, to~klient niczego nie zmienia w~swojej konfiguraji, w~szczególności nie odinstalowuje pakietu~$p$ --- klient odinstalowuje tylko te~pakiety, które są~\emph{explicite} wymienione na~liście pakietów do~usunięcia.
	\item $A\neq B\;\wedge\;\exists_{p\in B}\;p\not\in A$, to~klient instaluje pakiet~$p$.
\end{itemize}

Konfiguracja serwera pozwala opcjonalnie włączyć multicastowe rozgłaszanie listy wszystkich obsługiwanych multicastowych adresów~IP i~odpowiadających im~opisowych nazw, ustalonych przez administratora sieci, dzięki czemu aplikacja klienta jest zdolna wyświetlić wszystkie adresy multicastowe\footnote{Zakres multicastowych adresów~IP jest regulowany przez \gls{iana} w~\href{https://tools.ietf.org/html/rfc5771}{RFC5771} i~jest następujący: 224.0.0.0 -- 239.255.255.255~(\href{https://en.wikipedia.org/wiki/Classful_network\#Classful_addressing_definition}{klasa~D}), przy~czym adresy z~zakresu 224.0.0.0 -- 224.0.0.255 \href{https://www.iana.org/assignments/multicast-addresses/multicast-addresses.xhtml}{są}~wykorzystywane m.in.~przez protoły trasowania oraz~protokoły wykrywające topologię sieci i~nie są~wykorzystywane przez aplikacje~\cite{rfc5771}.}, na~których rozgłaszane są~konfiguracje klientów. Przykładowo, dla~sieci przedstawionej na~rys.~\ref{fig:simple-network}, lista zwrócona przez serwer~(tu~zapisaną w~notacji znanej np.~z~języka Python) byłaby następująca:
\begin{lstlisting}[numbers=none,frame=none]
[
	[ { 'name' : 'Laboratorium A' }, { 'IP' : '224.10.10.1' } ],
	[ { 'name' : 'Laboratorium B' }, { 'IP' : '224.10.10.2' } ],
	[ { 'name' : 'Laboratorium C' }, { 'IP' : '224.10.10.3' } ],
	[ { 'name' : 'Biblioteka'     }, { 'IP' : '224.10.10.4' } ]
]
\end{lstlisting}

\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{img/przykladowa-siec-wireless}
	\caption{Przykładowa sieć działająca pod~kontrolą serwerów dystrybucji oprogramowania}
	\label{fig:simple-network}
\end{figure}

%------------------------------------------------------------------------------

\section{Bezpieczeństwo protokołu}
\label{sec:security}

Uwzględnienie aspektów bezpieczeństwa jest krytyczne dla~powodzenia każdego poważnego projektu protokołu, szczególnie takiego, który umożliwia serwerowi na~zarządzanie konfiguracją dziesiątek, setek lub~tysięcy klientów. Zaniedbanie bezpieczeństwa protokołu lub~jego wadliwa implementacja, może umożliwić atakującemu na~przejęcie kontroli nad~wszystkimi klientami, np.~przez przesłanie klientom złośliwych aktualizacji oprogramowania lub~konfiguracji.

Istnieje wiele powszechnych technik ataków protokołów sieciowych. Najpopularniejsze z~nich to:\mynobreakpar

\begin{itemize}
	\item \hypertarget{itm:mitm} \protect\hrefemph{https://en.wikipedia.org/wiki/Man-in-the-middle_attack}{Man In The Middle~(MITM)} --- technika ataku polegająca na~tym, że~atakujący nasłuchuje komunikacji między klientem i~serwerem i~modyfikuje przesyłane dane albo~sam tworzy nowe i~,,wstrzykuje'' je~między pakiety klienta i~serwera.
	\item \hrefemph{https://en.wikipedia.org/wiki/Replay_attack}{Replay Attack} --- technika ataku polegająca na~tym, że~poprawne (nawet podpisane cyfrowo w~niektórych przypadkach) dane podsłuchane w~czasie wcześniejszych sesji komunikacyjnych między klientem i~serwerem, są~powtarzane po~jakimś czasie w~innym kontekście komunikacyjnym\footnote{Technika ta~może być szczególnie \href{https://en.wikipedia.org/wiki/Rolling_code}{dotkliwa} np.~dla~posiadaczy samochodów z~podatnymi układami \href{https://en.wikipedia.org/wiki/Remote_keyless_system}{zdalnego zamka centalnego} samochodu, posiadaczy bram garażowych sterowanych zdalnie~itp.}.
\end{itemize}

W~celu uniknięcia podatności protokołu na~wymienione i~inne, popularne rodzaje ataków, należy zagwarantować bezpieczeństwo protokołu co~najmniej pod~względem uwierzytelnienia serwera i~integralności komunikacji. Poufność komunikacji nie jest konieczna, ponieważ konfiguracja klientów nie jest poufna, a~pakiety oprogramowania przesyłane do~klientów są~powszechnie dostępne w~\href{https://wiki.archlinux.org/index.php/official_repositories}{repozytoriach pakietów}. Ponadto poufność w~trybie multicastowym byłoby bardzo trudno zagwarantować, ponieważ \href{https://www.google.pl/search?q=multicast+encryption}{nie istnieje} żaden powszechnie uznany standard gwarantujący \href{http://www.cisco.com/c/dam/en/us/products/collateral/ios-nx-os-software/ip-multicast/prod_presentation0900aecd80473105.pdf}{poufność} w~komunikacji multicastowej. Poufność oparta na~współdzieleniu klucza kryptograficznego przez wszystkich lub~część klientów, który byłby użyty do~szyfrowania symetrycznego (np.~popularnym szyfrem~\gls{aes}) byłby kryptograficznie słabym rozwiązaniem ze~względu na~powielenie tajnego klucza. W~przypadku potrzeby szyfrowania elementów konfiguracji pakietów, można ją~zapewnić w~ramach unicastowego połączenia klienta z~serwerem buforującym pakiety oprogramowania.

W~kolejnych podrozdziałach zostały opisane metody, które zostały wykorzystane do~zapewnienia poszczególnych elementów, składających się na~bezpieczeństwo protokołu. Wszystkie opisane dalej algorytmy i~metody kryptograficzne zostały wykorzystane przez niniejszy projekt przez wykorzystanie biblioteki \hreftt{http://www.pyopenssl.org/}{pyOpenSSL}, będącej interfejsem otwartoźródłowej biblioteki kryptograficznej~\texttt{\gls{openssl}} dla~języka Python, implementującej m.in.~protokół kryptograficzny~\gls{ssl/tls}.

%---------------------------------------

\subsection{Uwierzytelnienie}

Uwierzytelnienie serwera przez klienta jest krytyczne dla~bezpieczeństwa protokołu. Gdyby nie ono, to~atakujący mógłby podawać się za~serwer i~przesłać klientowi dowolną konfigurację i~oprogramowanie, co~jest szczególnie łatwe w~wykorzystanym protokole multicastowym niekorzystającym z~opcji filtrowania \hyperlink{igmpv3-filtering}{dostępnego} w~IGMPv3. Warto zauważyć, że~nawet gdyby komunikacja była szyfrowana, ale nie uwierzytelniana, to~atakujący mógłby również podjąć próby ataku \emph{replay attack}. W~celu uniknięcia tego problemu wykorzystano certyfikat \href{https://en.wikipedia.org/wiki/X.509}{X.509} dla~serwera rozgłaszającego konfiguracje klientów~\cite{wiki:x509}.

Wygenerowanie takiego certyfikatu cyfrowego wymaga podpisania go~przez centrum certyfikacji~(\gls{ca})~\cite{wiki:ca}. Ze~względu na~brak potrzeby posiadania w~trakcie implementacji certyfikatu podpisanego przez uznane~\gls{ca}, a~także ze~względu na~względnie duże koszty finansowe i~czasowe z~tym związane, w~czasie implementacji wykorzystano certyfikat podpisany przez siebie~(\hrefemph{https://en.wikipedia.org/wiki/Self-signed_certificate}{self-signed certificate}). Konfiguracja klienta pozwala w~trybie \texttt{debug} zaufać takiemu certyfikatowi. Oczywiście, w~przypadku wdrożenia projektu, należałoby postarać się o~certyfikat podpisany przez uznany~\gls{ca}.

Wygenerowanie i~podpisanie certyfikatu zostało wykonane z~użyciem \gls{openssl}. Listing~\ref{lst:openssl-gencert} przedstawia jak wygenerować klucze publiczny i~prywatny \gls{rsa} o~długości 4096~bitów, a~następnie, jak wykorzystać klucz prywatny do~wygenerowania żądania podpisania certyfikatu (\hrefemph{https://en.wikipedia.org/wiki/Certificate_signing_request}{Certificate Signing Request}) i~na jego podstawie podpisać certyfikat~X.509~\cite{openssl-cookbook,wiki:csr}.\\% Czemu taki mał odstęp bez nowej linii? o.O

\begin{lstlisting}[numbers=none,caption={Wygenerowanie i~podpisanie certyfikatu X.509},label=lst:openssl-gencert]
$ openssl genrsa -aes256 -out rsa_aes256_4096.key 4096
$ openssl req -new -key rsa_aes256_4096.key -out request.csr
$ openssl req -new -config request.cnf -key fd.key -out request.csr
$ openssl x509 -req -days 365 -in request.csr -signkey rsa_aes256_4096.key -out certificate.pem
\end{lstlisting}

\begin{lstlisting}[numbers=none,caption={Plik z~konfiguracją certyfikatu X.509},label=lst:openssl-request-config]
[req]
default_bits       = 4096
default_keyfile    = rsa_aes256_4096.key
prompt             = no
distinguished_name = dn
req_extensions     = ext
input_password     = minipw

[dn]
CN                 = Patryk
OU                 = MiNI
emailAddress       = bezap@student.mini.pw.edu.pl
O                  = PW
L                  = Warsaw
ST                 = Masovian
C                  = PL

[ext]
subjectAltName     = DNS:www.mini.pw.edu.pl,DNS:*.mini.pw.edu.pl
\end{lstlisting}

Listing~\ref{lst:openssl-request-config} przedstawia przykładową zawartość pliku \path{request.cnf}, który służy do~konfiguracji żądania podpisania certyfikatu. Certyfikat jest zaufany jeśli istnieje ważny\footnote{Tzn.~żaden certyfikat w~ciągu nie stracił ważności.} ciąg podpisów cyfrowych, który zaczyna się~od~\gls{ca}, a~kończy na~naszym certyfikacie. Aby sprawdzić czy~certyfikat jest przez nas zaufany, wystarczy wydać komendę:
\begin{lstlisting}[numbers=none]
$ openssl verify -verbose certificate.pem
\end{lstlisting}

%---------------------------------------

\subsection{Integralność}

Integralność komunikacji jest konieczna, aby zapobiec atakom typu \emph{\hyperlink{itm:mitm}{Man In the Middle}}, polegającym na~modyfikacji komunikacji między serwerem i~klientem, \href{https://en.wikipedia.org/wiki/Digital_signature\#Integrity}{niezależnie} od~tego czy jest ona~szyfrowana czy nie. Do~zapewnienia integralności danych używana jest \href{https://www.ibm.com/support/knowledgecenter/SSFKSJ_7.0.1/com.ibm.mq.csqzas.doc/sy11300_.htm}{funkcja skrótu} zastosowana na~wysłanych danych, a~następnie podpisana certyfikatem cyfrowym. W~zależności od~konfiguracji do~tego celu może użyta np.~\emph{SHA384}, \emph{SHA256} czy~\emph{SHA1}.

\end{document}
