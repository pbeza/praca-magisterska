\documentclass[thesis]{subfiles}

\begin{document}

\chapter{Protokół komunikacji}
\label{ch:protokol}

Celem niniejszej pracy jest ułatwienie pracy administratora komputerowego przez zaprojektowanie i~zaimplementowanie protokołu umożliwiającego propagowanie zmian w~systemie plików, pakietów oraz~elementów konfiguracji do~stacji roboczych pod~kontrolą systemu operacyjnego \glslink{gnulinux}{Linux/GNU} lub~innego systemu \glslink{unix-like-system}{*nix}, a~także elastycznego standardu opisu zmian oraz~narzędzi dla~ich rejestrowania i~dostosowywania. Tak postawiony cel wydaje się być zbliżony do~celu jaki postawili przed sobą twórcy istniejących rozwiązań, przedstawionych w~rozdziale~\ref{ch:istniejace-rozwiazania}, jednak pomysł na~jego realizację w~ramach tej pracy jest zasadniczo inny od~istniejących implementacji.

%------------------------------------------------------------------------------

\section{Idea działania}

Typowy scenariusz użycia dowolnego z~przedstawionych czterech, istniejących rozwiązań, polega w~uproszczeniu na~tym, że~administrator komputerowy przygotowuje zestaw plików konfiguracyjnych, będących abstrakcyjnym, tzn.~niezależnym od~konkretnego systemu, \href{https://martinfowler.com/bliki/DomainSpecificLanguage.html}{wyrażaniem} wymagań administratora w~stosunku do~konfiguracji systemów klienckich. Tak przygotowane pliki konfiguracyjne są~następnie przetwarzane --- w~zależności od~rozwiązania --- przez aplikację serwera lub~klienta, a~wynik przetworzenia jest docelową konfiguracją klienta, do~której klient się dostosowuje. W~zależności od~rozwiązania, klient odpytuje serwer co~pewien czas o~aktualizację oprogramowania --- tak się dzieje np.~w~\hyperref[sec:puppet]{Puppet}, \hyperref[sec:chef]{Chef} i~w~zwykłym trybie pracy \hyperref[sec:salt]{Salt} --- lub~serwer wymusza zmiany na~kliencie --- jak np.~w~\hyperref[sec:ansible]{Ansible} i~w~trybie \emph{agentless} w~\hyperref[sec:salt]{Salt}. Po~zastosowaniu się do~zmian konfiguracji przesłanych przez serwer do~klienta, klient, w~zależności od~rozwiązania, może poinformować serwer o~powodzeniu lub~niepowodzeniu przeprowadzonej instalacji i~może przesłać dodatkowe logi, z~których serwer może przygotować np.~kompleksowe raporty.

Rozwiązanie stworzone w~ramach niniejszej pracy działa w~odmienny sposób. Zaprojektowany zestaw narzędzi zwalnia administratora komputerowego z~przygotowania plików konfiguracyjnych opisujących szczegółowo konfigurację klientów, jak ma~to~miejsce w~opisanych w~\hyperref[ch:istniejace-rozwiazania]{poprzednim rozdziale} istniejących rozwiązaniach. Takie podejście ma~praktyczną zaletę polegającą na~tym, że~administrator nie musi poznawać języka (\hrefemph{https://en.wikipedia.org/wiki/Domain-specific_language}{Domain Specific Language}), którym posługuje się aplikacja do~abstrakcyjnego opisania wzorcowej konfiguracji.

Typowy przykład użycia zaproponowanego rozwiązania polega na~tym, że~administrator, przed dokonaniem jakichkolwiek zmian, które chce, aby~były odzwierciedlone na~stacjach klienckich, skanuje system, który jest wzorcem oprogramowania i~konfiguracji dla~klientów. W~typowym przypadku takie skanowanie zostaje przeprowadzonym na~,,czystym'' systemie operacyjnym, tzn.~dopiero co~zainstalowanym i~niezmodyfikowanym. W~wyniku przeprowadzonego skanowania systemu powstaje plik tekstowy opisujący stan systemu. Po~wykonaniu skanowania, administrator konfiguruje przeskanowany uprzednio system, tak, jak chciałby skonfigurować stacje klienckie. Wszystkie zmiany, które wykona na~systemie wzorcowym\footnote{W~dalszej części pracy, określenie \emph{system wzorcowy} będzie skrótowo utożsamiany z~systemem, którego konfiguracja została przeskanowana i~na podstawie której powstał obraz zmian dla~klientów.}, zostają wykryte podczas drugiego skanowania, którego wynikiem jest drugi plik opisujący stan systemu po~dokonaniu zmian w~konfiguracji przez administratora. Na~podstawie tych dwóch plików stanów, administrator, za~pomocą przygotowanych w~ramach tej pracy aplikacji, otrzymuje obraz zmian, który zostanie przesłany do~klientów i~zastosowany przez nich. Zastosowanie obrazu zmian przez klienta odbywa się również za~pośrednictwem aplikacji stworzonej w~ramach tej~pracy.

Kolejne trzy rozdziały~\ref{sec:tworzenie-obrazu-konfiguracji}, \ref{sec:przeslanie-obrazu-konfiguracji} i~\ref{sec:zastosowanie-obrazu-konfiguracji} opisują wszystkie etapy użycia zaprojektowanego zestawu narzędzi, tzn.~kolejno --- stworzenie obrazu zmian konfiguracji stacji wzorcowej, przesłanie jej do~klienta i~zastosowanie jej przez system klienta.

%------------------------------------------------------------------------------

\section{Tworzenie obrazu zmian konfiguracji}
\label{sec:tworzenie-obrazu-konfiguracji}

Tworzenie obrazu zmian konfiguracji wzorcowej, tzn.~takiej konfiguracji systemu, która zostanie zastosowana na~maszynach klienckich, odbywa się w~trzech lub czterech krokach, w~zależności od~tego czy stacja wzorcowa była wcześniej skanowana\footnote{Przez \emph{skanowanie} rozumie się przeanalizowanie systemu plików stacji wzorcowej w~poszukiwaniu zmian konfiguracji lub~ustalenie konfiguracji referencyjnej w~przypadku pierwszego skanowania.} --- w~rezultacie czego powstał plik podsumowujący stan systemu --- czy nie była. Jeśli stacja nie była wcześniej skanowana, to~do~wygenerowania obrazu konfiguracji jest wymagane wykonanie następujących czterech kroków:
\begin{enumerate}
	\item Pierwsze skanowanie tej części systemu plików stacji wzorcowej, którą administrator chce przenieść na~maszyny klienckie. Skanowanie odbywa się za~pomocą skanera\footnote{Przygotowany w~ramach tej pracy skaner korzysta z~programu~\href{http://aide.sourceforge.net/}{AIDE}, opisanego szerzej w~rozdziale~\ref{sec:aide}.} W~rezultacie skanowania powstaje plik tekstowy ze~\href{https://en.wikipedia.org/wiki/Hash_function}{skrótami} przeskanowanych plików, definiującymi referencyjny stan systemu. Ustawienie parametrów skanowania, w~tym m.in.~zakresu skanowanych katalogów, odbywa się za~pomocą konfiguracji programu~\href{http://aide.sourceforge.net/}{AIDE}, opisanej w~rozdziale~\ref{sec:aide}.
	\item Dokonanie zmian w~konfiguracji maszyny wzorcowej, tak, jakby była maszyną kliencką, której konfigurację administrator chce dostosować do~wzorca. Wszystkie pliki maszyny wzorcowej, które ulegną zmianie od~czasu pierwszego skanowania oraz wszystkie usunięte i~nowe pliki, które odpowiednio --- znajdowały się lub znajdą się --- w~katalogach skanowanych podczas pierwszego skanowania, zostaną wzięte pod~uwagę\footnote{Decyzja o~skopiowaniu lub~usunięciu tych plików z~maszyny klienta zależy od~decyzji administratora podjętej w~trakcie generowania obrazu zmian dla~klienta, o~czym więcej w~dalszej części akapitu.} podczas ostatniego etapu tworzenia obrazu zmian konfiguracji dla~maszyny klienckiej.
	\item Drugie skanowanie tej samej części systemu plików co~podczas pierwszego skanowania. Drugie skanowanie nie odbywa się identycznie jak pierwsze, ponieważ drugie skanowanie bierze pod uwagę plik stanu systemu powstały po~uruchomieniu pierwszego skanowania. Rezultatem drugiego skanowania jest plik zmian konfiguracji systemu od~czasu pierwszego skanowania. W~szczególności w~stworzonym pliku nie ma informacji o~plikach których skróty się nie zmieniły od~czasu pierwszego skanowania.
	\item Stworzenie obrazu konfiguracji dla~maszyn klienckich na~podstawie plików powstałych w~rezultacie przeprowadzonych dwóch skanowań systemu. Obraz konfiguracji to~archiwum plików z~\href{https://unix.stackexchange.com/questions/43605/how-do-i-copy-a-folder-keeping-owners-and-permissions-intact}{zachowanymi} m.in.~\href{https://wiki.archlinux.org/index.php/File_permissions_and_attributes}{prawami użytkowników, grup i~atrybutami plików}.
\end{enumerate}

%------------------------------------------------------------------------------

\section{Przesłanie obrazu zmian konfiguracji}
\label{sec:przeslanie-obrazu-konfiguracji}

%------------------------------------------------------------------------------

\section{Zastosowanie obrazu zmian konfiguracji}
\label{sec:zastosowanie-obrazu-konfiguracji}

%------------------------------------------------------------------------------

\section{Bezpieczeństwo protokołu}
\label{sec:security}

Uwzględnienie aspektów bezpieczeństwa jest krytyczne dla~powodzenia każdego poważnego projektu protokołu, szczególnie takiego, który umożliwia serwerowi na~zarządzanie konfiguracją dziesiątek, setek lub~tysięcy klientów. Zaniedbanie bezpieczeństwa protokołu lub~jego wadliwa implementacja, może umożliwić atakującemu na~przejęcie kontroli nad~wszystkimi klientami, np.~przez przesłanie klientom złośliwych aktualizacji oprogramowania lub~konfiguracji.

Istnieje wiele powszechnych technik ataków protokołów sieciowych. Najpopularniejsze z~nich to:\mynobreakpar

\begin{itemize}
	\item \hypertarget{itm:mitm} \protect\hrefemph{https://en.wikipedia.org/wiki/Man-in-the-middle_attack}{Man In The Middle~(MITM)} --- technika ataku polegająca na~tym, że~atakujący nasłuchuje komunikacji między klientem i~serwerem i~modyfikuje przesyłane dane albo~sam tworzy nowe i~,,wstrzykuje'' je~między pakiety klienta i~serwera.
	\item \hrefemph{https://en.wikipedia.org/wiki/Replay_attack}{Replay Attack} --- technika ataku polegająca na~tym, że~poprawne (\href{https://www.ibm.com/support/knowledgecenter/en/SSAW57_8.0.0/com.ibm.websphere.nd.doc/info/ae/ae/rwbs_secconsider6wssec.html}{nawet} podpisane cyfrowo) dane podsłuchane w~czasie wcześniejszych sesji komunikacyjnych między klientem i~serwerem, są~powtarzane po~jakimś czasie w~innym kontekście komunikacyjnym\footnote{Technika ta~może być szczególnie \href{https://en.wikipedia.org/wiki/Rolling_code}{dotkliwa} np.~dla~posiadaczy samochodów z~podatnymi układami \href{https://en.wikipedia.org/wiki/Remote_keyless_system}{zdalnego zamka centralnego} samochodu, posiadaczy bram garażowych sterowanych zdalnie~itp.}.
\end{itemize}

W~celu uniknięcia podatności protokołu na~wymienione i~inne, popularne rodzaje ataków, należy zagwarantować bezpieczeństwo protokołu co~najmniej pod~względem uwierzytelnienia serwera i~integralności komunikacji. Poufność komunikacji nie jest konieczna, ponieważ konfiguracja klientów nie jest poufna, a~pakiety oprogramowania przesyłane do~klientów są~powszechnie dostępne w~\href{https://wiki.archlinux.org/index.php/official_repositories}{repozytoriach pakietów}. Ponadto poufność w~trybie multicastowym byłoby bardzo trudno zagwarantować, ponieważ \href{https://www.google.pl/search?q=multicast+encryption}{nie istnieje} żaden powszechnie uznany standard gwarantujący \href{http://www.cisco.com/c/dam/en/us/products/collateral/ios-nx-os-software/ip-multicast/prod_presentation0900aecd80473105.pdf}{poufność} w~komunikacji multicastowej. Poufność oparta na~współdzieleniu klucza kryptograficznego przez wszystkich lub~część klientów, który byłby użyty do~szyfrowania symetrycznego (np.~popularnym szyfrem~\gls{aes}) byłby kryptograficznie słabym rozwiązaniem ze~względu na~powielenie tajnego klucza. W~przypadku potrzeby szyfrowania elementów konfiguracji pakietów, można ją~zapewnić w~ramach unicastowego połączenia klienta z~serwerem buforującym pakiety oprogramowania.

W~kolejnych podrozdziałach zostały opisane metody, które zostały wykorzystane do~zapewnienia poszczególnych elementów, składających się na~bezpieczeństwo protokołu. Wszystkie opisane dalej algorytmy i~metody kryptograficzne zostały wykorzystane przez niniejszy projekt przez wykorzystanie biblioteki \hreftt{http://www.pyopenssl.org/}{pyOpenSSL}, będącej interfejsem otwartoźródłowej biblioteki kryptograficznej~\texttt{\gls{openssl}} dla~języka Python, implementującej m.in.~protokół kryptograficzny~\gls{ssl/tls}.

%---------------------------------------

\subsection{Uwierzytelnienie}

Uwierzytelnienie serwera przez klienta jest krytyczne dla~bezpieczeństwa protokołu. Gdyby nie ono, to~atakujący mógłby podawać się za~serwer i~przesłać klientowi dowolną konfigurację i~oprogramowanie, co~jest szczególnie łatwe w~wykorzystanym protokole multicastowym niekorzystającym z~opcji filtrowania \hyperlink{igmpv3-filtering}{dostępnego} w~IGMPv3. Warto zauważyć, że~nawet gdyby komunikacja była szyfrowana, ale nie uwierzytelniana, to~atakujący mógłby również podjąć próby ataku \emph{replay attack}. W~celu uniknięcia tego problemu wykorzystano certyfikat \href{https://en.wikipedia.org/wiki/X.509}{X.509} dla~serwera rozgłaszającego konfiguracje klientów~\cite{wiki:x509}.

Wygenerowanie takiego certyfikatu cyfrowego wymaga podpisania go~przez centrum certyfikacji~(\gls{ca})~\cite{wiki:ca}. Ze~względu na~brak potrzeby posiadania w~trakcie implementacji certyfikatu podpisanego przez uznane~\gls{ca}, a~także ze~względu na~względnie duże koszty finansowe i~czasowe z~tym związane, w~czasie implementacji wykorzystano certyfikat podpisany przez siebie~(\hrefemph{https://en.wikipedia.org/wiki/Self-signed_certificate}{self-signed certificate}). Konfiguracja klienta pozwala w~trybie \texttt{debug} zaufać takiemu certyfikatowi. Oczywiście, w~przypadku wdrożenia projektu, należałoby postarać się o~certyfikat podpisany przez uznany~\gls{ca}.

Wygenerowanie i~podpisanie certyfikatu zostało wykonane z~użyciem \gls{openssl}. Listing~\ref{lst:openssl-gencert} przedstawia jak wygenerować klucze publiczny i~prywatny \gls{rsa} o~długości 4096~bitów, a~następnie, jak wykorzystać klucz prywatny do~wygenerowania żądania podpisania certyfikatu (\hrefemph{https://en.wikipedia.org/wiki/Certificate_signing_request}{Certificate Signing Request}) i~na jego podstawie podpisać certyfikat~X.509~\cite{openssl-cookbook,wiki:csr}.\\% Czemu taki mał odstęp bez nowej linii? o.O

\begin{lstlisting}[numbers=none,caption={Wygenerowanie i~podpisanie certyfikatu X.509},label=lst:openssl-gencert]
$ openssl genrsa -aes256 -out rsa_aes256_4096.key 4096
$ openssl req -new -key rsa_aes256_4096.key -out request.csr
$ openssl req -new -config request.cnf -key fd.key -out request.csr
$ openssl x509 -req -days 365 -in request.csr -signkey rsa_aes256_4096.key -out certificate.pem
\end{lstlisting}

\begin{lstlisting}[numbers=none,caption={Plik z~konfiguracją certyfikatu X.509},label=lst:openssl-request-config]
[req]
default_bits       = 4096
default_keyfile    = rsa_aes256_4096.key
prompt             = no
distinguished_name = dn
req_extensions     = ext
input_password     = minipw

[dn]
CN                 = Patryk
OU                 = MiNI
emailAddress       = bezap@student.mini.pw.edu.pl
O                  = PW
L                  = Warsaw
ST                 = Masovian
C                  = PL

[ext]
subjectAltName     = DNS:www.mini.pw.edu.pl,DNS:*.mini.pw.edu.pl
\end{lstlisting}

Listing~\ref{lst:openssl-request-config} przedstawia przykładową zawartość pliku \path{request.cnf}, który służy do~konfiguracji żądania podpisania certyfikatu. Certyfikat jest zaufany jeśli istnieje ważny\footnote{Tzn.~żaden certyfikat w~ciągu nie stracił ważności.} ciąg podpisów cyfrowych, który zaczyna się~od~\gls{ca}, a~kończy na~naszym certyfikacie. Aby sprawdzić czy~certyfikat jest przez nas zaufany, wystarczy wydać komendę:
\begin{lstlisting}[numbers=none]
$ openssl verify -verbose certificate.pem
\end{lstlisting}

%------------------------------------------------------------------------------

\subsection{Integralność}

Integralność komunikacji jest konieczna, aby zapobiec atakom typu \emph{\hyperlink{itm:mitm}{Man In the Middle}}, polegającym na~modyfikacji komunikacji między serwerem i~klientem, \href{https://en.wikipedia.org/wiki/Digital_signature\#Integrity}{niezależnie} od~tego czy jest ona~szyfrowana czy nie. Do~zapewnienia integralności danych używana jest \href{https://www.ibm.com/support/knowledgecenter/SSFKSJ_7.0.1/com.ibm.mq.csqzas.doc/sy11300_.htm}{funkcja skrótu} zastosowana na~wysłanych danych, a~następnie podpisana certyfikatem cyfrowym. W~zależności od~konfiguracji do~tego celu może użyta np.~\emph{SHA384}, \emph{SHA256} czy~\emph{SHA1}.

\end{document}
