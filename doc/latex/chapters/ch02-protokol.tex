\documentclass[thesis]{subfiles}

\begin{document}

\chapter{Protokół komunikacji}
\label{ch:protokol}

Celem niniejszej pracy jest ułatwienie pracy administratora komputerowego przez zaprojektowanie i~zaimplementowanie protokołu umożliwiającego propagowanie zmian w~systemie plików, pakietów oraz~elementów konfiguracji do~stacji roboczych pod~kontrolą systemu operacyjnego \glslink{gnulinux}{Linux/GNU} lub~innego systemu \glslink{unix-like-system}{*nix}, a~także elastycznego standardu opisu zmian oraz~narzędzi dla~ich rejestrowania i~dostosowywania. Tak~przedstawiony cel może wydawać się podobny lub~identyczny do~celu jaki postawili przed sobą twórcy istniejących rozwiązań, przedstawionych w~rozdziale~\ref{ch:istniejace-rozwiazania}, jednak pomysł na~jego realizację w~ramach tej pracy zasadniczo różni się od~istniejących implementacji.

%------------------------------------------------------------------------------

\section{Idea działania}

Typowy scenariusz użycia dowolnego z~przedstawionych w~rozdziale~\ref{ch:istniejace-rozwiazania} czterech rozwiązań, polega w~uproszczeniu na~tym, że~administrator komputerowy przygotowuje zestaw plików konfiguracyjnych, będących abstrakcyjnym, tzn.~niezależnym od~systemu klienta, \href{https://martinfowler.com/bliki/DomainSpecificLanguage.html}{wyrażaniem} wymagań administratora w~stosunku do~konfiguracji systemów klienckich. Tak~przygotowane pliki konfiguracyjne są~następnie przetwarzane --- w~zależności od~rozwiązania --- przez aplikację serwera lub~klienta, a~wynik przetworzenia jest docelową konfiguracją klienta, do~której klient się dostosowuje. W~zależności od~rozwiązania, klient odpytuje serwer co~pewien czas o~aktualizację oprogramowania (model \emph{pull}) --- tak się dzieje np.~w~\hyperref[sec:puppet]{Puppet}, \hyperref[sec:chef]{Chef} i~w~zwykłym trybie pracy \hyperref[sec:salt]{Salt} --- lub~serwer wymusza zmiany na~kliencie (model \emph{push}) --- jak np.~w~\hyperref[sec:ansible]{Ansible} i~w~trybie \emph{agentless} w~\hyperref[sec:salt]{Salt}. Klient po~zastosowaniu się do~zmian konfiguracji przesłanych przez serwer, w~zależności od~rozwiązania, może poinformować serwer o~powodzeniu lub~niepowodzeniu przeprowadzonej instalacji przesyłając dodatkowe logi, z~których serwer może przygotować np.~kompleksowe raporty.

Rozwiązanie stworzone w~ramach niniejszej pracy działa w~odmienny sposób. Zaprojektowany zestaw narzędzi zwalnia administratora komputerowego z~konieczności przygotowania plików konfiguracyjnych szczegółowo opisujących konfigurację klientów, jak ma~to~miejsce w~istniejących rozwiązaniach, opisanych w~rozdziale~\ref{ch:istniejace-rozwiazania}. Takie alternatywne podejście ma~praktyczną zaletę polegającą na~tym, że~administrator nie musi poznawać i~używać często dość złożonego języka --- nazywanego czasami określeniem \hrefemph{https://en.wikipedia.org/wiki/Domain-specific_language}{Domain Specific Language} --- którym posługuje się aplikacja do~abstrakcyjnego opisania wzorcowej konfiguracji.

Typowy przykład użycia rozwiązania stworzonego w~ramach niniejszej~pracy polega na~tym, że~administrator przed dokonaniem na~stacji wzorcowej jakichkolwiek zmian, które chce, aby~były śledzone i~odzwierciedlone na~stacjach klienckich, ustawia w~pliku konfiguracyjnym listę katalogów i~plików, które chce odzwierciedlić na~stacjach klienckich, a~następnie skanuje system wzorcowy\footnote{Przez \emph{skanowanie} rozumie się przeanalizowanie systemu plików stacji wzorcowej w~poszukiwaniu zmian konfiguracji względem poprzedniego skanowania lub~ustalenie pierwszej konfiguracji referencyjnej w~przypadku pierwszego skanowania. W~dalszej części pracy, określenie \emph{system wzorcowy} będzie skrótowo utożsamiany z~systemem, którego konfiguracja została przeskanowana i~na podstawie której, za~pomocą \hyperref[sec:srv-app]{aplikacji serwera}, powstaje \hyperref[sec:obraz-zmian-konfiguracji]{obraz zmian konfiguracji wzorcowej} dla~klientów.}, tzn.~system który jest wzorcem oprogramowania i~konfiguracji dla~klientów. W~typowym przypadku, pierwsze takie skanowanie zostaje przeprowadzone na~,,czystym'' systemie operacyjnym, tzn.~dopiero co~zainstalowanym i~niezmodyfikowanym. W~wyniku przeprowadzonego skanowania powstają pliki opisujące stan systemu, który jest stanem referencyjnym, tzn.~takim, do~którego będą porównywane wyniki kolejnych skanowań, już~po~dokonaniu zmian w~systemie wzorcowym. Po~przeskanowaniu systemu wzorcowego administrator konfiguruje system wzorcowy, tak, jak chciałby skonfigurować stacje klienckie. Wszystkie zmiany, których dokona na~systemie wzorcowym w~obrębie śledzonych katalogów, zostają wykryte i~odnotowane podczas kolejnego skanowania, którego wynikiem są~kolejne pliki opisujące nowy stan systemu --- już~po~dokonaniu zmian w~konfiguracji przez administratora. Administrator korzystając z~przygotowanej w~ramach tej~pracy \hyperref[sec:srv-app]{aplikacji serwera} przeznaczonej dla~stacji wzorcowej, porównującej takie dwa, niekoniecznie utworzone bezpośrednio po~sobie wyniki skanowań systemu wzorcowego, otrzymuje \hyperref[sec:obraz-zmian-konfiguracji]{obraz zmian konfiguracji wzorcowej}, który może być przejrzany, podsumowany, poddany ostatecznej konfiguracji i~parametryzacji, a~następnie przesłany do~klienta i~przez niego zastosowany.% Przed przeniesieniem obrazu zmian konfiguracji na~stację kliencką, klient powinien mieć już zainstalowany działający system operacyjny, który zostanie tylko skonfigurowany za~pomocą otrzymanego obrazu zmian konfiguracji.

Rozdział~\ref{sec:obraz-zmian-konfiguracji} opisuje dokładniej z~czego składa się wygenerowany obraz zmian konfiguracji systemu, a~trzy następne rozdziały \ref{sec:tworzenie-obrazu-konfiguracji}, \ref{sec:przeslanie-obrazu-konfiguracji} i~\ref{sec:zastosowanie-obrazu-konfiguracji} opisują wszystkie trzy etapy użycia zaprojektowanego zestawu narzędzi, tzn.~kolejno --- stworzenie obrazu zmian konfiguracji stacji wzorcowej, przesłanie jej na~maszynę klienta i~zastosowanie przez aplikację kliencką. Opis interfejsu aplikacji realizującej pomysł przedstawiony w~rozdziale~\ref{ch:protokol} został omówiony w~rozdziale~\ref{ch:implementacja} dotyczącym implementacji projektu.

%------------------------------------------------------------------------------

\section{Obraz zmian konfiguracji systemu wzorcowego}
\label{sec:obraz-zmian-konfiguracji}

Obraz zmian konfiguracji wzorcowej\footnote{W~dalszej części pracy zamiennie nazywany również w~skrócie \emph{obrazem zmian} i~\emph{obrazem konfiguracji}.} to~tworzone przez \hyperref[sec:srv-app]{aplikację serwera} archiwum \targz{} z~\href{https://unix.stackexchange.com/questions/43605/how-do-i-copy-a-folder-keeping-owners-and-permissions-intact}{zachowanymi} m.in.~\href{https://wiki.archlinux.org/index.php/File_permissions_and_attributes}{prawami użytkowników, grup i~innymi atrybutami} spakowanych plików systemu wzorcowego\footnote{Zachowanie atrybutów spakowanych plików jest istotne, ponieważ jest to~jeden z~elementów konfiguracji systemu wzorcowego.} oraz~dodatkowymi plikami opisującymi jakie zmiany zaszły między dwoma przeskanowanymi stanami elementów konfiguracji stacji wzorcowej. Archiwum to~jest generowane na~podstawie wyników przeprowadzonych skanowań systemu wzorcowego za~pomocą skanera~\hyperref[sec:aide]{AIDE}~(patrz rozdział~\ref{sec:aide}). W~jego skład wchodzą pliki, które służą \hyperref[sec:cli-app]{aplikacji klienckiej} do~dostosowania się do~zmian elementów konfiguracji narzuconych przez stację wzorcową, w~tym~m.in.:\mynobreakpar
\begin{itemize}
	\item drzewo katalogów \path{ADDED} zawierające katalogi i~pliki\footnote{Poza zwykłymi plikami brane są~pod uwagę również \href{https://en.wikipedia.org/wiki/Unix_file_types}{pliki specjalne}, w~tym m.in.~\href{https://en.wikipedia.org/wiki/Network_socket}{gniazda sieciowe}, \href{https://en.wikipedia.org/wiki/Unix_domain_socket}{gniazda UNIX}, \href{https://en.wikipedia.org/wiki/Named_pipe}{potoki nazwane (FIFO)}, \href{https://en.wikipedia.org/wiki/Symbolic_link}{dowiązania symboliczne}, pliki urządzeń \href{https://en.wikipedia.org/wiki/Device_file\#Block_devices}{blokowe} i~\href{https://en.wikipedia.org/wiki/Device_file\#Character_devices}{znakowe}.} dodane do~systemu wzorcowego od~czasu ostatniej aktualizacji klienta --- aplikacja kliencka doda je~do~swojego systemu,
	\item drzewo katalogów \path{CHANGED} zawierające \hrefemph{https://en.wikipedia.org/wiki/Patch_(Unix)}{patche} zmienionych plików tekstowych i~inne pliki, których zawartość została zmieniona na~systemie wzorcowym od~czasu ostatniej aktualizacji klienta --- aplikacja kliencka nadpisze nimi swoje wersje plików, a~\emph{patche} zastosuje na~istniejących plikach\footnote{Użycie \hrefemph{https://en.wikipedia.org/wiki/Patch_(Unix)}{patchy} ma~tę~zaletę, że~\hyperref[sec:obraz-zmian-konfiguracji]{obraz zmian konfiguracji wzorcowej} zawierający \emph{patche} zamiast całych plików zajmuje zazwyczaj mniej miejsca na~dysku niż~obraz z~przekopiowanymi w~całości plikami. Konfiguracja aplikacji serwera pozwala ustawić dla~których podkatalogów i~plików mają powstawać \emph{patche} (pozostałe są~kopiowane w~całości do~\hyperref[sec:obraz-zmian-konfiguracji]{obrazu zmian}). Pliki dla~których są~tworzone \emph{patche} są~kopiowane do~wyniku skanowania za~pomocą opcji \hyperlinktt{itm:srv-scan}{--scan} \hyperref[sec:srv-app]{aplikacji serwera} --- dopiero na~podstawie ich~porównania są~tworzone \emph{patche} w~archiwum \hyperref[sec:obraz-zmian-konfiguracji]{obrazu zmian} utworzonym za~pomocą opcji \hyperlinktt{itm:srv-gen-img}{--gen-img}.},
	\item plik \path{removed.txt} z~listą ścieżek do~plików i~katalogów\footnote{Katalog na~poziomie \glslink{kernel}{jądra} systemu operacyjnego to~specjalny rodzaj pliku, dlatego w~dalszej części pracy nie kładzie się szczególnego nacisku na~ich rozróżnianie.} usuniętych z~systemu wzorcowego od~czasu ostatniej aktualizacji klienta przeprowadzonej za~pomocą opcji \hyperlinktt{itm:apply-img}{--apply-img} \hyperref[sec:cli-app]{aplikacji klienckiej} --- aplikacja kliencka usunie te~pliki i~katalogi ze~swojego systemu,
	\item plik \path{changed.txt} z~listą ścieżek plików, katalogów i~ich \href{https://serverfault.com/a/584102/289017}{atrybutów}, w~tym m.in.~uprawnienia, właściciel~(\hreftt{https://en.wikipedia.org/wiki/User_identifier}{UID}), grupa~(\hreftt{https://en.wikipedia.org/wiki/Group_identifier}{GID}), czasy dostępu \hreftt{http://leksykot.top.hell.pl/lx3/N/atime_mtime_ctime}{atime}, modyfikacji \hreftt{http://leksykot.top.hell.pl/lx3/N/atime_mtime_ctime}{mtime}, zmiany \hreftt{http://leksykot.top.hell.pl/lx3/N/atime_mtime_ctime}{ctime}~itp. --- lista zawiera tylko te~pliki i~katalogi, których atrybuty zostały zmienione od~czasu ostatniej aktualizacji klienta --- aplikacja kliencka zmieni atrybuty tych plików i~katalogów na~swoim systemie, tak, aby~były identyczne z~tymi wymienionymi na~liście.
\end{itemize}

Plik \path{changed.txt} zawiera, poza nową wartością zmienionego atrybutu pliku, również jego starą wersję, aby~móc wykryć samowolne --- niezalecane, bo~mogące prowadzić do~niechcianych konfliktów --- zmiany konfiguracji klienckiej od~czasu ostatniej aktualizacji klienta. Przed zastosowaniem zmian na~systemie klienta, \hyperref[sec:cli-app]{aplikacja kliencka} zawsze sprawdza czy~atrybuty zmienionych plików są~takie jakie zakłada \hyperref[sec:srv-app]{aplikacja serwera} i~przerywa procedurę stosowania \hyperref[sec:obraz-zmian-konfiguracji]{obrazu zmian} na~czas rozwiązania konfliktu przez administratora jeśli taki wystąpi --- dzięki temu można łatwo uniknąć dokonania nieoczekiwanych, niezamierzonych i~trudno wykrywalnych, niespójnych zmian w~systemie klienta, które mogłoby być dość trudno zauważyć i~odwrócić. W~przypadku zaistnienia sytuacji konfliktowych aplikacja kliencka wypisuje informację które atrybuty plików zostały zmienione i~kolidują z~tymi oczekiwanymi przez \hyperref[sec:srv-app]{stację wzorcową}. Przykładami sytuacji konfliktowych są~sytuacje w~których od~czasu ostatniej aktualizacji klienta:\mynobreakpar
\begin{itemize}
	\item na~systemie wzorcowym powstał śledzony plik lub~katalog, który już istnieje na~systemie klienckim i~ich atrybuty lub~zawartości są~różne,
	\item na~systemie wzorcowym i~klienckim powstał śledzony plik lub~katalog o~tej samej ścieżce o~różnych atrybutach lub~zawartości,
	\item atrybuty lub~zawartość śledzonego pliku została zmieniona zarówno na~systemie klienckim, jak i~systemie wzorcowym i~zmiany te~nie są~identyczne,
	\item z~systemu klienckiego został usunięty śledzony plik lub~katalog, a~z~systemu wzorcowego~nie,
	\item na~systemie klienckim zostały zmodyfikowane atrybuty lub~zawartość śledzonego pliku lub~katalogu, a~na~systemie wzorcowym~nie.
\end{itemize}

Pliki stanów powstałe podczas kolejnych skanowań systemu wzorcowego są~wersjonowane, tzn.~każdy taki plik stanu ma~w~swojej nazwie unikalny identyfikator będący liczbą naturalną\footnote{Na~potrzeby dalszego opisu przyjmujemy, że~$0\not\in\mathbb{N}$.}, która jest wykorzystywana przez aplikację \hyperref[sec:srv-app]{serwera} do~stworzenia \hyperref[sec:obraz-zmian-konfiguracji]{obrazu zmian konfiguracji systemu wzorcowego}. Każdy obraz zmian jest identyfikowany za~pomocą dwóch identyfikatorów stanów odpowiadających wynikom dwóch skanowań systemu wzorcowego --- najnowszego oraz tego, który opisuje deklarowany przez klienta aktualny stan konfiguracji systemu klienckiego. Przykładowo plik \hyperref[sec:obraz-zmian-konfiguracji]{obrazu zmian} \path{myscm-img.1.2.tar.gz} jest przeznaczony dla~klienta którego konfiguracja jest w~stanie~\texttt{1} i~chce zaktualizować swoją konfigurację do~stanu identyfikowanego liczbą~\texttt{2}. \hyperref[sec:cli-app]{Aplikacja kliencka} ma~opcję \hyperlinktt{itm:print-ver}{--print-ver}, która wyświetla liczbę identyfikującą aktualny stan klienta, a~\hyperref[sec:srv-app]{aplikacja serwera} ma~opcję \hyperlinktt{itm:list-db}{--list-db} do~wyświetlenia listy katalogów powstałych na~skutek skanowania stacji wzorcowej, jak i~opcję \hyperlinktt{itm:list-img}{--list-img} do~listowania wszystkich obrazów wygenerowanych do~tej pory wraz z~informacją które z~nich są~poprawnie podpisane certyfikatem cyfrowym \hyperref[sec:srv-app]{serwera}.

\begin{figure}
	\centering
	\begin{tikzpicture}[>=latex',shorten >=1pt,auto,node distance=2.5cm]
		\node[state,initial] (q0)       {$Q_0$};
		\node[state] (q1) [right of=q0] {$Q_1$};
		\node[state] (q2) [right of=q1] {$Q_2$};
		\node[state] (q3) [right of=q2] {$Q_3$};
		\node[state] (q4) [right of=q3] {$Q_4$};
		\node[state] (q5) [right of=q4] {$Q_5$};

		\path[->] (q0) edge[font=\scriptsize]        node[align=center] {skanowanie\\systemu}  (q1);
		\path[->] (q1) edge[font=\scriptsize,dashed] node[align=center] {zmiany\\konfiguracji} (q2);
		\path[->] (q2) edge[font=\scriptsize]        node[align=center] {skanowanie\\systemu}  (q3);
		\path[->] (q3) edge[font=\scriptsize,dashed] node[align=center] {zmiany\\konfiguracji} (q4);
		\path[->] (q4) edge[font=\scriptsize]        node[align=center] {skanowanie\\systemu}  (q5);
	\end{tikzpicture}
	\caption[Przykładowy ciąg 3~skanowań i~2~zmian konfiguracji systemu wzorcowego]{Przykładowy ciąg 3~skanowań i~2~zmian konfiguracji systemu wzorcowego --- linią przerywaną zobrazowano zmiany konfiguracji systemu wzorcowego, linią ciągłą skanowania systemu wzorcowego, a~wierzchołkami stany konfiguracji systemu wzorcowego}
	\label{fig:ciag-skanowan}
\end{figure}

Przywracanie poprzedniego stanu systemu wzorcowego i~klienckiego nie jest \emph{explicite} możliwe ze~względu na~to, że~stacja wzorcowa nie utrzymuje bazy różnic między plikami zmodyfikowanymi w~następujących po~sobie skanowaniach\footnote{Takie różnice plików tekstowych mogłaby tworzyć np.~komenda \hreftt{https://linux.die.net/man/1/diff}{diff}.}, a~same pliki systemu wzorcowego nie są~wersjonowane\footnote{Poza tymi, które w~konfiguracji \hyperref[sec:srv-app]{serwera} zostały oznaczone jako te, dla~których mają powstawać \emph{patche}.}, tylko ich~skrótowo opisany stan. Przywrócenie stanu systemu klienta może się odbyć przez ,,ręczne'' cofnięcie zmian na~systemie wzorcowym, przeskanowanie nowej konfiguracji wzorcowej, stworzenie nowego obrazu konfiguracji, rozpropagowanie go~do~stacji klienckich i~zastosowanie przez aplikację kliencką --- etapy skanowania, tworzenia nowego obrazu, rozpropagowanie i~zastosowanie go~przez klienta mogą być (w~zależności od~sposobu użycia aplikacji) zautomatyzowane.

Jeśli na~przykład na~systemie wzorcowym dokonano już~3~skanowań systemu, w~wyniku których powstały 3~pliki stanu, opisujące stan początkowy systemu wzorcowego $Q_0$~oraz~dokonane na~nim~2~zestawy zmian $Q_1\rightarrow Q_2$, $Q_3\rightarrow Q_4$~(patrz rys.~\ref{fig:ciag-skanowan}) i~klient nigdy do~tej pory nie synchronizował swojej konfiguracji z~systemem wzorcowym, to~\hyperref[sec:srv-app]{aplikacja serwera} może wygenerować obraz zmian który zaktualizuje system klienta ze~stanu $Q_0$ do~stanu aktualnie najnowszego, czyli w~tym przypadku do~stanu~$Q_5$. Klienci i~stacja wzorcowa na~początku całego procesu skanowań i~zmian konfiguracji powinni być tym~samym stanie~$Q_0$, co~najmniej w~zakresie synchronizowanych plików, aby~uniknąć początkowych konfliktów konfiguracji. W~szczególności systemy klienckie i~system wzorcowy powinny działać na~tej samej lub~zgodnej \href{https://en.wikipedia.org/wiki/List_of_instruction_sets}{architekturze procesora}\footnote{Architektura procesora (np.~\href{https://en.wikipedia.org/wiki/X86-64}{AMD64}, \href{https://en.wikipedia.org/wiki/X86}{x86}, \href{https://en.wikipedia.org/wiki/ARM_architecture}{ARM}) wpływa na~kod binarny programów i~bibliotek, które stacja kliencka synchronizuje ze~stacją wzorcową.} oraz~mieć zainstalowaną tę~samą dystrybucję \glslink{gnulinux}{Linux}. Wymagania te~chyba najłatwiej spełnić rozpoczynając używanie przygotowanego oprogramowania na~dowolnych, ale~takich samych, dopiero co~zainstalowanych systemach operacyjnych Linux. Przygotowane oprogramowanie można również uruchomić na~różnych systemach Linux klienta i~systemu wzorcowego, ale~powinny być to~dystrybucje podobne co~najmniej pod~względem sposobu konfiguracji systemu --- przykładem mogą być~niektóre dystrybucje wywodzące się z~systemu \debian{}, np.~\href{https://en.wikipedia.org/wiki/Ubuntu_(operating_system)}{Ubuntu}, \href{https://en.wikipedia.org/wiki/Linux_Mint}{Linux Mint}~itp.

Obraz zmian konfiguracji systemu wzorcowego nie zawiera plików zbędnych z~punktu widzenia bieżącej aktualizacji klienta, tzn.~m.in.~takich plików, których zawartość i~atrybuty nie zmieniły się~od~ostatniej aktualizacji klienta --- w~szczególności takich które zostały dodane do~systemu wzorcowego, a~następnie, przed dokonaniem skanowania systemu wzorcowego, w~wyniku którego powstał plik stanu opisujący stan systemu wzorcowego, do~którego klient chce aktualizować swoją konfigurację, zostały usunięte z~systemu wzorcowego.

%------------------------------------------------------------------------------

\section{Tworzenie obrazu zmian konfiguracji}
\label{sec:tworzenie-obrazu-konfiguracji}

Pracę z~aplikacją \hyperref[sec:srv-app]{serwera} i~\hyperref[sec:cli-app]{klienta} należy rozpocząć od~dostosowania zakresu katalogów i~plików śledzonych przez oprogramowanie systemu wzorcowego, czyli przez \hyperref[sec:srv-app]{aplikację serwera}. W~ramach przygotowanego oprogramowania dostarczono domyślną konfigurację, jednak przed skorzystaniem z~niej należy się~upewnić, że~spełnia ona~oczekiwania administratora. Poza~konfiguracją zakresu skanowanego systemu plików istnieje również oddzielna konfiguracja innych parametrów programów \hyperref[sec:cli-app]{klienta} i~\hyperref[sec:srv-app]{serwera} --- np.~ścieżka do~certyfikatu cyfrowego serwera, którym zostają podpisane \hyperref[sec:obraz-zmian-konfiguracji]{obrazy zmian konfiguracji}, ustawienia logowania zdarzeń podczas działania aplikacji, miejsce zapisu i~tymczasowego rozpakowania pobranych \hyperref[sec:obraz-zmian-konfiguracji]{obrazów zmian konfiguracji}~itp. --- ją~również warto przejrzeć i~dostosować do~własnych potrzeb.

Po~dokonaniu takiej wstępnej (meta)konfiguracji można stworzyć \hyperref[sec:obraz-zmian-konfiguracji]{obraz zmian konfiguracji wzorcowej}. Proces tworzenia takiego obrazu odbywa się w~trzech krokach:\mynobreakpar
\begin{enumerate}
	\item \hypertarget{itm:pierwsze-skanowanie} Skanowanie tej części systemu plików stacji wzorcowej, którą administrator chce przenieść na~maszyny klienckie. Skanowanie odbywa się za~pomocą skanera~\href{http://aide.sourceforge.net/}{AIDE} (patrz rozdział~\ref{sec:aide}). W~wyniku skanowania powstaje m.in.~plik stanu, tj.~plik tekstowy z~wybranymi w~konfiguracji własnościami skanowanych plików, takimi jak np.~jego wielkość, ilość zajmowanych bloków pamięci, właściciel i~grupa pliku, liczba dowiązań, czas modyfikacji~itp. Na~podstawie zawartości plików liczone są~dla~wszystkich śledzonych \href{https://en.wikipedia.org/wiki/Unix_file_types\#Regular_file}{zwykłych} (tzn.~nie specjalnych) plików wartości funkcji \href{https://en.wikipedia.org/wiki/Hash_function}{skrótu}~(np.~\href{https://en.wikipedia.org/wiki/MD5}{MD5}, \href{https://en.wikipedia.org/wiki/SHA-1}{SHA1}, \href{https://en.wikipedia.org/wiki/Cyclic_redundancy_check}{CRC32}), które wraz ze~swoimi pozostałymi atrybutami definiują referencyjny stan systemu, do~którego będą porównywane wyniki kolejnych skanowań systemu, już~po~dokonaniu zmian konfiguracji na~nim. W~przypadku zmiany zawartości śledzonego pliku, jego wartość funkcji skrótu zmienia się, co~zostaje odnotowane przez \hyperref[sec:aide]{AIDE} jako zmiana stanu systemu wzorcowego. Możliwe jest wybranie kilku(nastu) funkcji skrótu, co~drastycznie zmniejsza prawdopodobieństwo kolizji wartości funkcji skrótu. Ustawienie parametrów skanowania, w~tym m.in.~zakresu skanowanych katalogów i~wybór funkcji skrótu, odbywa się za~pomocą konfiguracji programu~\href{http://aide.sourceforge.net/}{AIDE}, której składnia została opisana w~rozdziale~\ref{sec:aide} dotyczącym implementacji projektu.
	\item \hypertarget{itm:dokonanie-zmian} Dokonanie zmian w~konfiguracji maszyny wzorcowej, tak, jakby była maszyną kliencką, której konfigurację administrator chce dostosować do~systemu wzorcowego. Wszystkie śledzone pliki i~katalogi maszyny wzorcowej, które uległy zmianie lub~których śledzone własności zostały zmienione oraz~wszystkie nowe pliki i~katalogi, które zostały dodane do~śledzonych katalogów od~czasu ostatniego skanowania systemu wzorcowego, zostają dołączone do~\hyperref[sec:obraz-zmian-konfiguracji]{archiwum plików} tworzonego podczas ostatniego --- \hyperlink{itm:stworzenie-obrazu-konfiguracji}{trzeciego} etapu tworzenia obrazu zmian konfiguracji. Pliki, które zostały usunięte z~systemu wzorcowego i~pliki których atrybuty zostały zmienione od~czasu ostatniej aktualizacji klienta, również zostają dodane do~takiego archiwum w~odpowiednio --- liście ścieżek plików usuniętych zapisanej w~pliku \path{removed.txt} i~liście ścieżek zmodyfikowanych plików i~ich atrybutów w~pliku \path{changed.txt}. Pozostałe, niezmienione w~żaden sposób pliki zostaną zignorowane, tzn.~nie znajdą się one w~wynikowym \hyperref[sec:obraz-zmian-konfiguracji]{obrazie zmian konfiguracji stacji wzorcowej}.
	\item \hypertarget{itm:stworzenie-obrazu-konfiguracji} Stworzenie dla~maszyn klienckich archiwum plików będącego właściwym \hyperref[sec:obraz-zmian-konfiguracji]{obrazem zmian konfiguracji systemu wzorcowego} (patrz rozdział~\ref{sec:obraz-zmian-konfiguracji}) na~podstawie porównania dwóch plików stanów powstałych w~wyniku przeprowadzonych skanowań systemu wzorcowego --- najnowszego dostępnego na~systemie wzorcowym i~aktualnego pliku stanu klienta. Stworzone archiwum plików może być udostępnione maszynie klienckiej przez stację wzorcową przez sieć lub~alternatywnie administrator może przenieść taki obraz na~maszynę klienta w~dowolny inny sposób (patrz rozdział~\ref{sec:przeslanie-obrazu-konfiguracji}). Zastosowanie obrazu konfiguracji na~maszynie klienckiej zostało opisane w~rozdziale~\ref{sec:zastosowanie-obrazu-konfiguracji}.
\end{enumerate}

\begin{figure}
	\centering
	\begin{tikzpicture}[>=latex',shorten >=1pt,auto,node distance=3.1cm]
		\node[initial,state] (q0)       {$Q_0$};
		\node[state] (q1) [right of=q0] {$Q_1$};
		\node[state] (q2) [right of=q1] {$Q_2$};
		\node[state] (q3) [right of=q2] {$Q_3$};
		\node[state] (q4) [right of=q3] {$Q_4$};

		\path[->] (q0) edge[font=\scriptsize]            node[align=center] {skanowanie\\systemu}  (q1);
		\path[->] (q1) edge[font=\scriptsize,dashed]     node[align=center] {zmiany\\konfiguracji} (q2);
		\path[->] (q2) edge[font=\scriptsize]            node[align=center] {skanowanie\\systemu}  (q3);
		\path[->] (q3) edge[font=\scriptsize,dashed]     node[align=center] {zmiany\\konfiguracji} (q4);
		\path[->] (q4) edge[font=\scriptsize,bend left]  node[align=center] {skanowanie\\systemu}  (q3);
		\path[->] (q3) edge[font=\scriptsize,loop below] node[align=center] {tworzenie\\obrazu zmian\\konfiguracji} (q3);
	\end{tikzpicture}
	\caption[Kompletny cykl skanowań systemu wzorcowego]{Kompletny cykl skanowań systemu wzorcowego, gdzie $Q_0=\{\neg k_1, \neg k_2, k_3\}$, $Q_1=\{k_1, \neg k_2, k_3\}$, $Q_2=\{k_1, \neg k_2, \neg k_3\}$, $Q_3=\{k_1, k_2, k_3\}$, $Q_4=\{k_1, k_2, \neg k_3\}$ a~$k_1$, $k_2$ i~$k_3$ oznaczają odpowiednio, że~\begin{inparaenum}[(1)]\let\refstepcounter\stepcounter \protect\item istnieje pliku stanu systemu wzorcowego, utworzony podczas pierwszego skanowania~go \protect\item istnieje porównawczy plik stanu systemu wzorcowego, tworzony podczas kolejnych skanowań \protect\item najnowszy plik stanu jest aktualny \end{inparaenum}}
	\label{fig:cykl-skanowan}
\end{figure}

Wymienione trzy kroki tworzenia \hyperref[sec:obraz-zmian-konfiguracji]{obrazu zmian konfiguracji systemu wzorcowego} zobrazowano na~poglądowym rysunku~\ref{fig:cykl-skanowan} przedstawiającym maszynę stanów działania aplikacji z~wyróżnionymi pięcioma stanami --- $Q_0$, $Q_1$, $Q_2$, $Q_3$ i~$Q_4$. Każdy stan został określony przez trzy zmienne logiczne --- $k_1$, $k_2$ i~$k_3$. Zmienna $k_1$~oznacza istnienie pliku stanu systemu wzorcowego, utworzonego podczas pierwszego skanowania~go. Zmienna $k_2$~oznacza istnienie dowolnego pliku stanu systemu wzorcowego, utworzonego podczas dowolnego z~kolejnych jego skanowań. Zmienna $k_3$~oznacza, że~najnowszy plik stanu jest aktualny, tzn.~że~po~dokonaniu zmian w~konfiguracji wzorcowej, zostało uruchomione skanowanie stacji wzorcowej, w~czasie którego powstał nowy, zaktualizowany plik stanu konfiguracji systemu wzorcowego\footnote{Założono, że~$k_3\in Q_0$, tzn.~że~jeśli nie dokonano jeszcze drugiego skanowania systemu, to~najnowszy plik stanu jest pusty i~aktualny.}. Krok~\hyperlink{itm:pierwsze-skanowanie}{1} odpowiada przejściu między stanami $Q_0\rightarrow Q_1$, $Q_2\rightarrow Q_3$ lub~$Q_4\rightarrow Q_3$, krok~\hyperlink{itm:dokonanie-zmian}{2} przejściu między stanami $Q_1\rightarrow Q_2$ lub~$Q_3\rightarrow Q_4$, a~krok~\hyperlink{itm:dokonanie-zmian}{3} przejściu to~pętla~$Q_4\rightarrow Q_4$. Pozostałe stany pominięte na~rysunku~\ref{fig:cykl-skanowan} --- tj.~stany~$\{\neg k_1,k_2,k_3\}$, $\{\neg k_1,k_2,\neg k_3\}$ i~$\{\neg k_1,\neg k_2,\neg k_3\}$ --- są~traktowane przez \hyperref[sec:srv-app]{aplikację serwera} tworzącą obraz zmian konfiguracji jako stany błędne, w~których administrator musi podjąć własne działania, aby~przejść do~jednego z~poprawnych stanów, tj.~$Q_0$, $Q_1$, $Q_2$, $Q_3$ lub~$Q_4$. Wygenerowanie \hyperref[sec:obraz-zmian-konfiguracji]{obrazu konfiguracji wzorcowej} jest możliwe tylko w~stanie~$Q_3$, gdy~najnowszy plik stan jest aktualny, tzn.~że~po~dokonaniu wszystkich zmian w~konfiguracji systemu wzorcowego zostało uruchomione jego skanowanie. \hyperref[sec:srv-app]{Aplikacja serwera} przed wygenerowaniem zmian obrazu konfiguracji wymusza sprawdzenie czy~plik stanu jest aktualny --- jeśli nie jest, to~zostaje wypisany komunikat o~konieczności ponownego skanowania systemu wzorcowego. Takie wymuszenie jest konieczne, m.in.~po to, aby~nie dopuścić do~stworzenia \hyperref[sec:obraz-zmian-konfiguracji]{obrazu zmian} z~nowszymi wersjami spakowanych plików niż te~na~które wskazywałby identyfikator przydzielony takiemu \hyperref[sec:obraz-zmian-konfiguracji]{obrazowi zmian}.

%------------------------------------------------------------------------------

\section{Przesłanie obrazu zmian konfiguracji}
\label{sec:przeslanie-obrazu-konfiguracji}

\hyperref[sec:obraz-zmian-konfiguracji]{Obraz zmian konfiguracji} utworzony przez stację wzorcową może być przeniesiony na~stację klienta na~dwa sposoby --- ręcznie --- przenosząc \hyperref[sec:obraz-zmian-konfiguracji]{obraz zmian konfiguracji} na~system klienta np.~przez~\href{https://en.wikipedia.org/wiki/Network_File_System}{NFS} (\emph{Network File System}), na~dowolnym nośniku danych, np.~\href{https://en.wikipedia.org/wiki/USB_flash_drive}{pamięci USB} (\hrefemph{http://sjp.pwn.pl/poradnia/haslo/Odmieniamy-pendrive;11159.html}{pendrivie}), \href{https://en.wikipedia.org/wiki/Memory_card}{karcie pamięci}, \href{https://en.wikipedia.org/wiki/Hard_disk_drive\#External_hard_disk_drives}{zewnętrznym dysku twardym}, płycie~\href{https://en.wikipedia.org/wiki/Compact_disc}{CD}/\href{https://en.wikipedia.org/wiki/DVD}{DVD}~\href{https://en.wikipedia.org/wiki/USB_mass_storage_device_class}{itp.} --- lub~przez sieć --- pobierając \hyperref[sec:obraz-zmian-konfiguracji]{obraz zmian konfiguracji} od~innego klienta przez \sftp{}.

Wariant przesłania obrazu zmian konfiguracji przez sieć jest elastyczny, ponieważ obraz może być udostępniony przez klientów korzystając z~dowolnego protokołu zdolnego do~przesyłania plików, implementowanego przez klienta. W~implementacji przygotowanej w~ramach tej pracy klient implementuje tylko protokół \sftp{} (\emph{SSH File Transfer Protocol}), jednak interfejs aplikacji jest dostosowany do~rozbudowania aplikacji klienckiej o~kolejne protokoły sieciowe. Domyślna konfiguracja aplikacji klienckiej korzysta ze~standardowego dla~tego protokołu portu \href{https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml?search=22}{TCP~22}. Protokół \sftp{} jest protokołem bezpiecznym, tzn.~gwarantuje, że~otrzymane dane pochodzą od~serwera, do~którego klient zgłosił się po~obraz konfiguracji, a~ponadto przesyłane dane są~szyfrowane, co~może być przydatne jeśli w~przesyłanej konfiguracji znajdują się dane wrażliwe, takie jak np.~hasła, klucze prywatne, dane personalne~itp.

%------------------------------------------------------------------------------

\section{Zastosowanie obrazu zmian konfiguracji}
\label{sec:zastosowanie-obrazu-konfiguracji}

Maszyna kliencka pobiera \hyperref[sec:obraz-zmian-konfiguracji]{obraz zmian konfiguracji stacji wzorcowej} od~innego klienta korzystając z~protokołu \sftp{}. \hyperref[sec:cli-app]{Aplikacja kliencka} nie ogranicza możliwości pobierania \hyperref[sec:obraz-zmian-konfiguracji]{obrazu zmian} tylko z~klientów, ale w~zamyśle projektowanego protokołu było przerzucenie tego zadania właśnie na~nich. Poza obrazem zmian klient pobiera \href{https://superuser.com/a/426345/139893}{podpis cyfrowy} pobranego obrazu jeśli został on wygenerowany przez \hyperref[sec:srv-app]{aplikację serwera} i~udostępniony przez klienta. W~przypadku protokołu \sftp{} krok ten jest zbędny, ponieważ protokół ten zapewnia zarówno uwierzytelnienie jak i~integralność przesyłanych danych. Oddzielny plik z~podpisem cyfrowym może być użyteczny jeśli obraz zmian jest przenoszony na~system klienta w~inny sposób, np.~na~dowolnym zewnętrznym nośniku danych.

Zastosowanie \hyperref[sec:obraz-zmian-konfiguracji]{obrazu zmian} przez system maszyny klienckiej odbywa się za~pomocą opcji \hyperlinktt{itm:apply-img}{--apply-img} przygotowanej \hyperref[sec:cli-app]{aplikacji klienckiej}. Użycie tej opcji powoduje zweryfikowanie podpisu cyfrowego \hyperref[sec:obraz-zmian-konfiguracji]{obrazu zmian konfiguracji}, sprawdzenie jego poprawności, rozpakowanie go i~skopiowanie w~odpowiednie miejsca systemu plików. W~przypadku wykrycia konfliktów aplikacja wymusza na~administratorze ich~rozwiązanie. Dokładniejsza instrukcja użycia aplikacji klienckiej w~celu zastosowania \hyperref[sec:obraz-zmian-konfiguracji]{obrazu zmian} została opisana w~rozdziale~\ref{sec:cli-app}.

%------------------------------------------------------------------------------

\section{Bezpieczeństwo protokołu}
\label{sec:security}

Wydaje się, że~uwzględnienie aspektów bezpieczeństwa jest ważne dla~powodzenia każdego projektu protokołu sieciowego, szczególnie takiego, który umożliwia serwerowi na~zarządzanie konfiguracją dziesiątek, setek lub~tysięcy klientów. Zaniedbanie bezpieczeństwa protokołu lub~jego wadliwa implementacja może umożliwić atakującemu na~przejęcie kontroli nad~wszystkimi klientami, np.~przez przygotowanie klientom złośliwych aktualizacji oprogramowania lub~konfiguracji.

Istnieje wiele powszechnych technik ataków protokołów sieciowych. Jednymi z~najpopularniejszych~są:\mynobreakpar

\begin{itemize}
	\item \hypertarget{itm:mitm} \protect\hrefemph{https://en.wikipedia.org/wiki/Man-in-the-middle_attack}{Man In The Middle~(MITM)} --- technika ataku polegająca na~tym, że~atakujący nasłuchuje komunikacji między klientem i~serwerem i~modyfikuje przesyłane dane albo~sam tworzy nowe i~,,wstrzykuje'' je~między pakiety klienta i~serwera.
	\item \hrefemph{https://en.wikipedia.org/wiki/Replay_attack}{Replay Attack} --- technika ataku polegająca na~tym, że~poprawne (\href{https://www.ibm.com/support/knowledgecenter/en/SSAW57_8.0.0/com.ibm.websphere.nd.doc/info/ae/ae/rwbs_secconsider6wssec.html}{nawet} podpisane cyfrowo) dane podsłuchane w~czasie wcześniejszych sesji komunikacyjnych między klientem i~serwerem, są~powtarzane po~jakimś czasie w~innym kontekście komunikacyjnym\footnote{Technika ta~może być szczególnie \href{https://en.wikipedia.org/wiki/Rolling_code}{dotkliwa} np.~dla~posiadaczy samochodów z~podatnymi układami \href{https://en.wikipedia.org/wiki/Remote_keyless_system}{zdalnego zamka centralnego} samochodu, posiadaczy bram garażowych sterowanych zdalnie~itp.}.
\end{itemize}

W~celu uniknięcia podatności protokołu na~wymienione i~inne, popularne rodzaje ataków, należy zagwarantować bezpieczeństwo protokołu co~najmniej pod~względem uwierzytelnienia serwera i~integralności komunikacji. Poufność komunikacji nie jest zazwyczaj konieczna, ponieważ konfiguracja klientów zazwyczaj nie jest poufna, a~oprogramowanie przesyłane do~klientów jest powszechnie dostępne w~\href{https://wiki.archlinux.org/index.php/official_repositories}{repozytoriach pakietów} różnych dystrybucji \glslink{gnulinux}{Linux}. % W~przypadku potrzeby szyfrowania przesyłanego obrazu klient może wybrać połączenie przez protokół \sftp{} gwarantujący, poza uwierzytelnieniem serwera i~integralnością komunikacji, również poufność.

Uwierzytelnienie serwera przez klienta jest krytyczne dla~bezpieczeństwa protokołu, ponieważ gdyby nie ono, to~atakujący mógłby podszywać się za~serwer i~przesłać klientowi dowolną konfigurację i~oprogramowanie. Warto zauważyć, że~nawet gdyby komunikacja była szyfrowana, ale nie uwierzytelniana, to~atakujący mógłby również podjąć próby ataku \emph{replay attack}. W~celu uniknięcia tego problemu wykorzystano certyfikat \href{https://en.wikipedia.org/wiki/X.509}{X.509} dla~systemu wzorcowego będącego jednocześnie serwerem udostępniającym swoją konfigurację systemom klienckim~\cite{wiki:x509}.

Wygenerowanie takiego cyfrowego certyfikatu wymaga podpisania go~przez centrum certyfikacji~(\gls{ca})~\cite{wiki:ca}. Ze~względu na~brak potrzeby posiadania w~trakcie implementacji certyfikatu podpisanego przez uznane~\gls{ca}, a~także ze~względu na~względnie duże koszty finansowe i~czasowe z~tym związane, w~czasie implementacji wykorzystano certyfikat podpisany przez siebie~(\hrefemph{https://en.wikipedia.org/wiki/Self-signed_certificate}{self-signed certificate}). Konfiguracja klienta pozwala w~trybie \texttt{debug} zaufać takiemu certyfikatowi. Oczywiście, w~przypadku wdrożenia projektu, należałoby postarać się o~certyfikat podpisany przez uznany~\gls{ca}.

Wygenerowanie i~podpisanie certyfikatu zostało wykonane z~użyciem \gls{openssl}. Listing~\ref{lst:openssl-gencert} przedstawia jak wygenerowano publiczny i~prywatny klucz \gls{rsa} o~długości 4096~bitów, a~następnie, jak wykorzystano klucz prywatny do~wygenerowania żądania podpisania certyfikatu (\hrefemph{https://en.wikipedia.org/wiki/Certificate_signing_request}{Certificate Signing Request}) i~na jego podstawie jak podpisano certyfikat~X.509~\cite{openssl-cookbook,wiki:csr}.

\begin{minipage}{\linewidth} % https://tex.stackexchange.com/questions/73231/avoid-page-breaks-in-lstlistings
\begin{lstlisting}[language=,caption={Ciąg komend służący wygenerowaniu i~podpisaniu cyfrowego certyfikatu X.509},label=lst:openssl-gencert]
openssl genrsa -aes256 -out certificate.key 4096
openssl req -new -key certificate.key -out request.csr
openssl req -new -config request.cnf -key fd.key -out request.csr
openssl x509 -req -days 365 -in request.csr -signkey certificate.key -out certificate.pem
\end{lstlisting}
\end{minipage}

Listing~\ref{lst:openssl-request-config} przedstawia przykładową zawartość pliku \path{request.cnf}, który służy do~konfiguracji żądania podpisania certyfikatu. Certyfikat jest zaufany jeśli istnieje ważny\footnote{Tzn.~żaden certyfikat w~ciągu nie stracił ważności.} ciąg podpisów cyfrowych, który zaczyna się~od~\gls{ca}, a~kończy na~naszym certyfikacie. Aby sprawdzić czy~certyfikat jest zaufany przez nasz system, wystarczy wydać komendę:\mynobreakpar

\begin{center}
	\texttt{openssl verify -verbose certificate.pem}
\end{center}

Aby~\href{http://stackoverflow.com/questions/10782826/digital-signature-for-a-file-using-openssl}{podpisać} skrót~\href{https://en.wikipedia.org/wiki/SHA-2}{SHA256} pliku \path{config.img} za~pomocą certyfikatu \path{certificate.pem} i~zapisać wynik takiej operacji do~pliku~\path{signature} wystarczy wydać komendę\footnote{W~zaimplementowanej aplikacji operacja podpisania obrazu konfiguracji wzorcowej jest wykonywana z~poziomu biblioteki OpenSSL, a~nie z~poziomu linii komend.}:\mynobreakpar

\begin{center}
	\texttt{openssl dgst -sha256 -sign certificate.pem -out signature config.img}
\end{center}

Obraz konfiguracji podpisany certyfikatem, poza uwierzytelnieniem gwarantuje również integralność pliku, tzn.~gwarantuje, że~nikt go nie zmodyfikował przeprowadzając atak \emph{\hyperlink{itm:mitm}{Man In the Middle}}.

\begin{lstlisting}[language=,caption={Plik z~konfiguracją cyfrowego certyfikatu X.509},label=lst:openssl-request-config]
[req]
default_bits       = 4096
default_keyfile    = certificate.key
prompt             = no
distinguished_name = dn
req_extensions     = ext
input_password     = minipw

[dn]
CN                 = Patryk
OU                 = MiNI
emailAddress       = bezap@student.mini.pw.edu.pl
O                  = PW
L                  = Warsaw
ST                 = Masovian
C                  = PL

[ext]
subjectAltName     = DNS:www.mini.pw.edu.pl,DNS:*.mini.pw.edu.pl
\end{lstlisting}

Uruchamiając aplikacje dołączone do~niniejszej pracy z~domyślną konfiguracją należy spodziewać się tego, że~podczas generowania \hyperref[sec:obraz-zmian-konfiguracji]{obrazu zmian konfiguracji wzorcowej} oraz~podczas jego weryfikacji pojawi się monit o~podanie hasła \texttt{minipw} dla~domyślnego, testowego certyfikatu cyfrowego~(por. listing~\ref{lst:openssl-request-config}).

\end{document}
