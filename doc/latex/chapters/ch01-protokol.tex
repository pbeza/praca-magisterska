\documentclass[thesis]{subfiles}

\begin{document}

\chapter{Protokół komunikacji}
\label{chapter:protokol}

W~tym rozdziale opisano sieciowy protokół komunikacji między serwerem i~klientem.

\section{Bezpieczeństwo}

Uwzględnienie bezpieczeństwa protokołu jest krytyczne dla projektu, ponieważ umożliwia on~serwerowi na zarządzanie konfiguracją wszystkich klientów. Zaniedbanie bezpieczeństwa protokołu lub~jego wadliwa implementacja, umożliwiłaby atakującemu system, na~przejęcie kontroli nad~wszystkimi klientami, np.~przez przesłanie klientom złośliwych aktualizacji oprogramowania lub~konfiguracji.

Umożliwienie przejęcia kontroli nad wszystkimi klientami byłoby prawdopodobnie najgorszym z~możliwych scenariuszy zarówno dla użytkowników jak i~administratora atakowanej sieci, jednak niedbała implementacja protokołu mogłaby umożliwiać również wiele innych rodzajów ataków, np. \emph{replay attack} i~\emph{man in the middle~(MITM)}. W~celu uniknięcia podatności protokołu na~wymienione i~inne, popularne rodzaje ataków, należy zagwarwantować bezpieczeństwo protokołu co~najmniej pod względem:
\begin{enumerate}
\item uwierzytelnienia co~najmniej serwera,
\item poufności komunikacji,
\item integralności komunikacji.
\end{enumerate}
W~celu maksymalnego zaostrzenia rygorów bezpieczeństwa protokołu, do powyższych własności można dodać również inne, w~szczególności, własność \glslink{pfs}{\emph{Perfect Forward Secrecy}~(\texttt{PFS})} (patrz rozdział~\ref{sec:pfs}).

W~kolejnych podrozdziałach zostaną opisane metody, które zostały wykorzystane do~zapewnienia poszczególnych elementów, składających się na~bezpieczeństwo protokołu. Wszystkie opisane dalej algorytmy i~metody kryptograficzne zostały wykorzystane przez niniejszy projekt przez wykorzystanie popularnej, otwartoźródłowej biblioteki kryptograficznej~\glstt{openssl}, implementującej protokół kryptograficzny~\glstt{ssl/tls}.

\subsection{SSL/TLS}
\label{sec:ssl-tls}

Protokół \glstt{ssl/tls} jest bardzo elastyczny pod względem doboru algorytmów i~metod kryptograficznych. Elastyczność objawia się nie tylko możliwością skonfigurowania konkretnych algorytmów, które posłużą do~zapewnienia uwierzytelnienia, poufności, integralności komunikacji i~ustalenia klucza sesji, ale również możliwością zdefiniowania za pomocą słów kluczowych, zbioru algorytmów spośród których serwer i~klient, podczas negocjacji w~ramach \emph{handshake'u} sesji \glstt{ssl/tls}, wybierają jeden, najsilniejszy z~tych, które wspierają.

Przykładowo, jeśli celem jest dopuszczenie do~użytku wyłącznie zestawów metod kryptograficznych używających algorytmu \glslink{dh}{Diffiego-Hellmana} do~wymiany klucza, a~do szyfrowania szyfru blokowego~\texttt{AES}, to filtr będzie miał postać napisu \texttt{DH+AES @STRENGTH}. Słowo kluczowe \texttt{@STRENGTH} służy do posortowania wynikowych zestawów metod kryptograficznych nierosnąco (a~nie ściśle malejąco) względem bezpieczeństwa.

Aby przekonać się jakie algorytmy zostaną zwrócone dla danego filtru, nie~trzeba korzystać z~\glslinktt{api}{API} biblioteki \glstt{openssl}. Wystarczy nam do~tego konsola, co~prezentuje listing~\ref{openssl-console-filter}.\\

\begin{lstlisting}[numbers=none,language=bash,caption={Wynik filtrowania zestawów algorytmów w~konsoli za~pomocą \glstt{openssl}},label=openssl-console-filter]
$ openssl ciphers -v 'DH+AES @STRENGTH'
AES256-GCM-SHA384   TLSv1.2 Kx=RSA  Au=RSA  Enc=AESGCM(256)  Mac=AEAD
AES256-SHA256       TLSv1.2 Kx=RSA  Au=RSA  Enc=AES(256)     Mac=SHA256
AES256-SHA          SSLv3 Kx=RSA    Au=RSA  Enc=AES(256)     Mac=SHA1
AES128-GCM-SHA256   TLSv1.2 Kx=RSA  Au=RSA  Enc=AESGCM(128)  Mac=AEAD
AES128-SHA256       TLSv1.2 Kx=RSA  Au=RSA  Enc=AES(128)     Mac=SHA256
AES128-SHA          SSLv3 Kx=RSA    Au=RSA  Enc=AES(128)     Mac=SHA1
\end{lstlisting}

Filtr złożony ze~słów kluczowych, wykorzystany w~implementacji projektu zarówno dla serwera, jak i~klienta, został przedstawiony na listingu~\ref{openssl-filter}. Filtr ten jest bardzo restrykcyjny, tak, aby zapewnić~\glstt{pfs}. Wykrzyknik w filtrze pełni rolę operatora logicznego~\texttt{not}.\\

\begin{lstlisting}[numbers=none,caption={Filtr \texttt{OpenSSL} dla algorytmów użytych w~projekcie},label=openssl-filter]
kEECDH+ECDSA kEECDH kEDH +SHA !aNULL !eNULL !LOW !3DES !MD5 !EXP !DSS !PSK !SRP !kECDH !CAMELLIA !IDEA !RC4 !SEED @STRENGTH
\end{lstlisting}

Pełny opis słów kluczowych można znaleźć w~dokumentacji \glstt{openssl} oraz w~darmowej, regularnie aktualizowanej elektronicznej książce\footnote{Jest ona częścią większej książki pt.~\emph{,,Bulletproof SSL and TLS"}~(ISBN:~978-1907117046). Projekt \glstt{openssl} ma~raczej opinię słabo udokumentowanego, dlatego te~książki mają spore znaczenie praktyczne.} pt.~\emph{,,OpenSSL Cookbook"} autorstwa \emph{Ivana Ristić'a}, polecanej na~oficjalnej stronie internetowej projektu~\glstt{openssl}~\cite{openssl-cookbook-suites}.

\subsection{Uwierzytelnienie}

Uwierzytelnienie serwera przez klienta jest krytyczne dla~bezpieczeństwa protokołu. Gdyby nie ono, to~atakujący mógłby podawać się za~serwer i~przesłać klientowi dowolną konfigurację i~oprogramowanie. Gdyby komunikacja była szyfrowana, ale nieuwierzytelniona, to atakujący mógłby również podjąć próby ataku \emph{replay attack}. W~celu uniknięcia tego problemu wykorzystano certyfikat \texttt{X.509} dla serwera~\cite{wiki:x509}.

Wygenerowanie takiego certyfikatu wymaga podpisania przez centrum certyfikacji~(\glstt{ca})~\cite{wiki:ca}. Ze~względu na~brak potrzeby posiadania w~trakcie implementacji certyfikatu podpisanego przez uznane \glstt{ca}, a~także ze względu na~względnie duże koszty finansowe i~czasowe z~tym związane, w czasie implementacji wykorzystano certyfikat podpisany przez siebie~(ang.~\emph{self-signed certificate}). Konfiguracja klienta pozwala w~trybie \texttt{debug} zaufać takiemu certyfikatowi. Oczywiście, w~przypadku wdrożenia projektu, należałoby postarać się o~certyfikat podpisany przez uznany~\glstt{ca}.

Wygenerowanie i~podpisanie certyfikatu zostało wykonane z~użyciem \glstt{openssl}. Listing~\ref{openssl-gencert} przedstawia jak wygenerować klucze publiczny i~prywatny \glstt{rsa} o~długości 4096~bitów, a~następnie, jak wykorzystać klucz prywatny do~wygenerowania żądania podpisania certyfikatu (ang.~\emph{Certificate signing request}) i~na jego podstawie podpisać certyfikat~\texttt{X.509}~\cite{openssl-cookbook,wiki:csr}.

\begin{lstlisting}[numbers=none,caption={Wygenerowanie i~podpisanie certyfikatu \texttt{X.509}},label=openssl-gencert]
$ openssl genrsa -aes256 -out rsa_aes256_4096.key 4096
$ openssl req -new -key rsa_aes256_4096.key -out request.csr
$ openssl req -new -config request.cnf -key fd.key -out request.csr
$ openssl x509 -req -days 365 -in request.csr -signkey rsa_aes256_4096.key -out certificate.crt
\end{lstlisting}

Przykładowa zawartość pliku \path{request.cnf}, który służy do~konfiguracji żądania podpisania certyfikatu przedstawia listing~\ref{openssl-request-config}.

\begin{lstlisting}[numbers=none,caption={Plik z~konfiguracją certyfikatu \texttt{X.509}},label=openssl-request-config]
[req]
default_bits       = 4096
default_keyfile    = rsa_aes256_4096.key
prompt             = no
distinguished_name = dn
req_extensions     = ext
input_password     = minipw

[dn]
CN                 = Patryk
OU                 = MiNI
emailAddress       = patryk.beza@gmail.com
O                  = PW
L                  = Warsaw
ST                 = Masovian
C                  = PL

[ext]
subjectAltName     = DNS:www.mini.pw.edu.pl,DNS:*.mini.pw.edu.pl
\end{lstlisting}

Aby sprawdzić czy~certyfikat jest przez nas zaufany, wystarczy wydać komendę:
\begin{lstlisting}[numbers=none]
$ openssl verify -verbose certificate.crt
\end{lstlisting}

\subsection{Poufność}

Poufność komunikacji nie jest tak krytyczna jak uwierzytelnienie serwera, jednak jest również istotna, ponieważ atakujący podsłuchujący komunikację między serwerem i~klientami, mógłby się~wiele dowiedzieć o~wersjach i~konfiguracji oprogramowania klientów. Dzięki zdobytej wiedzy, atakujący mógłby przeanalizować np.~czy oprogramowanie klientów jest przestarzałe i~podatne na~ataki, czy konfiguracja oprogramowania pozwala na~wykorzystanie luk bezpieczeństwa.

Komunikacja między serwerem i~klientem jest szyfrowana symetrycznym, blokowym szyfrem \texttt{AES} z~kluczem 256-bitowym~(preferowane podczas negocjacji) lub 128-bitowym. Dla~obu długości klucza możliwe jest działanie w~trybie~\texttt{GCM}~(preferowane) lub~domyślnym.

\subsection{Integralność}

Integralność komunikacji jest konieczna, aby zapobiec atakom typu \emph{man in the middle}, polegającym na~modyfikacji komunikacji między serwerem i~klientem, niezależnie od~tego czy jest ona~szyfrowana czy nie.

Algorytm używany do~sprawdzania integralności wiadomości jest negocjowany tak jak algorytmy używane do~zapewnienia uwierzytelnienia, szyfrowania i~ustalenia wspólnego klucza dla symetrycznego algorytmu szyfrującego komunikację (patrz rozdział~\ref{sec:ssl-tls}). Możliwe algorytmy to: \texttt{AEAD}\footnote{Ściśle rzecz biorąc tryb \texttt{AEAD} jest trybem wiązania bloków zaszyfrowanych w~blokowym algorytmie szyfrującym~\texttt{AES~GCM}, więc integralność jest zapewniana ,,przy okazji" na~etapie szyfrowania komunikacji.}, \texttt{SHA384}, \texttt{SHA256} i~\texttt{SHA1}.

\subsection{Perfect Forward Secrecy}
\label{sec:pfs}

Własność \glslink{pfs}{\emph{Perfect Forward Secrecy}~(\texttt{PFS})} umożliwia zachowanie poufności komunikacji nawet jeśli atakujący zapisał całą zaszyfrowaną komunikację między serwerem i~klientem, a~po~jakimś czasie uzyskał klucze prywatne obu stron komunikacji. Własność ta~wiąże się ze sposobem ustalenia sesyjnego klucza dla~symetrycznego szyfru zapewniającego poufność komunikacji (takiego jak np.~\texttt{AES}).

W~uproszczeniu problem polega na tym, że~w~przypadku wykorzystania~\glstt{rsa} do~ustalenia klucza sesyjnego dla~symetrycznego algorytmu szyfrującego, strona~A komunikacji, używa klucza publicznego strony~B do~zaszyfrowania losowego klucza sesyjnego\footnote{W~rzeczywistości \emph{Pre-Master Key}, z~którego dopiero jest wyliczany ostateczny klucz sesyjny.}~i wysyła go~do~B. Po~skompromitowaniu klucza prywatnego strony~B, atakujący może odczytać całą komunikację między stronami A~i~B, deszyfrując najpierw klucz sesyjny, a~następnie całą komunikację między serwerem i~klientem.

\glstt{pfs} radzi sobie z~tym problemem rezygnując z~przesyłania zaszyfrowanego klucza sesyjnego, wprowadzając zamiast tego efemeryczny algorytm Diffiego-Hellmana w~postaci klasycznej~(\glslinktt{dh}{EDH})~i krzywoeliptycznej~(\texttt{ECDHE})~\cite{mimuw-ssl-w04,openssl-cookbook-suites}. Efemeryczny algorytm Diffiego-Hellmana różni się od~nieefemerycznego tym, że~w~efemerycznej wersji algorytmu parmetry algorytmu nie~są stałe, tzn. np.~nie są zapisane w~certyfikacie. Wersja krzywoliniowa co do~pomysłu nie różni się istotnie od~wersji klasycznej, tylko działa na krzywych eliptycznych. Wersja krzywoeliptyczna charakteryzuje się~lepszą wydajnością na~większości procesorów ze~względu na~fakt, że~do zapewnienia takiego samego poziomu bezpieczeństwa jakie gwarantuje~\gls{rsa} z~kluczem o~długości 3072~bitów, potrzeba krzywoeliptycznego odpowiednika o~długości 256~bitów.

Poniżej został przedstawiony schemat przebiegu klasycznego algorytmu Diffiego-Hellmana.

\begin{enumerate}
\item A i B uzgadniają skończoną, cykliczną groupę~$G$ rzędu~$p$, gdzie $p$ jest liczbą pierwszą i~generator $g$ tej grupy. Atakujący może znać~$g$ oraz~$p$.
\item A wybiera tajną liczbę całkowitą $1 \leq a < n$ i~wysyła do~B liczbę $A=g^a \pmod{p}$.
\item B wybiera tajną liczbę całkowitą $1 \leq b < n$ i~wysyła do~A liczbę $B=g^b \pmod{p}$.
\item A oblicza $s=B^a \pmod{p}$.
\item B oblicza $s=A^b \pmod{p}$.
\item A i B współdzielą tajną liczbę~$s$.
\end{enumerate}

Podsłuchujący atakujący, aby~poznać liczbę $s$, musiałby rozwiązać tzw.~problem Diffiego-Hellmana, który jest problemem równie trudnym w~sensie teorii złożoności, jak problem algorytmu dyskretnego. Liczby $a$ i~$b$ są~przed wysłaniem podpisywane kluczem prywantym w celu uniknięcia ataku~\emph{man in the middle}.

Ilustracja~\ref{fig:dh} obrazowo przedstawia w~jaki sposób działa algorytm Diffiego-Hellmana.

\begin{figure}[hb]
	\centering
	\includegraphics[width=0.3\textwidth]{img/Diffie-Hellman_Key_Exchange.pdf}
	\caption{Zobrazowanie działania algorytmu Diffiego-Hellmana (źródło: Wikipedia)}
	\label{fig:dh}
\end{figure}

\end{document}
