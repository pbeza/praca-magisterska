\documentclass[11pt,a4paper]{article}
\usepackage[main=english]{babel}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\usepackage[parfill]{parskip}[2001/04/09]
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{mathptmx}

\linespread{1.15}
\setlength{\parindent}{0cm}

\pagestyle{empty} % no page numbers!
\usepackage[left=28mm, right=28mm, top=13mm, bottom=18mm, noheadfoot]{geometry}

\begin{document}

\begin{titlepage}
	\let\endtitlepage\relax
	\center
	\begin{minipage}{2.3cm}
		\hspace*{-0.8cm}\includegraphics[width=2.3cm]{img/mini}
	\end{minipage}
	\hfill
	\begin{minipage}{2.3cm}
		\hspace*{0.8cm}\includegraphics[width=2.3cm]{img/pw}
	\end{minipage}\par
	\global\let\newpagegood\newpage
	\global\let\newpage\relax
\end{titlepage}

\thispagestyle{empty}
\title{\textbf{Management Protocol\\for~Linux Workstations}}
\author{\texorpdfstring{%
	\footnotesize
	\begin{minipage}{.5\textwidth}
	\centering
	\emph{Author:} Patryk Bęza\\[-1pt]
	\texttt{\href{mailto:P.Beza@student.mini.pw.edu.pl}{P.Beza@student.mini.pw.edu.pl}}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
	\centering
	\emph{Thesis supervisor:} dr inż.~Marek Kozłowski\\[-1pt]
	\texttt{\href{mailto:M.Kozlowski@mini.pw.edu.pl}{M.Kozlowski@mini.pw.edu.pl}}
\end{minipage}}{The Author}}

%\small Faculty of~Mathematics and~Information Science\\[-8pt]
%\small Warsaw University of Technology\\[-8pt]
%\small Koszykowa 75, 00-662~Warsaw

\date{}

\maketitle
\providecommand{\keywords}[1]{\textbf{\textit{Keywords ---}} #1}
\keywords{\emph{\href{https://en.wikipedia.org/wiki/Software_configuration_management}{Software Configuration Management~(SCM)}}, \emph{\href{https://en.wikipedia.org/wiki/Infrastructure_as_Code}{Infrastructure as Code~(IaC)}}, \emph{\href{https://en.wikipedia.org/wiki/Linux}{Linux}}, \emph{\href{https://en.wikipedia.org/wiki/Communications_protocol}{Communications Protocol}}}
\global\let\newpage\newpagegood
\thispagestyle{empty}

This paper entitled 'Management Protocol for Linux Workstations' concerns the~problem of~automating the~configuration of~a~group of~identically or~similarly configured group of~computers. Its~purpose is to~design and implement an~alternative, more convenient than existing, solution to~prepare and~propagate changes of~the configuration made on~the reference machine --- in~short called the~server --- to~its clients.

Existing SCMs (Software Configuration Managers) that solve the referred problem, such as~those discussed in~this paper --- Puppet, Chef, Ansible and~Salt --- use dedicated meta--configuration languages (Domain Specific Languages) that make it possible to~declaratively describe the~expected configuration of the~clients, i.e.~without specifying specific commands to~execute, but only by~referring to~the~desirable state of~e.g.~file, package or~system user. Using such a~description, that reminds kind of~an~abstraction layer over the~actual configuration, client undertakes actions aimed at~adapting its system configuration to the~requirements written in~the~description. The~created abstraction layer makes it~possible to~support various Linux distributions and~different operating systems, however, this can be achieved at~the~expense of~the~time that the~administrator must devote to~learning the~language of the~chosen SCM tool and to~express the~actual settings of~the~computers controlled by~him.

The~solution presented in~this paper doesn't introduce its own meta-configuration language, therefore on one hand the client and server must have installed Linux distributions with at~least identical hierarchy of~top-level directories (FHS --- Filesystem Hierarchy Standard) and~the same package managers. On~the other hand, the adopted unconventional approach allowed for the~implementation of an~application that facilitates and minimizes the~administrator's work on~the~iterative adaptation of the systems he manages, consequently reducing the risk of~making a~mistake in~the~clients' configuration. The~idea behind the~implemented server's application consists of~three, sequential steps --- modifying the~reference server system as~if it was a~client's system, scanning it to~generate a~snapshot of~its configuration state, and automatically creating an~applicable configuration snapshot image based on the~generated snapshots. The~prepared implementation introduces template files containing placeholders, which are replaced with client--specific values during the~application of~the~snapshot image --- for example placeholders can correspond to~the~client's network name or~its selected environment variable. The~exchange of~the~configuration snapshot images can take place over the~network both between the~server and its clients, as~well as~between the~clients themselves.

\end{document}
